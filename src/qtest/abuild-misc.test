#!/usr/bin/env perl

require 5.008;
BEGIN { $^W = 1; }
use strict;
use File::Copy;

require TestDriver;
require abuild_test_utils;

chdir("abuild-misc") or die;

my $td = new TestDriver("miscellaneous");
test_setup();

my $top = get_top();
my $filters = get_filters();

# This test suite is a place where we dump additional random tests to
# exercise very specific features or to exercise previously detected
# bugs.

setup($td);

cd("work/codegen-wrapper");

for my $i (1, 2)
{
    my $description = "codegen-wrapper: " .
	($i == 1 ? "run command" : "use cached");

    $td->runtest($description,
		 {$td->COMMAND => "abuild",
		  $td->FILTER => "perl $filters/filter-abuild.pl"},
		 {$td->FILE => "$top/codegen-wrapper$i.out",
		  $td->EXIT_STATUS => 0},
		 $td->NORMALIZE_NEWLINES);

    if (! in_windows())
    {
	$td->runtest("check executable",
		     {$td->STRING =>
			  (-x "abuild-indep/b/out1" ? "yes\n" : "no\n")},
		     {$td->STRING => "yes\n"});
    }

    foreach my $f (qw(out1 b/out1 out2))
    {
	my $out = "codegen-wrapper-$f.out";
	$out =~ s,/,-,g;
	$td->runtest("check $f",
		     {$td->FILE => "abuild-indep/$f"},
		     {$td->FILE => "$top/$out"},
		     $td->NORMALIZE_NEWLINES);
    }

    $td->runtest("check cache",
		 {$td->COMMAND => "find cache -type f -print | LANG=C sort"},
		 {$td->FILE => "$top/cache-contents.out",
		  $td->EXIT_STATUS => 0},
		 $td->NORMALIZE_NEWLINES);

    $td->runtest("clean",
		 {$td->COMMAND => "abuild clean",
		  $td->FILTER => "perl $filters/filter-abuild.pl"},
		 {$td->FILE => "$top/codegen-wrapper-clean.out",
		  $td->EXIT_STATUS => 0},
		 $td->NORMALIZE_NEWLINES);
}

cd("work/autoconf");

$td->runtest("autoconf compiler invocation",
	     {$td->COMMAND => "abuild -b all",
	      $td->FILTER => "perl $filters/filter-abuild.pl"},
	     {$td->FILE => "$top/autoconf.out",
	      $td->EXIT_STATUS => 0},
	     $td->NORMALIZE_NEWLINES);

cd("work/plugin-anywhere");

# tree1 has "plugin".  tree2 has tree1 as an external and declares
# "plugin" as a plugin.  tree3 has both tree1 and tree2 in that order
# as externals and does not declare "plugin" as a plugin.  abuild 1.0
# had a bug that caused plugin's interface to not get created.
$td->runtest("plugin-anywhere",
	     {$td->COMMAND => "abuild -C tree3",
	      $td->FILTER => "perl $filters/filter-abuild.pl"},
	     {$td->FILE => "$top/plugin-anywhere.out",
	      $td->EXIT_STATUS => 0},
	     $td->NORMALIZE_NEWLINES);

# Dependency on multiple instances of an interface.  "a" depends on
# two different platforms instances of "b".

cd("work/double-dep/good");

$td->runtest("double dependency on an item",
	     {$td->COMMAND => "abuild -b all",
	      $td->FILTER => "perl $filters/filter-abuild.pl"},
	     {$td->FILE => "$top/double-dependency.out",
	      $td->EXIT_STATUS => 0},
	     $td->NORMALIZE_NEWLINES);

cd("work/double-dep/bad");

$td->runtest("double dependency error",
	     {$td->COMMAND => "abuild -b all",
	      $td->FILTER => "perl $filters/filter-abuild.pl"},
	     {$td->FILE => "$top/double-dependency-error.out",
	      $td->EXIT_STATUS => 2},
	     $td->NORMALIZE_NEWLINES);

# Build set construction cases that require multiple passes of
# resolving traits, build-also directives, etc.

cd("work/multipass/a");

$td->runtest("multipass build-also explicit targets",
	     {$td->COMMAND => "abuild -d check",
	      $td->FILTER => "perl $filters/filter-abuild.pl"},
	     {$td->FILE => "$top/multipass.out",
	      $td->EXIT_STATUS => 0},
	     $td->NORMALIZE_NEWLINES);

$td->runtest("build-also and related-by-traits",
	     {$td->COMMAND => "abuild -d check --related-by-traits trait",
	      $td->FILTER => "perl $filters/filter-abuild.pl"},
	     {$td->FILE => "$top/multipass.build-also-traits.out",
	      $td->EXIT_STATUS => 0},
	     $td->NORMALIZE_NEWLINES);

cd("work/multipass");

$td->runtest("build-also and only-with-traits",
	     {$td->COMMAND => "abuild -b all check --only-with-traits trait",
	      $td->FILTER => "perl $filters/filter-abuild.pl"},
	     {$td->FILE => "$top/multipass.only-with-traits.out",
	      $td->EXIT_STATUS => 0},
	     $td->NORMALIZE_NEWLINES);

$td->runtest("clean",
	     {$td->COMMAND => "abuild -c all",
	      $td->FILTER => "perl $filters/filter-abuild.pl"},
	     {$td->FILE => "$top/multipass.clean.out",
	      $td->EXIT_STATUS => 0},
	     $td->NORMALIZE_NEWLINES);

validate_dump_data($td);

cd("work/non-recursive");

$td->runtest("non-recursive interface variable",
	     {$td->COMMAND => "abuild -b all",
	      $td->FILTER => "perl $filters/filter-abuild.pl"},
	     {$td->FILE => "$top/non-recursive-interface.out",
	      $td->EXIT_STATUS => 0},
	     $td->NORMALIZE_NEWLINES);

cd("work/ro-rw-path");

$td->runtest("ro-rw-path: none specified",
	     {$td->COMMAND => "abuild -b all",
	      $td->FILTER => "perl $filters/filter-abuild.pl"},
	     {$td->FILE => "$top/ro-rw-default.out",
	      $td->EXIT_STATUS => 0},
	     $td->NORMALIZE_NEWLINES);
$td->runtest("ro-rw-path: ro only",
	     {$td->COMMAND => "abuild -b all --ro-path=a",
	      $td->FILTER => "perl $filters/filter-abuild.pl"},
	     {$td->FILE => "$top/ro-a.out",
	      $td->EXIT_STATUS => 0},
	     $td->NORMALIZE_NEWLINES);
$td->runtest("ro-rw-path: clean ro only",
	     {$td->COMMAND => "abuild -c all --ro-path=a",
	      $td->FILTER => "perl $filters/filter-abuild.pl"},
	     {$td->FILE => "$top/ro-a-clean.out",
	      $td->EXIT_STATUS => 0},
	     $td->NORMALIZE_NEWLINES);
$td->runtest("ro-rw-path: rw only",
	     {$td->COMMAND => "abuild -b all --rw-path=p/q",
	      $td->FILTER => "perl $filters/filter-abuild.pl"},
	     {$td->FILE => "$top/rw-p-q.out",
	      $td->EXIT_STATUS => 0},
	     $td->NORMALIZE_NEWLINES);
$td->runtest("ro-rw-path: clean rw only",
	     {$td->COMMAND => "abuild -c all --rw-path=p/q",
	      $td->FILTER => "perl $filters/filter-abuild.pl"},
	     {$td->FILE => "$top/rw-p-q-clean.out",
	      $td->EXIT_STATUS => 0},
	     $td->NORMALIZE_NEWLINES);
cd("work");

$td->runtest("ro-rw-path: ro on top",
	     {$td->COMMAND => "abuild -b all -C ro-rw-path" .
		  " --ro-path=a --rw-path=a/b --ro-path=a/b/c",
	      $td->FILTER => "perl $filters/filter-abuild.pl"},
	     {$td->FILE => "$top/ro-a-rw-b-ro-c.out",
	      $td->EXIT_STATUS => 0},
	     $td->NORMALIZE_NEWLINES);
$td->runtest("ro-rw-path: rw on top",
	     {$td->COMMAND => "abuild -b all -C ro-rw-path" .
		  " --rw-path=p --ro-path=p/q --rw-path=a/b/c",
	      $td->FILTER => "perl $filters/filter-abuild.pl"},
	     {$td->FILE => "$top/rw-p-ro-q-rw-c.out",
	      $td->EXIT_STATUS => 0},
	     $td->NORMALIZE_NEWLINES);
$td->runtest("ro-rw-path: errors",
	     {$td->COMMAND => "abuild -b all -C ro-rw-path" .
		  " --rw-path=p --ro-path=a --rw-path=w",
	      $td->FILTER => "perl $filters/filter-abuild.pl"},
	     {$td->FILE => "$top/ro-rw-errors.out",
	      $td->EXIT_STATUS => 2},
	     $td->NORMALIZE_NEWLINES);

cd("work/optional-deps");

for (my $i = 1; $i <= 2; ++$i)
{
    my $suf = ($i == 1 ? "no-t3" : "t3");

    $td->runtest("optional deps ($suf)",
		 {$td->COMMAND => "abuild -C t1/a",
		  $td->FILTER => "perl $filters/filter-abuild.pl"},
		 {$td->FILE => "$top/optional-$suf.out",
		  $td->EXIT_STATUS => 0},
		 $td->NORMALIZE_NEWLINES);
    $td->runtest("dumpdata",
		 {$td->COMMAND => "abuild --dump-data",
		  $td->FILTER => "perl $filters/filter-abuild.pl"},
		 {$td->FILE => "$top/optional-$suf-dumpdata.out",
		  $td->EXIT_STATUS => 0},
		 $td->NORMALIZE_NEWLINES);
    validate_dump_data($td);

    copy("Abuild-with-t3.conf", "Abuild.conf") or die;
}

cd("work/symlink-ext");

if (! in_windows())
{
    symlink "target", "link" or die;
    symlink "ext.target", "ext" or die;
    $td->runtest("symlinked externals",
		 {$td->COMMAND => "abuild --dump-data",
		  $td->FILTER => "perl $filters/filter-abuild.pl"},
		 {$td->FILE => "$top/symlinked-external.out",
		  $td->EXIT_STATUS => 0},
		 $td->NORMALIZE_NEWLINES);
}
else
{
    system("(tar cf - . | cat > /dev/null)");
}

check_work_accessed($td, "not-accessed.out");

$td->report(37 + (in_windows() ? 0 : 3));
