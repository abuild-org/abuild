
This file contains fragments of documentation to be integrated into
the manual.

----------------------------------------------------------------------

Miscellaneous
=============

 * Read through all 1.1 release notes and update the body of the
   documentation accordingly.

 * Note: references to ant examples are still in the documentation.
   There are comments like <!-- ?example ....? --> marking where the
   file references used to be.  Files can be found in the abuild-ant
   test suite.  Paths that used to start with java now start with
   basic.

 * Points to include in codegen-wrapper documentation:

    - usually, --input $^ --output $@ is sufficient.  Sometimes output
      generates more files than just $@ though and you have to specify
      them.

    - tries to detect whether input file was found in "." or "..".
      Although the code tries to be written so that it doesn't matter
      what --src points to, it has only been tested for when --src is
      "..".

    - FLEX_CACHE, BISON_CACHE

 * Mention somewhere that people can copy jars into abuild's lib
   directory if I want that to be something people do...

 * Describe somewhere why we don't provide information about platforms
   in the interface files for java and indep.  Basically, it would be
   a bug to have an interface variable have a different value in
   different contexts when it might influence a build that could be
   used on multiple platforms.  For example, an indep build item could
   write out some value based on a platform variable and then that
   information could be wrong when the results of the build were used
   on a different platform.  If you really need to know what platform
   you are on for something indep or java, you can always get the
   information using a cross-platform dependency, which at least makes
   it visible.  But remember that text files containing
   platform-dependent values (like pathnames, etc.) are in fact
   platform-dependent.

 * Mention that we don't support descrpition for unnamed build items,
   including nameless tree roots, because we don't store anything
   about unnamed build items.  If you want a description in your tree
   root, give it a name.  Comments are allowed anywhere.

 * For msvc toolchain, document MSVC_GLOBAL_FLAGS,
   MSVC_MANAGEMENT_FLAGS, and MSVC_RUNTIME_FLAGS.  See comments in
   msvc.mk.

 * Update **/*-help.txt.  Write help files for all built-in toolchains
   and rules.

 * Document built-in interface variables in help/vars.txt

 * New acknowledgements: Brian Reid, Kathleen Locher, Joe Schettino,
   Brandon Barlow for help with the Java redesign and 1.1 testing

 * Document ABUILD_FORCE_32BIT and ABUILD_FORCE_64BIT.  See release
   notes.  Mention somewhere that all support for this can be found
   for searching for FORCE_WORDSIZE in the code.  The only references
   are in private/bin/get_native_platform_data and
   make/toolchains/gcc.mk.

 * Autoconf: remember to mention attributes: serial.  Also, mention
   the serial attribute in the description of --make-jobs.

 * Mention somewhere that the native platform components are
   determined by private/bin/get_native_platform_data.  If there were
   a need to tweek this, this would be the only place that would have
   to be changed.

----------------------------------------------------------------------

Read-only Build Items
=====================

In abuild 1.1, read-only externals are no longer supported, and there
is no mechanism for giving tree-deps similar semantics.  Instead, a
much more flexible and unambiguous mechanism has been provided for
controlling which build items are writable.

The --ro-path=dir and --rw-path=dir command line options to tell
abuild to treat some or all build items as read only based on path.
This is a more robust approach than using read-only externals for
preventing cross-tree builds when they are not desired.  Consider
these trees:

      A
    / | \
   B  C  D

If B and D both have C as a tree dependency and are independent
from each other, you might want to build C first and then have both
B and D built in parallel while treating C as read only.  This
would provide a way to do that.

For another example, suppose A has a read-only external pointing to B,
and B has a read-only external pointing to a subtree somewhere under
A.  When A does a descending build, part of itself will be read only
because of the external in B.  Even then, this behavior is subject to
the order in which externals are listed.  All in all, read-only
externals were a bad idea.

Both --ro-path=dir and --rw-path=dir may appear multiple times.  If
only --ro-path appears, build items are writable by default.  If only
--rw-path appears, build items are read-only by default.  If both
appear, then either every --ro-path must be a path under some
--rw-path (in which case build items are read-only by default) or
every --rw-path must be path under some --ro-path (in which case build
items are writable by default).  These rules make it possible to
unambiguously create any combination of read-only/writable build items
without having the order of the arguments matter.

Paths may be absolute or relative.  Relative paths are resolved
relative to the starting directory of abuild (after any -C is
evaluated).

When determining whether a build item is read only, the
determination is made based on the lowest directory in the path to
the item for which a read/write status is specified.  If none is
found, the default is used.


Upgrading Build Trees from 1.0 to 1.1
=====================================

Abuild can help you with the process of upgrading your build trees
from 1.0 format to 1.1 format.  This chapter describes how to use
abuild to help you perform these updates.

Outline
-------

Here is an outline of the basic process:

 * cd to a directory that is above all your build trees and that you
   wish to use as the new "forest root".

 * run "abuild --upgrade-trees"

 * abuild --upgrade-trees will analyze all Abuild.conf files and
   generate a file called "abuild.upgrade-data" that you will have to
   edit.  Edit the file as described in this document.

 * Rerun "abuild --upgrade-trees".  Once abuild has all the
   information it needs, it will perform the upgrade by rewriting any
   Abuild.conf or Abuild.backing that needs to be rewritten.  The
   original file will be renamed to Abuild.conf-1_0 or
   Abuild.backing-1_0.  When you are satisfied with the upgrade, you
   can delete the *-1_0 files, as those files are not used by abuild
   under any circumstance.

Generally, if you have a backing area, you should upgrade the backing
area first.  If your backing areas are set up properly and you have
not added any new trees in your area, the upgrade of the backing area
may work without any intervention, as abuild will use the backing area
to figure out tree names for trees that are backed.


Information You Will Need
-------------------------

Among the most significant changes to abuild for version 1.1 is the
requirement that all build trees have names.  In order for abuild to
upgrade your trees from version 1.0 to version 1.1, it will need to
know what name you wish to assign to all your build trees.  You will
use the "abuild.upgrade-data" file to provide this information to
abuild.  Once it has all the required information, abuild will insert
the "tree-name" key into the root Abuild.conf file of every tree, and
it will replace any "external-dirs" keys with "tree-deps" keys.  It
will also remove "parent-dir" keys, replace "this" with "name",
upgrade "Abuild.backing" files, and move any occurrences of "deleted"
from root "Abuild.conf" files into the forest-wide "Abuild.backing"
file.

The "abuild.upgrade-data" File Format
-------------------------------------

QUICK START

 * For each directory whose contents you wish to (recursively) ignore,
   place the directory in the [ignored-directories] section.  Place
   one directory per line, and specify directories relative to the one
   containing this file.

 * For each detected build tree root below, replace '***' with the
   name you intend to give the tree.

 * Rerun abuild --upgrade-data

DETAILS

This is a configuration file used to assist abuild --upgrade-trees.
Every time abuild --upgrade-trees is run, it will replace this file,
so any comments or formatting changes you make will be lost.  Any
tree names you assign will be preserved.

The abuild.upgrade-data file consists of sections Each section is
opened with a line of the form

[section-name]

where "section-name" is replaced by one of the valid section names.

There are three sections: one [ignored-directories] lists directories
that will be skipped during the upgrade, any number of [forest]
sections list all the trees abuild finds to be in a given forest, and
an optional [orphan-trees] section is used to hang onto names
previously assigned to any trees that no longer appear in a known
forest.

The "abuild --upgrade-trees" command recursively scans the current
directory looking for Abuild.conf files.  It reads every Abuild.conf
file that it can find and analyzes them to determine what build trees
are available.  Based on the relationships it detects among the build
trees by looking at each tree's external-dirs entry, it creates a list
of possible forests.  Each forest is a group of build trees that refer
to each other in some way.  The list of forests is generated such that
no tree in one forest refers to any tree in another forest through any
of its items' Abuild.conf files.  In other words, all forests are
expected to be completely independent.  There are several cases in
which you might have multiple forests.  Normal cases could include
self-contained groups of build trees inside of test suites or abuild
setups to build third-party packages or other external software.
There may also be erroneous cases resulting from stray Abuild.conf
files that are not connected to the rest of the trees.  You should
examine the list of forests carefully to determine whether there are
stray files that you wish to remove.

The "abuild --upgrade-trees" functionality fully supports partially
upgraded trees.  It is okay to upgrade forests that have a mixture of
1.0-style and 1.1-style trees in them.  This means you do not have
upgrade your trees all at the same time.

If there are directories below the current directory that you wish to
ignore during the conversion process, list them in the
[ignored-directories] section.

In each forest that abuild discovers, it will require a name for each
tree.  If the tree already has a name, that name will appear filled in
below.  Otherwise, the place-holder '***' will appear.

In some cases, there may be a tree that you are not ready to upgrade,
perhaps because that tree is still being used by a project that hasn't
yet upgraded its version of abuild.  In that case, you may list the
path to the root of the tree in the [ignored-directories] section.
You do not need to remove it from the [forest] section in which it
appears; abuild will remove it from there automatically next time it
writes the file.

Abuild is able to perform the actual upgrade when all of the following
conditions are met:

 * Abuild is able to parse all Abuild.conf files at or below the
   current directory, excluding any ignored directories, without
   finding any errors.

 * Every external-dirs entry exists (or can be resolved through a
   backing area).

 * Every tree root listed in a given [forest] section has a name
   assigned to it.

 * Every tree that abuild finds during its scan as well as every
   external-dirs entry referenced by those trees appears in a [forest]
   section and has a name assigned to it.

Abuild is usually able to upgrade forests with backing areas, but it
will not do so if any externals resolve to 1.0-style trees in backing
areas.  In that case, you must either upgrade the backing area or make
the external resolve locally.  You can make the external local by just
creating a directory and populating it with an Abuild.conf and an
Abuild.backing.  The reason for this restriction is that abuild will
not read the Abuild.backing file of an upgraded tree root that is not
at the root of a forest.  This means that abuild would no longer be
able to resolve the external in the backing area.  Generally, when
possible, it is best to upgrade your backing area first anyway since
upgrades to forests with upgraded backing areas often require no
manual intervention.


Rationale for Changing Build Tree Structure
===========================================

A principal failing in abuild 1.0 stems from the use of paths to
specify the locations of external build trees -- "external-dirs" is
used to convey both dependency and location information.  This is
against a fundamental design principle of abuild and must be
corrected.  Another serious problem is the interaction between
backing areas and externals: setting up backing areas for trees
with lots of externals is complex to the point of being
impractical.

Projects that desire certain parts of their trees to be potentially
compile-time independent from other parts have to break things into
multiple trees and use externals.  This sometimes results in build
areas consisting of many more trees than I envisioned in my
original design.  (I had originally envisioned externals as being a
rarely-used feature, primarily intended for supporting builds at
multiple classification levels or supporting central libraries of
reusable build items.)

Consider first the case of externals without backing areas.  If
there are multiple build trees with complex "external"
relationships between them, then there is an implicit build
"forest" consisting of multiple build trees which must be organized
relative to each other in a particular way.  Knowledge of this
relative organization of trees is not represented in any one place
but rather is distributed through all the root Abuild.conf files,
usually with considerable but non-obvious duplication of knowledge
(exactly the situation abuild's name-based organization was
designed to avoid).  For example, if A, B, C, and D are build trees
whose roots are under a common parent, you could have a situation
in which A declares ../B and ../C as externals and B declares ../D
as an external.  There is no single place where A, B, C, and D are
even all mentioned, yet abuild will require them to all be in the
same directory.  This situation becomes much worse when build trees
are at different levels -- the same tree may be referred to by
multiple different relative paths.  This creates great confusion,
and makes it very to move a tree around or even find who is
referencing a particular tree.

When backing areas are added to the mix, the problem is further
compounded.  If a build tree contains other external build trees
nested inside of it, use of a backing area with the parent tree, in
practice, requires use of a specific backing area on the child
tree, especially when externals need to be resolved from a backing
area.  Consider this arrangement of build trees:

   A       F
 / | \    /
B  C  D  G
|
E

with the following external relationships:

E -> C, D
D -> G

Suppose you have a backing area forest containing A and F, and a
local build area containing only A.  In this case, in the local A,
it is necessary to have backing areas for E, C, and D in, and they
all have to point to the right locations under A's backing area.
In addition to that, people remain generally in the dark about how
externals are resolved through backing areas.  It's
(understandably) hard for people to understand the idea that a
relative path expressed in an Abuild.conf file may be resolve
relative to another directory that is listed in an Abuild.backing
file.

In defense of the original design, when abuild was a simple perl
script that used "make" to do most of its work, this made the
initial implementation very easy -- abuild just replaced the tree
top path with the backing area path and re-invoked itself.
However, given the current state of abuild's evolution and an
understanding of how these features are actually used, it is
obvious that the current implementation is no longer tenable.

It is clear that build trees deserve to be named entities, and that
just as is true with build items, the location of any given tree
must appear in only one place within a build area.  It is also
clear that use of backing areas when multiple trees are involved is
too cumbersome to be practical.


Revamped Build Tree Structure
=============================

Introduce the concept of a "build forest".  A build forest is a
collection of related build trees that are physically located under a
common root.  Build forests already exist with abuild 1.0, but they
are not an explicit entity.

Eliminate the parent-dir key.  Build item X's parent directory is the
next higher directory, if any, whose Abuild.conf lists X's directory
in its child-dirs key.  We must enforce that child-dirs may not
contain .. in any path element, and that there are no intervening
Abuild.conf files between a parent and child Abuild.conf.

Require build tree root Abuild.conf files to include a "tree-name" key
which provides the name of the build tree.  Any Abuild.conf file may
contain a tree-name key.  This makes it the root of a subtree, which
functions very much as externals do in abuild 1.0.  Subtrees are
hooked into the forest like any other build item: through a
higher-level directory's child-dirs key.

Eliminate the external-dirs key.  Introduce in its place a "tree-deps"
key which takes a list of tree names rather than tree paths.  Since we
have no longer have the concept of externals, we no longer have the
concept of read-only externals.  To support the pattern of building a
tree without building any of the other subtrees that it uses, users
must specify --ro-path or --rw-path on the command line at build time.
Absolute path externals also disappear, but they were a bad idea to
begin with.

Allow Abuild.backing files only at forest roots, and allow multiple
backing areas.  Introduce a new Abuild.backing syntax in which one or
more backing areas may be specified in a backing-areas keyword, as in

  backing-areas: /path/to/ba1 /path/to/ba2

Backing areas as searched in the order in which they appear, and in a
depth-first fashion.  The normal integrity guarantee still applies.
If one backing area backs to another, the further back one is ignored,
but no message is issued since this is an allowable case that can
happen in normal circumstances.  A discussion appears in a comment in
the code.  If there are multiple independent backing areas, they must
all be disjoint; i.e., they may not supply the same items or trees.

Disallow build item directories from being symbolic links.  When a
symbolic link is detected, suggest for people to use a backing area
instead.  This is more practical with support for multiple backing
areas.

Traits, supported flags, and plugins behave with respect to subtrees
in 1.1 just as they behaved with respect to externals in 1.0.  This
means that it is still necessary to repeat plugin declaration lists
for each subtree.  Although this is somewhat unfortunate, it makes it
possible to have reasonable semantics when building an isolated
subtree outside of the context of a backing area.

Example:

  OLD:

   Top-level Abuild.conf files in each leaf below.  No way to know of
   all build trees or their relative positions without visiting each
   root.  No way to get list of build tree roots other than exhaustive
   search.

   top                  (no Abuild.conf)
   |
   |-- common           root Abuild.conf; no externals
   |
   |-- proj1
   |   |
   |   |-- interface
   |   |   |
   |   |   |-- comp1    external-dirs: ../../../common
   |   |   |
   |   |   `-- comp2    external-dirs: ../../../common
   |   |
   |   `-- private
   |       |
   |       |-- comp1    external-dirs: ../../interface/comp1
   |       |
   |       `-- comp2    external-dirs: ../../interface/comp2 ../comp1
   |
   `-- proj2
       |
       |-- common       external-dirs: ../../common
       |
       |-- comp1        external-dirs: ../common
       |
       `-- comp2        external-dirs: ../comp1

  Note that ../../common from proj2/common is the same as
  ../../../common from proj1/interface/comp1 and different from
  ../common in proj2/comp1.


  NEW:

   Top-level Abuild.conf file in top directory; subtrees are hooked in
   with child-dirs just like any other subdirectory.

   top                  tree-name: top
   |
   |-- common           tree-name: common
   |
   |-- proj1
   |   |
   |   |-- interface
   |   |   |
   |   |   |-- comp1    tree-name: proj1-comp1; tree-deps: common
   |   |   |
   |   |   `-- comp2    tree-name: proj1-comp2; tree-deps: common
   |   |
   |   `-- private
   |       |
   |       |-- comp1    tree-name: proj1-comp1-impl; tree-deps: proj1-comp1
   |       |
   |       `-- comp2    tree-name: proj1-comp2-impl;
   |                    tree-deps: proj1-comp2 proj1-comp1
   `-- proj2
       |
       |-- common       tree-name: proj2-common; tree-deps: common
       |
       |-- comp1        tree-name: proj2-comp1; tree-deps: proj2-common
       |
       `-- comp2        tree-name: proj2-comp2; tree-deps: proj2-comp1



Compatibility
=============

Starting with version 1.1, abuild runs with a compatibility level
equal to x.y where x.y is a released major/minor version.  In version
1.1, the only valid compatibility levels are 1.0 and 1.1.  When abuild
is running at compatibility level x.y, backward compatibility is
disabled for features deprecated at or before version x.y.  For
example, at compatibility level 1.0, abuild will recognize the "this"
keyword in Abuild.conf, issue a deprecation warning, and treat it as
if it were "name".  At compatibility level 1.1, abuild will not
recognize the "this" key at all.

The default compatibility level is 1.0.  At the present time, there is
no expectation of supporting compatibility levels more than one minor
release old, but this general capability level framework would make
that possible if it were desired.

When abuild recognizes feature from a version between the
compatibility level and the current version, it will issue a
deprecation warning.  Abuild can be run in a mode in which deprecation
warnings are treated as errors.  There will be no option for
suppressing deprecation warnings.

Compatibility mode will work by having abuild map a 1.0 structure into
the internal representation of a 1.1 structure.  Compatibility does
not apply to the command-line invocation of abuild, but only to
Abuild.conf and other build files.  There are some corner cases where
abuild will possibly fail in compatibility mode, such as with
interleaved build items (parent and child dirs skipping over each
other) or backing areas that point to different backing forests, but
the goal is for all "normal" abuild 1.0 trees to create the same
builds with 1.1 as with 1.0.

With pure abuild 1.1, a build item is a build tree root iff it has a
tree-name key.  In pure abuild 1.0, a build item was a build tree root
iff it did not have parent-dir key.  In 1.1 operating at 1.0
compatibility level, the logic is somewhat more complex.  See comments
in ItemConfig::isTreeRoot() for details on how the determination is made.

Note that a build item with only a child-dirs key in its Abuild.conf
can be a forest root even if it is not a tree root.

Deprecation warnings on old trees: detect if any build item in a tree
uses deprecated features.  This includes both using deprecated keys
and also being a root and not having tree-name.  If that happens for
any item in the tree, issue a single deprecation warning that points
to the user to abuild --upgrade-trees.

If the root of the tree has tree-name, point to the specific build
item that has the deprecated features.  This may indicate a partially
upgraded tree or someone accidentally using an old key.

In all of the above, remember that external-dirs can still appear in a
1.1 root build item if it points to an external tree that has not yet
been converted, and that 1.0 root can have an external-dirs that
points to a 1.1 tree.

----------------------------------------------------------------------

Optional Dependencies

 * tree-deps: tree-name -optional
 * deps: item -optional

In the case of optional tree dependencies, abuild will not complain if
the specified tree dependency is not found.

In case of optional item dependencies, abuild will not complain if the
specified item dependency is not found.  Additionally, the optional
item will be ignored when it appears as a trait referent item in the
build item that declares it as optional.  Additionally, for every
build item that is declared as an optional dependency, a local
(non-inheriting) boolean interface variable called
ABUILD_HAVE_OPTIONAL_DEP_item is created an initialized to true if the
item exists and to false otherwise.  This makes it possible for a
build item to test in its Abuild.interface or backend build file for
whether the dependency has been satisfied.

Note that, in both cases, when an optional dependency does not exist,
abuild removes it from the dependency list of the item that declared
it.  The effect of declaring an optional dependency (or tree
dependency) is local to the item that makes the declaration.  In other
words, if two build items declare a dependency on a third item and
only one of the declares it as optional, it is an error if the third
item doesn't exist, but that error will only be reported for the item
that did not declare its dependency to be optional.

When an optional item dependency or tree dependency is to an item or
tree that is not found, the name of the item or tree is listed in
<optional-tree-dependencies> or <optional-dependencies> in the
dumpdata output.


Help System
===========

Write this section.  See abuild --help help for details.

For every file x.{mk,groovy} in toolchains or rules, either built in
or provided by a build item, if x-help.txt exists, it is a help file
for that toolchain or rule.  The file is just displalyed, with
newlines normalized to the native newline, and with any lines starting
with "#" removed.

For internal help files in help, help/topic.txt is displayed by abuild
--help topic.  The first line can start with "## description: " in
which case the rest of the line is a description displayed by --help
help.
