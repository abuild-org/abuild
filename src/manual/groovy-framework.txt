Miscellaneous Points to Incorporate
===================================

 * Lazy jar signing is true by default in order to have idempotent
   builds


Guidelines For Groovy Target Authors
====================================

 * Coding style recommendation: all groovy files loaded by abuild are
   scripts.  The scripts should generally explicitly define a class
   and then instantiate it.  This provides a "fence" to protect us
   against certain types of errors, such as mistyping a field name and
   ending up adding something to the binding instead.

 * All defaults should be overridable through parameter settings.
   Don't repeat maven's mistake of locking the user into its own build
   conventions.

 * Targets should be written to be configurable to the maximum
   possible extent, even to the point of having ways of causing them
   to do nothing.  Although the interface has a way to completely
   override existing targets, using the capability should be reserved
   for extreme cases.  Targets may use abuild.runActions to facilitate
   this.

 * Targets should be parameter driven.  Parameters should provide
   defaults.  Users can override defaults by modifying preset
   parameters or setting keys in maps that are appended to general
   parameters.  Initialize parameters in _base.groovy (for built-in
   rules) or plugin.groovy (for rules provided by plugins).  These are
   loaded before Abuild.groovy.  Abuild.groovy can manipulate
   parameters set in initialization as needed.  No mechanism, at the
   moment, is provided for pre-initializing parameters for build
   item-supplied rules.  Maybe we need to add one, but this facility
   may not really be needed.

 * For groovy backends, defining a new test procedure requires only
   defining a closure for the 'test-only' target.  Abuild
   automatically calls this from test or check.

 * Build item paths (abuild.itemPaths[item])


"abuild" Object Interface
=========================

Would be nice to be able to generate this with groovydoc...

(check code)

 * Fields:

    - interfaceVars: a map corresponding to the values from
      Abuild.interface; all values are strings or lists of strings

    - defines: a map of variables defined on the command line; all
      values are strings

    - params: a map of parameters defined by the user in
      Abuild.groovy; keys are strings, but values can be any Object
      or null

    - buildDirectory: a File object containing the build directory

    - sourceDirectory: a File object containing the source directory

 * Methods:

    - configureTarget('name', named parameters) {
	  closureBody()
      }

      registers target 'name'; i.e., causes it to exist if it does
      not already exist

      if closure body is not null, adds it to the list of closures
      for target 'name'

      if 'deps' named parameter is specified, its value must be a
      string or a list of strings; each dependency is added as a
      dependency of name

      if 'replaceClosures' named parameter is specified, its value
      must be a boolean; if true, removes any closures associated
      with 'name' before (possibly) adding any specified closure

    - configureTarget('name')

      calls full configureTarget with no named parameters or closure
      body

    - addTarget('name') -- synonym for above form of configureTarget

    - configureTarget('name', named parameterse)

      calls full configureTarget with no closure body

    - addTargetDependencies('name', ['dep1', 'dep2'])

      calls configureTarget('name', 'deps': ['dep1', 'dep2'])

    - configureTarget('name') {
	  closureBody()
      }

      calls full configureTarget with no named parameters

    - addTargetClosure('name') {
	  closureBody()
      }

      synonym for above form of configureTarget

    - setParameter('name', value)

      Sets parameter 'name' to value, replacing any previous value
      that may have been set.

    - appendParameter('name', value)

      If parameter 'name' has been previously set with setParameter
      (and not subsequently deleted), this is an error.  Otherwise,
      makes the value of the parameter a list and appends value to
      it.

    - deletedParameter('name')

      Removes any previous value for parameter 'name'.

    - resolve('name', defaultValue)

      If defines['name'] exists, return it
      else if params['name'] exists, return it
      else if interfaceVars['name'] exists, return it
      else return defaultValue

      Effect: defines override everything else, params overrides
      interface, basically resulting in the same behavior as make
      and ant

      If 'name' names a parameter that may occur a variable number
      of times, it is up to the caller to deal with it.
      Alternatively, if you expect null or a single String, use
      resolveAsString, and if you expect one or more items and want
      to handle the result uniformly, use resolveAsList.

    - resolve('name')

      calls resolve('name', null)

    - resolveAsString('name', defaultValue)

      If resolve('name', defaultValue) returns other than null or a
      string, fail.  Otherwise, return value as type String.

    - resolveAsString('name')

      calls resolveAsString('name', null)

    - resolveAsList('name', defaultValue)

      If resolve('name', defaultValue) returns a list, return that
      value.  Otherwise, return a list containing that value.  This
      makes it convenient to deal with parameters whose values may
      contain a single value or a list of values without having to
      handle the special case in the target.


    - runActions(String targetParameter, Closure defaultAction,
		 Map defaultAttributes)

      targetParameter, if defined, resolves to a list whose elements
      are either maps or closures.  If not defined, it is treated as
      if its value were a list containing an empty map.

      For each element, if it is a closure, call it.  If it is a map,
      then expand the map by copying entries from defaultAttributes
      for keys that are not present in the map.  Then call
      defaultAttributes on the resulting map.

    - fail(String message)

      cause the build to fail immediately by throwing an instance of
      AbuildBuildFailure

    - error(String message)

      issue an error message and continue to the end of the
      closure; the build is considered to have failed, so (unless -k
      has been specified) no additional closures will be called

    - runTarget(target)

      runs target preceded by its full dependency chain; no target
      is ever run more than once

    - runTargets([target, ...])

      runs each target specified in order (with the order possibly
      overridden based on the dependency graph)

 * org.abuild.groovy.Util

    - absToRel(path, basedir) -- convert "path" into a path relative to
      "basedir".

    - field inWindows is true if in Windows


QTest Support
=============

 * parameter 'qtest.export' contains a list of "variables".  For each
   variable listed, an upper-case version of the variable name is
   exported to the environment with the value returned by
   getVariableAsString.

 * The value of "TESTS" is automatically exported.  This is used by
   qtest to restrict the list of test suites to run.
