<?xml version='1.0'?>
<!DOCTYPE book [
<!ENTITY Abuild "Abuild">
<!ENTITY abuild "abuild">
<!ENTITY ldquo "&#x201C;">
<!ENTITY rdquo "&#x201D;">
<!ENTITY mdash "&#x2014;">
<!ENTITY swversion "1.0-pre">
<!ENTITY lastreleased "November 21, 2007">
<!ENTITY example "../../doc/example">
<!ENTITY testdir "../qtest/abuild">
]>
<!--

Possible fop/stylesheet bugs:

 * A line break can occur before either of the +'s in "C++" and
   after hyphens in command-line options

 * <indexterm/> generates a hard space.

 * footnotes from list items don't seem to work as of fop 0.94.
   Search for comment containing "end footnote".

Possible stylesheet considerations:

 * Consider putting "example" and maybe "qtest" processing
   instructions in a formal listing/example element if we can get it
   to have a title of "Listing" instead of "Example".  See also
   Program listings chapter in DocBook XSL.

BEFORE EACH RELEASE

 * update sversion and lastreleased above

 * make sure a real date has been included in the release notes

PLEASE READ THESE IMPORTANT NOTES ABOUT EDITING THIS DOCUMENT.

This document confirms to docbook 4.4.  In order to make maintaining
this document as convenient as possible, we explicitly do not deviate
from strict docbook by doing things like adding additional elements.
Instead, we adopt certain conventions.

Place a blank line before each <programlisting> start tag.  This
prevents fill-paragraph in nxml-mode from filling the contents of the
programlisting element when run from the text preceding the
programlisting.  Do not put an extra blank line after the end tag or
put the start tag flush left as these will interfere with future line
indentation.

Each chapter, section, or appendix is given an id that starts with
"ref.".  Each example section is given an id that starts with
"ref.example.".  We use the "example" processing instruction to
include the contents of a file from doc/example.  Our processing
program requires the example to appear in a section whose id starts
with "ref.example.".  In order for this check to work, the id
attribute must be on the same line as the opening tag for the
section.  The list-of-examples processing instruction is used at the
end of the document to generate a list of links to each example in the
document.  Since we have examples spread throughout the document, this
makes it easier for people who just want examples to find them
quickly.

We also make use of the "qtest" processing instruction to pull files
from the "../src/qtest/abuild" directory, the "dump-data"
processing instruction to include the DTD for the dump data format,
and the "ccxx-mk" processing instruction to include ccxx.mk.
Our processing program requires processing instructions to be on a
line by themselves, so it is technically not a purely xml-aware
processor.

In normal writing when "abuild" is not part of a command, use the
entities "&Abuild;" for "Abuild" at the beginning of a sentence (or
when it would be capitalized such as in a title) and "&abuild;"
otherwise.  We typeset it as a plan unadorned word because doing
otherwise makes the document visually jarring.

We use the phrase "depend on" rather than "depend upon" to refer to
dependency relationships among build items.

Whenever appropriate, this document makes use of the following
technical character classes (definitions below from "Docbook: The
Definitive Guide"):

   classname - The name of a class, in the object-oriented programming sense
   command - The name of an executable program or other software command
   constant - A programming or system constant
   envar - A software environment variable
   filename - The name of a file
   firstterm - The first occurrence of a term
   function - The name of a function or subroutine, as in a programming language
   literal - Inline text that is some literal value
   option - An option for a software command
   replaceable - Content that may or must be replaced by the user
   type - The classification of a value
   varname - The name of a variable

We somewhat misuse the firstterm element in this document as a way to
italicize terms when they are used for the first time in a given
section of the document.  Some terms may appear more than once inside
the firstterm element.

Several types of items discussed in the document do not fit neatly
into one of the categories above.  For those, we have adopted
conventions which are illustrated in the Typographic Conventions
section.  Please see that to find out exactly what the conventions
are, and please follow them when editing this document.

When maintaining this document, keep in mind that if a section is
modified, you should check for references to that section to make sure
that the referencing text remains accurate.

There are certain conventions that we follow in the figures.  Please
see README-dia in the figures directory.

Before releasing this document after making major edits, do the
following checks:

 * Make sure all files are checked in and abuild passes its test
   suite.  The documentation extracts materials from the test suite
   and assumes that the test suite passes.

 * Make sure swversion and lastreleased are set appropriately and
   referenced in the document.

 * Make sure there are no occurrences of the straight double-quote
   character outside of examples or comments.

-->
<book>
 <bookinfo>
  <title>&Abuild; Users' Manual</title>
  <subtitle>For &Abuild; Version &swversion;, &lastreleased;</subtitle>
  <author>
   <firstname>Jay</firstname><surname>Berkenbilt</surname>
  </author>
  <copyright>
   <year>2007</year>
   <holder>Jay Berkenbilt, Argon ST</holder>
  </copyright>
  <legalnotice>
   <para>
    This software and documentation may be distributed under the terms
    of version 2 of the Artistic License which may be found in the
    source and binary distributions.  They are provided &ldquo;as
    is&rdquo; without express or implied warranty.
   </para>
  </legalnotice>
 </bookinfo>
 <preface id="ref.how-to-read-this-manual">
  <title>How to Read This Manual</title>
  <para>
   Welcome to the &abuild; manual!  You may always find the latest
   copy of this manual on <ulink
   url="http://www.abuild.org">&abuild;'s website</ulink>.  This
   manual is designed to get you up and running with &abuild; quickly.
   Then, when you are ready, you can come back for documentation on
   the full depth of &abuild;'s functionality.  The most essential and
   common topics are presented first so that top-down learners can
   just start at the beginning and stop reading when they feel that
   they've seen enough to get going.  If you come across something in
   the first reading that you don't understand, it's probably safe to
   skip it and come back when you're more comfortable.  As each new
   concept is presented, it is enhanced with examples.  A list of all
   the examples in the document can be found in <xref
   linkend="ref.list-of-examples"/>.  If you are just looking for
   changes from previous versions of &abuild;, please see <xref
   linkend="ref.release-notes"/>.
  </para>
  <para>
   This manual is divided into four parts.  Each part of the document
   draws on material introduced in the earlier parts.  Although
   earlier parts of the documentation are intended to be
   understandable without the material from the later parts, they
   contain forward cross references where appropriate.
  </para>
  <para>
   In <xref linkend="ref.part1"/>, we cover basic information that
   should help you come up to speed on using &abuild; for day-to-day
   work.  It is geared toward people who are working on an existing
   software baseline that uses &abuild;.  In Part I, you will learn
   about what &abuild; is and the types of problems it was designed to
   solve, be introduced to some basic terminology, and see a few
   examples of how to perform some simple build operations.  This part
   of the manual is very short and is designed to be readable in one
   sitting.  Casual users of &abuild; may have no need to read past
   Part I.
  </para>
  <para>
   In <xref linkend="ref.part2"/>, we introduce the most common
   features of &abuild;.  All the basic features are covered, and a
   few advanced features are covered.  All the information you need
   for simple projects has been presented by the end of Part II.
  </para>
  <para>
   In <xref linkend="ref.part3"/>, we introduce advanced topics.  Part
   III opens with complete reference guides to &abuild;'s command-line
   options and all the files used by &abuild;.  By the end of Part
   III, you will have been exposed to every feature of &abuild;.
  </para>
  <para>
   <xref linkend="ref.part4"/> consists of a small handful of
   appendices.
  </para>
  <para>
   For those wishing to go still deeper, the &abuild; source code is
   heavily commented, and the software comes with a thorough automated
   test suite that covers every feature of the software and many error
   conditions as well.
  </para>
 </preface>
 <preface id="ref.acknowledgments">
  <title>Acknowledgments</title>
  <para>
   The creation of &abuild; would not have been possible without the
   enthusiastic support of my employer, <ulink
   url="http://www.argonst.com">Argon ST</ulink>.  Argon not only
   recognized the important role of a strong build tool in
   contributing to the overall quality and reliability of its
   software, but saw the value of releasing it to the open source
   community in hopes of making an even broader contribution.
  </para>
  <para>
   There are many people within Argon who helped take &abuild; to
   where it is now, but among these, a handful of people deserve
   special mention:
   <itemizedlist>
    <listitem>
     <para>
      Chris Costa, who served as a sounding board and contributed
      numerous ideas throughout the entire development process of
      &abuild;, including conducting a thorough review of this
      document
     </para>
    </listitem>
    <listitem>
     <para>
      Andrew Hayden, who spent many hours reviewing and critiquing
      this entire document and who was the visionary behind Xenon, the
      &abuild; Eclipse plugin
     </para>
    </listitem>
    <listitem>
     <para>
      Joe Davidson, the primary &abuild; evangelist who has been
      invaluable in getting &abuild; to become as widely accepted
      within Argon ST as it is
     </para>
    </listitem>
    <listitem>
     <para>
      Gavin Mulligan, who has consistently taken the time to report
      any problem, no matter how small, and who is probably
      responsible for reporting more issues than everyone else
      combined
     </para>
    </listitem>
    <listitem>
     <para>
      Bob Tamaru, who in addition to being a mentor and supporter for
      most of my career, provided considerable assistance to me as I
      presented the case to Argon ST to allow me to release &abuild;
      as an open source project
     </para>
    </listitem>
   </itemizedlist>
  </para>
 </preface>
 <preface id="ref.preface-documentation-format">
  <title>Notes About Documentation Formatting</title>
  <para>
   This manual is written in docbook.  The PDF version of the manual
   was generated with Apache fop, which as of this writing, is still
   incomplete.  There are a few known issues with the PDF version of
   the documentation.  Hopefully these issues will all be addressed as
   fop matures.
   <itemizedlist>
    <listitem>
     <para>
      There are many bad line breaks.  Sometimes words are incorrectly
      hyphenated, and line breaks also occur between two dashes in
      command line options and even between the two
      <literal>+</literal> characters of &ldquo;C++&rdquo;.
     </para>
    </listitem>
    <listitem>
     <para>
      In many of the example listings, there are lines that would be
      longer than the shaded boxes in the PDF output.  We wrap those
      lines and place a backslash (<literal>\</literal>) character
      just before and after the extra line breaks.  This is done for
      both the HTML and the PDF output even though the long lines are
      only a problem for the PDF output.
     </para>
    </listitem>
    <listitem>
     <para>
      Some paragraphs appear to have extra indentation.  This is
      because the formatting software generates a hard space whenever
      we have an index term marker in the text.
     </para>
    </listitem>
    <listitem>
     <para>
      There are no bookmarks.  It would be good if we could create
      bookmarks to the chapter headings, but as of this writing, the
      documented procedure for doing this does not appear to work.
     </para>
    </listitem>
   </itemizedlist>
  </para>
 </preface>
 <part id="ref.part1" label="I">
  <title>Quick Start</title>
  <partintro id="ref.part1.intro">
   <para>
    The material contained in this part is geared toward new and
    casual users of &abuild;.  Without going into excessive detail,
    this part gives you a quick tour of &abuild;'s functionality and
    presents a few examples of routine build operations.  By the end
    of this part, you should be able to use &abuild; for simple build
    operations, and you should have begun to get a feel for the basic
    configuration files.
   </para>
  </partintro>
  <chapter id="ref.introduction">
   <title>Introduction</title>
   <sect1 id="ref.introduction.overview">
    <title>&Abuild; Overview</title>
    <para>
     &Abuild; is a system designed to build large software projects or
     related families of software projects that are divided into a
     potentially large number of components.  It is specifically
     designed for software projects that are continually evolving and
     that may span multiple languages and platforms.  The basic idea
     behind &abuild; is simple: when building a single component
     (module, unit, etc.) of a software package, the developer should
     be able to focus on that component exclusively.  &Abuild;
     requires each component developer to declare, by name, the list
     of other components on which his or her component depends.  It is
     then &abuild;'s responsibility to provide whatever is needed to
     the build environment to make other required items visible.
    </para>
    <para>
     You might want to think of &abuild; as an
     <firstterm>object-oriented build system</firstterm>.  When
     working with &abuild;, the fundamental unit is the
     <firstterm>build item</firstterm>.  A build item is essentially a
     single collection of code, usually contained within one
     directory, that is built as a unit.  A build item may produce one
     or more products (libraries, executables, JAR files, etc.) that
     other build items may want to use.  It is the responsibility of
     each build item to provide information about its products that
     may be used by other items that depend on it.  This information
     is provided by a build item in its &abuild;
     <firstterm>interface</firstterm>.  In this way, knowledge about
     how to use a build item is encapsulated within that build item
     rather than being spread around throughout the other components
     of a system.
    </para>
    <para>
     To implement this core functionality, &abuild; provides its own
     system for managing build items as well as the dependencies and
     relationships among them.  It also provides various build rules
     implemented with underlying tools, specifically <application>GNU
     Make</application> and <application>Apache Ant</application>, to
     perform the actual build steps.  We refer to these underlying
     tools as <firstterm>backends</firstterm>.  Although the bulk of
     the functionality and sophistication of &abuild; comes from its
     own core capabilities rather than the build rules, the rules have
     rich functionality as well.  &Abuild; is intended to
     <emphasis>be</emphasis> your build system.  It is not intended,
     as some other tools are, to wrap around your existing build
     system.
     <footnote>
      <para>
       &Abuild; can, however, interoperate with other build systems as
       needed, which may be useful while transitioning a software
       development effort to using &abuild;.
      </para>
     </footnote>
    </para>
    <para>
     Support for compilation in multiple programming languages and on
     multiple platforms, including embedded platforms, is central to
     &abuild;'s design.  &Abuild; is designed to allow build items to
     be built on multiple platforms simultaneously.  An important way
     in which &abuild; achieves this functionality is to do all of its
     work inside of an <firstterm>output directory</firstterm>.  When
     &abuild; performs the actual build, it always creates an output
     directory named
     <filename>abuild-<replaceable>platform</replaceable></filename>
     and invokes the backend in that directory.  By actually invoking
     the backend in that directory, &abuild; avoids the situation of
     temporary files conflicting with each other on multiple
     simultaneous builds of a given build item on multiple platforms.
     &Abuild; is designed to never create or remove any output files
     outside of its output directories.  This enables &abuild;'s
     cleanup operation to simply remove all output directories created
     by any instance of &abuild;, and also reduces the likelihood of
     unintentionally mixing generated products with version-controlled
     sources.
    </para>
   </sect1>
   <sect1 id="ref.typographic-conventions">
    <title>Typographic Conventions</title>
    <para>
     The following list shows the font conventions used throughout
     this document for the names of different kinds of items.
     <simplelist>
      <member><literal>literal text</literal></member>
      <member><replaceable>replaceable text</replaceable></member>
      <member>
       <classname>build items</classname> and <classname>build item
       scope names</classname>
      </member>
      <member>
       <property>Abuild.conf keys</property>,
       <property>flags</property>, and <property>traits</property>
      </member>
      <member>
       <varname>Abuild.interface variables</varname>, <varname>java
       properties</varname>, and <varname>make variables</varname>
      </member>
      <member>
       <function>Abuild.interface keywords</function>
      </member>
      <member>
       <command>commands</command>, <command>build targets</command>,
       and <command>ant hooks</command>
      </member>
      <member>
       <option>command line options</option> and <option>build
       sets</option>
      </member>
      <member>
       <envar>environment variables</envar>
      </member>
      <member>
       <filename>file names</filename> and <filename>make rule
       sets</filename>
      </member>
      <member>
       <type>platforms</type>, <type>platform types</type>, and
       <type>target types</type>
      </member>
     </simplelist>
    </para>
   </sect1>
   <sect1 id="ref.introduction.design-features">
    <title>Design Features</title>
    <para>
     This section describes many of the principles upon which &abuild;
     was designed.  Understanding this material is not critical to
     being able to use &abuild; just to do simple compiles, but knowing
     these things will help you use &abuild; better and will provide a
     context for understanding what it does.
    </para>
    <!--
        Terms in this list should grammatically finish the sentence:
        "Abuild conforms to the principle of ...".  Use title case for
        the items below.
    -->
    <variablelist>
     <varlistentry>
      <term>Build Integrity</term>
      <listitem>
       <para>
        &Abuild; puts the integrity of the build over all other
        concerns.  &Abuild; includes several rigorously enforced
        integrity checks throughout its implementation in order to
        prevent many of the most common causes of build integrity
        problems.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Strict Dependency Management</term>
      <listitem>
       <para>
        Build items must explicitly declare dependencies on other build
        items.  These dependencies are declared by name, not by path.
        The same mechanism within &abuild; that is used to declare a
        dependency is also used to provide visibility to the dependent
        build item.  (A build item reads the interfaces of only those
        build items on which it directly or indirectly depends.)  In
        this way, it is impossible to <emphasis>accidentally</emphasis>
        become dependent on something by unwittingly using files that
        it provides.  &Abuild; guarantees that there are no circular
        dependencies among build items and also provides a fundamental
        guarantee that all build items in a dependency chain resolve
        names to paths in a consistent way within the dependency tree.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Directory Structure Neutrality</term>
      <listitem>
       <para>
        Build items refer to each other only by name and never by
        path.  &Abuild; resolves build item names to paths internally
        and provides path information at runtime as needed.  This
        makes any specific &abuild; installation agnostic about
        directory structure and makes it possible to move things
        around without changing any build rules.  In this way,
        &abuild; stays out of the way when it's time to reorganize
        your project.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Focus on One Item at a Time</term>
      <listitem>
       <para>
        When using &abuild;, you are generally able to focus on
        building just the item you are working on without having to
        worry about the details of the items it depends on.  &Abuild;
        does all the work of figuring out what your environment has to
        look like to give you access to your dependencies.  It can
        then start a local build from anywhere and pass the right
        information to that local build.  This is achieved through
        encapsulation of knowledge about a build item's products
        inside the build item itself and making that knowledge
        available to its users through an &abuild;-specific interface.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Environment Independence</term>
      <listitem>
       <para>
        &Abuild; does not require you to have any project-specific or
        source tree-specific environment variables set, be using any
        particular shell or operating system, or have the &abuild;
        software itself installed in any particular location.
        &Abuild; is designed so that having the
        <command>abuild</command> command in your path is sufficient
        for doing a build.  This keeps &abuild; independent from any
        specific source tree or project.  &Abuild; can be used to
        build a single-source-file, stand-alone program or an
        elaborate product line consisting of hundreds or thousands of
        components.  It can be also used for multiple projects on the
        same system at the same time.  No special path settings or
        environment variable settings are required to use &abuild;,
        other than ensuring that the external tools that your build
        requires (GNU Make, compilers, etc.) are available and in your
        path.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Support for Parallel and Distributed Builds</term>
      <listitem>
       <para>
        When building multiple items, &abuild; creates a
        <firstterm>build set</firstterm> consisting of all the items
        to be built.  It computes the directories in which it needs to
        build and invokes the build iteratively in those directories.
        &Abuild; automatically figures out what can be built in
        parallel and what the build order should be by inspecting the
        dependency graph.  &Abuild; avoids many of the pitfalls that
        get in the way of parallel and distributed operation including
        recursive execution, shell-based loops for iteration, file
        system-based traversal, and writing files to the source
        directory.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Support for Multiple Platforms</term>
      <listitem>
       <para>
        &Abuild; was designed to work on multiple platforms.  It
        includes a structure for referring to platforms and for
        encapsulating platform-specific knowledge.  This makes it
        easier to create portable build structures for portable code.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Efficiency</term>
      <listitem>
       <para>
        &Abuild; aims to be as efficient as possible without
        compromising build integrity.  &Abuild; calculates as much as
        possible up front when it is first invoked, and it passes that
        information to backend build programs through
        automatically-generated files created inside its own output
        directories.  By computing the information one time, &abuild;
        significantly reduces the degree to which its backend build
        programs' rules have to use external helper applications to
        compute information they need.  &Abuild;'s configuration files
        and build tree traversal steps are designed in such a way that
        &abuild; never has to perform unbounded searches of a build
        tree.  This enables startup to be fast even on build trees
        containing thousands of build items.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Encapsulation</term>
      <listitem>
       <para>
        Build items encapsulate knowledge about what is required by
        their users in order to make use of them at build time.  The
        user may also create build items with restricted scope, thus
        allowing private things to be kept private.  This makes it
        possible to refactor or reorganize individual components of a
        system without affecting the build files of other build items
        that depend on them.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Declarative Build Files</term>
      <listitem>
       <para>
        The majority of build item configuration files are
        declarative: they contain descriptions of what needs to be
        done, rather than information about how to do it.  Most end
        user configuration files contain nothing but variable settings
        or key/value pairs and are independent of the platform or
        compiler used to build the item.  For those cases in which a
        declarative system is insufficient to express what needs to do
        be done, &abuild; provides several mechanisms for specific
        steps to be defined and made available to the items that need
        them.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Support for Multiple Backends</term>
      <listitem>
       <para>
        The parts of &abuild; that manage dependencies and build
        integrity are distinct from the parts of &abuild; that
        actually perform builds.  Initial versions of &abuild; can use
        either <application>GNU Make</application> or
        <application>Apache Ant</application> to perform builds.  The
        internal integration between &abuild; and its backend build
        programs is fairly loose, and adding additional backends would
        require relatively minor and localized code changes.  In
        addition, &abuild; requires only the backends that a
        particular build tree uses to be present on your system when
        you are performing a build.  That is, if you are building only
        Java code, you don't need <application>GNU Make</application>,
        and if you're building only C and C++ code, you don't need
        <application>Apache Ant</application>.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
  </chapter>
  <chapter id="ref.installation">
   <title>Building and Installing &Abuild;</title>
   <sect1 id="ref.system.requirements">
    <title>System Requirements</title>
    <para>
     You may always find the latest version of &abuild; by following
     the links on <ulink url="http://www.abuild.org">&abuild;'s
     website</ulink>.  To use &abuild;, the following items must be
     available on your system:
    </para>
    <itemizedlist>
     <listitem>
      <para>
       <ulink url="http://www.gnu.org/software/make/"><application>GNU
       Make</application></ulink> version 3.81 or higher is required
       if you are building any build items that use <application>GNU
       Make</application> as a backend.  This would include
       platform-independent code and C/C++ code, but not Java code.
      </para>
     </listitem>
     <listitem>
      <para>
       <ulink url="http://ant.apache.org/"><application>Apache
       Ant</application></ulink> version 1.7.0 or newer with <ulink
       url="http://ant-contrib.sourceforge.net/"><application>ant-contrib</application></ulink>
       version 1.0.b3 or later installed in ant's lib directory is
       required if you are building any Java code.  &Abuild;'s own
       Java code requires a Java 5 Java SDK, but it could likely be
       ported fairly easily to any Java SDK that can build Apache Ant.
      </para>
     </listitem>
     <listitem>
      <para>
       <ulink url="http://www.perl.com/">Perl</ulink> version 5.8 or
       newer is required if you are performing any GNU Make-based
       builds.
      </para>
     </listitem>
     <listitem>
      <para>
       Perl version 5.8 or newer and <ulink
       url="http://qtest.qbilt.org/">qtest</ulink> version 1.0 or
       newer are required if you are using the qtest automated test
       framework.  &Abuild;'s own test suite uses qtest.
      </para>
     </listitem>
     <listitem>
      <para>
       If you are planning on building any GNU Make-based build items
       on Windows, <ulink url="http://www.cygwin.com/">Cygwin</ulink>
       is required.  For a Java-only &abuild; installation on Windows,
       Cygwin and Perl are not required.  It is hoped that a future
       version of &abuild; will not require Cygwin.  For details on
       using Cygwin with &abuild;, please see <xref
       linkend="ref.windows-requirements"/>.
      </para>
     </listitem>
    </itemizedlist>
    <para>
     To build &abuild;, you must also have version 1.33.1 or newer of
     the <ulink url="http://www.boost.org/">boost</ulink> regex and
     thread libraries.
     <footnote>
      <para>
       &Abuild; is known to work with the boost 1.32 in Red Hat
       Enterprise Linux 4, but it may not work with that version of
       boost on other systems.  It has also been tested with boost
       1.34 and 1.34.1.
      </para>
     </footnote>
     &Abuild; is known to buildable by gcc, xlc, Microsoft Visual C++
     (7.1 or newer), and <ulink
     url="http://www.mingw.org/">mingw</ulink>, and it should be
     buildable by on any system and with any compiler that supports
     the boost thread and regular expression libraries.  &Abuild;
     itself contains C++ code and Java code, so all the runtime
     requirements for both systems are required to build &abuild;.
    </para>
    <para>
     Since &abuild; determines where it is being run from when it is
     invoked, a binary distribution of &abuild; is not tied to a
     particular installation path.  It finds the root of its
     installation directory by walking up the path from the &abuild;
     executable until it finds a directory that contains
     <filename>make/abuild.mk</filename>.  This makes it easy to have
     multiple versions of &abuild; installed simultaneously, and it
     also makes it easy to create relocatable binary distributions of
     &abuild;.
    </para>
    <para>
     &Abuild; itself does not require any environment variables to be
     set, but <application>ant</application> and/or the Java
     development environment may.  If you have the
     <envar>ANT_HOME</envar> environment variable set, &abuild; will
     honor it when selecting which copy of
     <application>ant</application> to run.  Otherwise, it will run
     <application>ant</application> from your path.
    </para>
    <para>
     As you begin using &abuild;, you may find yourself generating a
     collection of useful utility build items for things like specific
     third-party libraries, external compilers, documentation
     generators, or test frameworks.  There is a small collection of
     contributed build items in the
     <filename>abuild-contrib</filename> package, which is available
     at <ulink url="http://www.abuild.org">&abuild;'s web
     site</ulink>.  These may have additional requirements.  For
     details, please see the information about
     <filename>abuild-contrib</filename> on the website.
    </para>
   </sect1>
   <sect1 id="ref.installation.build">
    <title>Building &Abuild;</title>
    <para>
     &Abuild; is self-hosting: it can be built with itself, or for
     bootstrapping, it can be built with a GNU Makefile that uses
     &abuild;'s internal <application>GNU Make</application> support.
     To build &abuild;'s Java code, you also need <application>Apache
     Ant</application> and a Java development environment.  Please see
     the file <filename>src/README.build</filename> in the source
     distribution for instructions on building abuild.
    </para>
   </sect1>
   <sect1 id="ref.installation.install">
    <title>Installing &Abuild;</title>
    <para>
     If you are creating a binary distribution or installing from
     source, please see the file <filename>src/README.build</filename>
     in the source directory.  If you are installing from a pre-built
     binary distribution, simply extract the binary distribution in
     any directory.  &Abuild; imposes no requirements on where the
     directory should be or what it should be called as long as its
     contents remain in the correct relative locations.  You may make
     a symbolic link to the actual <filename>bin/abuild</filename>
     executable from a directory in your path.  &Abuild; will follow
     this link when attempting to discover the path of its
     installation directory.  You may also add the &abuild;
     distribution's <filename>bin</filename> directory to your path,
     or invoke &abuild; by the full path to its executable.
    </para>
   </sect1>
   <sect1 id="ref.windows-requirements">
    <title>Additional Requirements for Windows Environments</title>
    <para>
     To build &abuild; and use it in a Windows environment for
     <application>make</application>-based builds, certain pieces of
     the <ulink url="http://www.cygwin.com/">Cygwin</ulink>
     environment are required.
     <footnote>
      <para>
       This may cease to be true in a future version of &abuild;.
      </para>
     </footnote>
     Note that &abuild; is able to build with and be built by Visual
     C++ on Windows.  It uses Cygwin only for its development tools.
     Cygwin is not required to run executables built by &abuild; in a
     Windows environment, including &abuild; itself.  However, Cygwin
     is required to supply <command>make</command> and
     <command>perl</command> to &abuild;.  The following parts of
     Cygwin are required:
     <variablelist>
      <varlistentry>
       <term>Devel</term>
       <listitem>
        <simplelist>
         <member>autoconf</member>
         <member>automake</member>
         <member>make</member>
        </simplelist>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>System</term>
       <listitem>
        <simplelist>
         <member>rebase</member>
        </simplelist>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Util</term>
       <listitem>
        <simplelist>
         <member>diffutils</member>
        </simplelist>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Perl is required, but appears to be installed by default in recent
     Cygwin installations.
    </para>
    <para>
     Note that rebaseall (from the rebase package) may need to be run
     in order for <function>fork</function> to work from perl with
     certain modules.  (Although &abuild; itself doesn't call
     <function>fork</function> from perl,
     <application>qtest</application>, which is used for &abuild;'s
     test suite, does.)
    </para>
    <para>
     Other modules may also be desirable.  In particular,
     <filename>libxml2</filename> from the <filename>Text</filename>
     section is required in order to run certain parts of &abuild;'s
     test suite, though the test suite will just issue a warning and
     skip those tests without failing if it can't find
     <command>xmllint</command>.
    </para>
    <para>
     If you intend to use autoconf from Windows and you have Rational
     Rose installed, you may need to create
     <filename>/usr/bin/hostinfo</filename> (inside of the Cygwin
     environment) as

     <programlisting>#!/bin/false
</programlisting>
     so that <command>./configure</command>'s running of
     <command>hostinfo</command> doesn't run
     <command>hostinfo</command> from Rational Rose.
    </para>
    <para>
     In order to use Visual C++ with &abuild;, you must have your
     environment set up to invoke Visual C++ command line tools.  This
     can be achieved by running the shortcut supplied with Visual
     Studio, or you can create a batch file on your own.  The
     following batch file would enable you to run &abuild; from a
     Cygwin environment with the environment set up for running Visual
     C++ from Visual Studio 7.1 (.NET 2003):

     <programlisting>@echo off
call "%VS71COMNTOOLS%"\vsvars32.bat
C:\cygwin\cygwin.bat
</programlisting>
     Adjust as needed if your Cygwin is installed other than in
     <filename>C:\cygwin</filename> or you have a different version of
     Visual C++ installed.
    </para>
    <para>
     In order to use <application>qtest</application> with &abuild;
     under Windows, the Cygwin version of Perl must be the first
     <command>perl</command> in your path.
    </para>
   </sect1>
   <sect1 id="ref.version-control">
    <title>Version Control Considerations</title>
    <para>
     &Abuild; creates output directories in the source directory, and
     all generated files are created inside of these
     &abuild;-generated directories.  All output directories are named
     <filename>abuild-*</filename>.  It is recommended that you
     configure hooks or triggers in your version control system to
     prevent these directories or their contents from being
     accidentally checked in.  It may also be useful to prevent
     <filename>Abuild.backing</filename> from being checked in since
     this file always contains information about the local
     configuration rather than something that would be CM controlled.
     If it is your policy to allow these to be checked in, they should
     be prevented from appearing in shared areas such as the trunk.
     <footnote>
      <para>
       Note, however, that the &abuild; test suite contains
       <filename>Abuild.backing</filename> files, so any CM system
       that contains &abuild; must have an exception for &abuild;
       itself.  It's conceivable that other tools could also have
       reasons to have checked in <filename>Abuild.backing</filename>
       files in test suites or as templates.
      </para>
     </footnote>
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.basic-operation">
   <title>Basic Operation</title>
   <para>
    In this chapter, we will describe the basics of running &abuild;
    on a few simple build items, and we will describe how those build
    items are constructed.  We will gloss over many details that will
    be covered later in the documentation.  The goal of this chapter
    is to give you enough information to work on simple build items
    that belong to existing build trees.  Definitions of
    <firstterm>build item</firstterm> and <firstterm>build
    tree</firstterm> appear below.  More detailed information on them
    can be found in <xref linkend="ref.build-items-and-trees"/>.  The
    examples we refer to in this chapter can be found in
    <filename>doc/example/basic</filename> in your &abuild; source or
    binary distribution.
   </para>
   <sect1 id="ref.system-considerations">
    <title>System Considerations</title>
    <para>
     &Abuild; imposes few system-based restrictions on how you set it
     up and use it, but here are a few important things to keep in
     mind:
     <itemizedlist>
      <listitem>
       <para>
        Avoid putting spaces in path names wherever possible.
        Although &abuild; tries to behave properly with respect to
        spaces in path names and is known to handle many cases
        correctly, <application>make</application> is notoriously bad
        at it.  If you try to use spaces in path names, it is very
        likely that you will eventually run into problems as they
        generally cause trouble in a command-line environment.
       </para>
      </listitem>
      <listitem>
       <para>
        Be careful about the lengths of path names.  Although &abuild;
        itself imposes no limits on this, you may run up against
        operating system limits if your paths are too long.  In
        particular, Windows has a maximum path name length of 260
        characters.  If you have a build tree whose root already has a
        long path and you then have Java classes that are buried deep
        within a package-based directory structure, you can bump into
        the 260-character limit faster than you'd think.  On Windows,
        it is recommended that you keep your build tree roots as close
        to the root of the drive as possible.  On any modern UNIX
        system, you should not run into any path name length issues.
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect1>
   <sect1 id="ref.basic-terminology">
    <title>Basic Terminology</title>
    <para>
     Here are a few basic terms you'll need to get started:
     <variablelist>
      <varlistentry>
       <term>build item</term>
       <listitem>
        <para>
         <indexterm>
          <primary>build item</primary>
         </indexterm>
         <indexterm>
          <primary>build item</primary>
          <secondary>current</secondary>
         </indexterm>
         A <firstterm>build item</firstterm> is the most basic item
         that is built by &abuild;.  It usually consists of a directory
         that contains files that are built.  Any directory that
         contains an <filename>Abuild.conf</filename> file is a build
         item.  We refer to the build item whose
         <filename>Abuild.conf</filename> resides in the current
         directory as the <firstterm>current build item</firstterm>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>build tree</term>
       <listitem>
        <para>
         <indexterm>
          <primary>build tree</primary>
         </indexterm>
         A <firstterm>build tree</firstterm> is a collection of build
         items arranged hierarchically in the file system.  All build
         items in a build tree may refer to each other by name.  Each
         build item knows the locations of its parents and children
         within the file system hierarchy and the names of the build
         items on which it depends.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>target</term>
       <listitem>
        <para>
         <indexterm>
          <primary>
           target
          </primary>
         </indexterm>
         A <firstterm>target</firstterm> is some specific product to
         be built.  The term &ldquo;target&rdquo; means exactly the
         same thing with &abuild; as it does with other build systems
         such as <application>make</application> or
         <application>ant</application>.  In fact, with the exception
         of a small handful of &ldquo;special&rdquo; targets, &abuild;
         simply passes any targets given to it onto the backend build
         system for processing.  The most common targets are
         <command>all</command> and <command>clean</command>.  For a
         more complete discussion of targets, see <xref
         linkend="ref.targets"/>.  Be careful not to confuse
         <firstterm>target</firstterm> with <firstterm>target
         type</firstterm>, defined in <xref
         linkend="ref.platform-structure"/>.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     For a more complete description of build items and build trees,
     please see <xref linkend="ref.build-items-and-trees"/>.
    </para>
   </sect1>
   <sect1 id="ref.example.basic.cxx-library">
    <title>Building a C++ Library</title>
    <para>
     The directory <filename>cxx-library</filename> under
     <filename>doc/example/basic</filename> contains a simple C++
     library.  Our library is called
     <filename>basic-library</filename>.  It implements the single C++
     class called <classname>BasicLibrary</classname> using the header
     file <filename>BasicLibrary.hh</filename> and the source file
     <filename>BasicLibrary.cc</filename>.  Here are the contents of
     those files:
     <?example basic/cxx-library/BasicLibrary.hh?>
     <?example basic/cxx-library/BasicLibrary.cc?>
     Building this library is quite straightforward.  &Abuild;'s build
     files are generally declarative in nature: they describe what
     needs to be done rather than how it is done.  Building a C or C++
     library is a simple matter of creating an
     <filename>Abuild.mk</filename> file that describes what the names
     of the library targets are and what each library's sources are,
     and then tells &abuild; to build the targets using the C and C++
     rules.  Here is this library's <filename>Abuild.mk</filename>
     file:
     <?example basic/cxx-library/Abuild.mk?>
     The string <filename>ccxx</filename> as the value of the
     <varname>RULES</varname> variable indicates that this is C or C++
     code (&ldquo;c&rdquo; or &ldquo;cxx&rdquo;).  In order for
     &abuild; to actually build this item, we also need to create an
     <filename>Abuild.conf</filename> file for it.  The existence of
     this file is what makes this into a build item.  We present the
     file here:
     <?example basic/cxx-library/Abuild.conf?>
     In this file, the <property>this</property> key is used to
     specify the name of the build item, the
     <property>parent-dir</property> key is used to connect this build
     item into the build tree, and the
     <property>platform-types</property> key is used to help &abuild;
     figure out on which platforms it should attempt to build this
     item.  Finally, we want this build item to be able to make the
     resulting library and header file available to other build items.
     This is done in its <filename>Abuild.interface</filename> file:
     <?example basic/cxx-library/Abuild.interface?>
     This tells &abuild; to add the directory containing this file to
     the include path, the output directory in which the generated
     targets were created to the library path, and the
     <filename>basic-library</filename> library to the list of
     libraries to be linked with.  Notice that the name of the library
     assigned to the <varname>LIBS</varname> variable is the same as
     the value assigned to the <varname>TARGETS_lib</varname> variable
     in the <filename>Abuild.mk</filename> file, and that the
     &abuild;-provided variable
     <varname>$(ABUILD_OUTPUT_DIR)</varname> is used as the library
     directory.
    </para>
    <para>
     To build this item, you would run the command
     <command>abuild</command> in the
     <filename>basic/cxx-library</filename> directory.  &Abuild; would
     create an output directory whose name would start with
     <filename>abuild-</filename> and be based on the platform or
     platforms on which abuild was building this item.  This is the
     directory to which the variable
     <varname>$(ABUILD_OUTPUT_DIR)</varname> refers in the
     <filename>Abuild.interface</filename> file.
    </para>
    <para>
     There is a lot of capability hiding beneath the surface here and
     quite a bit of flexibility in the exact way in which this can be
     done, but this is the basic pattern you will observe for the
     majority of C and C++ library build items.
    </para>
   </sect1>
   <sect1 id="ref.example.basic.cxx-program">
    <title>Building a C++ Program</title>
    <para>
     The directory <filename>basic/cxx-program</filename> contains a
     simple C++ program.  This program links against the library
     created in our previous example.  Here is the main body of our
     program:
     <?example basic/cxx-program/program.cc?>
     This program includes the <filename>BasicLibrary.hh</filename>
     header file from the <classname>cxx-library</classname> build
     item.  Here is the <filename>Abuild.mk</filename> for this build
     item:
     <?example basic/cxx-program/Abuild.mk?>
     Notice that this is very similar to the
     <filename>Abuild.mk</filename> from the library build item.  The
     only real difference is that the <varname>TARGETS</varname> and
     <varname>SRCS</varname> variables contain the word
     <varname>bin</varname> instead of <varname>lib</varname>.  This
     tells &abuild; that these are executable targets rather than
     library targets.  Notice the conspicuous lack of any references to
     the library build item or the location of the headers or libraries
     that it makes available.  A principle feature of &abuild; is that
     this program build item does not need to know that information.
     Instead, it merely declares a dependency on the
     <classname>cxx-library</classname> build item by name.  This is
     done in its <filename>Abuild.conf</filename>:
     <?example basic/cxx-program/Abuild.conf?>
     Notice the addition of the <property>deps</property> key in this
     file.  This tells &abuild; that our program build item
     <firstterm>depends</firstterm> on the library build item.  When
     &abuild; sees this, it automatically makes all the information in
     <classname>cxx-library</classname>'s
     <filename>Abuild.interface</filename> available to
     <classname>cxx-program</classname>'s build, alleviating the need
     for the <classname>cxx-program</classname> build item to know the
     locations of these files.  This will also tell &abuild; that
     <classname>cxx-library</classname> must be built before we can
     build <classname>cxx-program</classname>.
    </para>
    <para>
     To build this item, we could just run the
     <command>abuild</command> command as we did for
     <classname>cxx-library</classname>, but this would only work
     properly if <classname>cxx-library</classname> were already built.
     A better way to build this item would to go to the
     <filename>cxx-program</filename> directory and run <command>abuild
     --with-deps</command>.  The <option>--with-deps</option> option to
     &abuild; tells &abuild; to build all build items that this item
     depends on before building this item itself.  Using the
     <option>--with-deps</option> command line option, you can start a
     build from any build item and let &abuild; automatically take care
     of building all of its dependencies in the correct order.  (For a
     complete list of all of &abuild;'s command line options, please
     see <xref linkend="ref.command-line"/>.)
    </para>
    <para>
     The output of running <command>abuild --with-deps</command> in the
     <filename>cxx-program</filename> directory when starting from a
     clean build is shown below.  Your actual output will differ
     slightly from this.  In particular, the output below has the
     string <literal>--topdir--</literal> in place of the path to
     <filename>doc/example</filename>, and the string
     <literal>&lt;native&gt;</literal> in place of your native
     platform.
     <footnote>
      <para>
       All example output in this document is normalized this way
       since it all comes directly from &abuild;'s test suite.
       Testing all the examples in the test suite guarantees the
       accuracy of the examples and ensures that they work as
       advertised on all platforms for which &abuild; is released.
       Should you wish to study &abuild;'s test suite with the
       examples, be aware that the bold italicized text preceding each
       block of example output is the name of the expected output file
       from the test suite.
      </para>
     </footnote>
     Notice that &abuild; builds
     <classname>cxx-library</classname> first and then
     <classname>cxx-program</classname>:
     <?qtest example.basic-cxx-program.out?>
    </para>
    <para>
     To remove all of the files that &abuild; created in any build
     item's directory, you can run <command>abuild clean</command> in
     that directory.  To clean everything in the build tree, run
     <command>abuild --clean=all</command>.  More details of how to
     specify what to build and what to clean can be found in <xref
     linkend="ref.what-to-build"/>.
    </para>
   </sect1>
   <sect1 id="ref.example.basic.java-library">
    <title>Building a Java Library</title>
    <para>
     In our next example, we'll demonstrate how to build a simple Java
     library.  &Abuild; has two different ways to build Java code: a
     <emphasis>property-driven</emphasis> method, and a
     <emphasis>build.xml-driven</emphasis> method.  The
     property-driven method of building Java code is truer to
     &abuild;'s philosophy of using declarative build files but has
     proven to be inadequate for some of the more complex Java build
     problems that arise in an enterprise environment.  It is hoped
     that a future version of &abuild; will provide a more complete
     answer to the Java build problem, perhaps by integrating with a
     Java build engine other than <application>Apache
     Ant</application>.  In the mean time, we will demonstrate the
     property-driven approach to doing Java builds with &abuild; using
     this library example.  For an example of the build.xml-based
     approach, see <xref linkend="ref.example.build-driven-java"/>.
    </para>
    <para>
     You will find the Java example in
     <filename>basic/java-library</filename>.  The files here are
     analogous to those in our C++ library example.  First, here is a
     Java implementation of our <classname>BasicLibrary</classname>
     class:
     <?example basic/java-library/src/java/com/example/basic/BasicLibrary.java?>
     Next, look at <filename>Abuild.conf</filename>:
     <?example basic/java-library/Abuild.conf?>
     This is essentially identical to our C++ library except that the
     <property>platform-types</property> key has the value
     <property>java</property> instead of the value
     <property>native</property>.  This is always true for Java build
     items.  Next, we'll look at the
     <filename>Abuild-ant.properties</filename> file:
     <?example basic/java-library/Abuild-ant.properties?>
     Property-driven Java build items have this file instead of
     <filename>Abuild.mk</filename>.  The only thing we have to set
     here is the property <varname>abuild.jar-name</varname>.  For
     Java build items, we don't explicitly list the source files.
     Instead &abuild; automatically finds sources in the
     <filename>src/java</filename> directory.  There are more
     properties that can be set, and there are other ways to get files
     into the JAR file.  We provide detailed information about the
     directory structure for property-driven Java builds in <xref
     linkend="ref.directory-structure-for-java-builds"/>.  Finally,
     look at the <filename>Abuild.interface</filename> file.  This
     file provides information to other build items about what they
     should add to their classpaths in order to make use of the JAR
     file created by this build item:
     <?example basic/java-library/Abuild.interface?>
     As with the C++ library, it is possible to build this item by
     running <command>abuild</command> from the
     <filename>basic/java-library</filename> directory.  Notice that
     &abuild; puts the JAR file in the <filename>dist</filename>
     subdirectory of the &abuild; output directory.
    </para>
   </sect1>
   <sect1 id="ref.example.basic.java-program">
    <title>Building a Java Program</title>
    <para>
     In Java, there is really no distinction between a
     &ldquo;library&rdquo; and a &ldquo;program&rdquo; except that a
     JAR file that provides a program must have a
     <function>main</function> method.
     <footnote>
      <para>
       More accurately, if a JAR file contains a main method, it can
       be executed, though it can also be used as a library.  A JAR
       file can also contain a <firstterm>manifest file</firstterm>
       that identifies a class that contains a
       <function>main</function> method.  Although &abuild; allows
       specification of the class containing <function>main</function>
       in the <varname>abuild.main-class</varname> property of
       <filename>Abuild-ant.properties</filename>, this does not
       presently influence the manifest file.  For a discussion, read
       the comments in <filename>ant/abuild.xml</filename> in the
       &abuild; distribution.
      </para>
     </footnote>
     Here are the relevant files for the program example:
     <?example basic/java-program/src/java/com/example/basic/BasicProgram.java?>
     <?example basic/java-program/Abuild.conf?>
     <?example basic/java-program/Abuild-ant.properties?>
     Note the addition of the <varname>abuild.main-class</varname> and
     <varname>abuild.wrapper-name</varname> properties.  If these are
     both set, &abuild; will create a wrapper executable (script file
     and/or batch file as appropriate) so that you can run the
     resulting program with the correct classpath.  The wrapper
     programs are placed directly in the &abuild; output directory.
    </para>
    <para>
     Here is the output of running <command>abuild
     --with-deps</command> in this directory.  As in the C++ program
     example, the output has been modified slightly: in addition to
     the <literal>--topdir--</literal> substitution, we have also
     filtered out time stamps and other strings that could potentially
     differ between platforms:
     <?qtest example.basic-java-program.out?>
    </para>
   </sect1>
  </chapter>
 </part>
 <part id="ref.part2" label="II">
  <title>Normal Operation</title>
  <partintro id="ref.part2.intro">
   <para>
    In this part of the manual, we discuss the standard features of
    &abuild;.  For most ordinary build problems, these chapters
    provide all the information you will need.  A few advanced topics
    are presented here.  Where appropriate, they include cross
    references to later parts of the document where functionality is
    covered in more depth.  By the end of this part, you should have a
    reasonably complete understanding of the structure of &abuild;'s
    build trees, and a fairly complete picture of &abuild;'s overall
    functionality.  You will know enough about &abuild; to be able to
    use it for tasks of moderate complexity.
   </para>
  </partintro>
  <chapter id="ref.build-items-and-trees">
   <title>Build Items and Build Trees</title>
   <para>
    Now that we've had a chance to see &abuild; in action for a simple
    case, it's time to go into a bit more detail about how things fit
    together.  In <xref linkend="ref.basic-terminology"/>, we briefly
    defined the terms <firstterm>build item</firstterm> and
    <firstterm>build tree</firstterm>.  In this chapter, we will
    describe them in bit more detail and briefly introduce a number of
    concepts that apply to them.
   </para>
   <sect1 id="ref.build-items-as-objects">
    <title>Build Items as Objects</title>
    <indexterm>
     <primary>build item</primary>
    </indexterm>
    <para>
     A precise definition of <firstterm>build item</firstterm> would
     state that a build item is any directory that contains an
     <filename>Abuild.conf</filename>.  Perhaps a more useful
     definition would say that a build item is the basic object that
     participates in &abuild;'s object-oriented view of a software
     build.  A build item provides some <emphasis>service</emphasis>
     within a build tree.  Most build items build some kind of code:
     usually a library, executable, or Java archive.  Build items may
     provide other kinds of services as well.  For example, a build
     item may implement a code generator, support for a new compiler,
     or the ability to make use of a third-party software library.  In
     addition, a build item may have certain attributes including a
     list of <firstterm>dependencies</firstterm>, a list of
     <firstterm>supported flags</firstterm>, information about what
     types of platforms the build item may be built on, a list of
     <firstterm>traits</firstterm>, and other non-dependency
     relationships to other build items.  Each of these concepts is
     explored in more depth later in the document.
    </para>
    <para>
     All build items that provide a service are required to have a
     name.  Build item names must be unique within their build tree
     and all other build trees accessible to their build tree since
     the build item name is show &abuild; addresses a build item.
     Build item names consist of period-separated segments.  Each
     segment may contain mixed case alphanumeric characters,
     underscores, and dashes.  Build item names are case-sensitive.
    </para>
    <para>
     The primary mechanism for describing build items is the
     <filename>Abuild.conf</filename> file.  This file consists of
     colon-separated key/value pairs.  A complete description of the
     <filename>Abuild.conf</filename> file may be found in <xref
     linkend="ref.abuild.conf"/>.  In the mean time, we will
     introduce keys as they become relevant to our discussion.
    </para>
   </sect1>
   <sect1 id="ref.build-item-files">
    <title>Build Item Files</title>
    <para>
     Although every build item has an <filename>Abuild.conf</filename>
     file, there are various other files that a build item may have.
     We defer a complete list and detailed discussion these files for
     later in the document, but we touch briefly upon a few of the
     common ones here.
    </para>
    <variablelist>
     <varlistentry>
      <term><filename>Abuild.conf</filename></term>
      <listitem>
       <para>
        This is the most basic of the build item files, and it is the
        only file that must be present for every build item.  We
        sometimes refer to this as the <firstterm>build item
        configuration file</firstterm>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>Abuild.mk</filename></term>
      <term><filename>Abuild-ant.properties</filename></term>
      <term><filename>Abuild-ant.xml</filename></term>
      <listitem>
       <para>
        These are the files that direct &abuild; what to actually
        build in a given build item.  Each build file is associated
        with a specific backend.  Exactly one of these files must be
        present in order for &abuild; to attempt to build a build
        item.  As such, these files are known as <firstterm>build
        files</firstterm>.  When we say that a build item has or does
        not have a build file, we are specifically talking about one
        of these files.  In particular, it is important to note that
        <filename>Abuild.conf</filename> and
        <filename>Abuild.interface</filename> are not considered build
        files.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>Abuild.interface</filename></term>
      <listitem>
       <para>
        The <filename>Abuild.interface</filename> file is present for
        every build item that wants to make some product of its build
        accessible to other build items.  We refer to this as the
        build item's <firstterm>interface file</firstterm>.  There has
        been some confusion among some &abuild; users about the term
        <firstterm>interface</firstterm>.  Please understand that
        &abuild; interfaces are distinct from Java interfaces, C++
        header files, and so forth, though they serve essentially the
        same function.  If you view a build item as an object, the
        &abuild; interface contains information about what services
        that object provides.  It exposes the interfaces through which
        other build items will access a given build item's products.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
   <sect1 id="ref.build-trees">
    <title>Build Trees</title>
    <indexterm>
     <primary>build tree</primary>
    </indexterm>
    <para>
     A build tree, as defined before, is a collection of build items
     arranged hierarchically in the file system.  A build tree is
     formed as a result of the items it contains holding references to
     the locations of their parents and children within the file
     system hierarchy.  These locations are named as relative paths in
     the <property>parent-dir</property> and
     <property>child-dirs</property> keys of the items'
     <filename>Abuild.conf</filename> files.  Ordinarily, the value of
     the <property>parent-dir</property> key is
     &ldquo;<filename>..</filename>&rdquo;, but it doesn't have to be.
     It is also customary to have the value of
     <property>child-dirs</property> contain single path elements
     (<emphasis>i.e.</emphasis>just a file without a directory), but
     this is also not a hard restriction.  When &abuild; starts up, it
     looks for an <filename>Abuild.conf</filename> in the current
     directory and looks for its <property>parent-dir</property> key.
     Using that, it locates the parent build item's
     <filename>Abuild.conf</filename> file and reads it for its
     <property>parent-dir</property> key.  This process is repeated
     until &abuild; discovers a build item that does not have a
     <property>parent-dir</property> key.  This build item is known as
     the <firstterm>root build item</firstterm> of the build tree.
    </para>
    <para>
     Note that the hierarchy defined by the layout of build items in
     the file system is a file system hierarchy and nothing more.  It
     doesn't have to have any bearing at all on the dependency
     relationships among the build items.
     <footnote>
      <para>
       This information is used only at startup to locate the root of
       the build tree and to find the locations of all of the build
       items in the tree so that they may be later referred to only by
       name. In fact, &abuild; doesn't even retain the information
       about the parents and children of build items in the file
       system after it uses the information during startup.
      </para>
     </footnote>
     That said, it is sensible to organize build items in a manner
     that relates to the architecture of the system, and this in turn
     usually has implications about dependencies.  Still, it is
     important to keep in mind that &abuild; is not file-system driven
     but rather is dependency driven.
    </para>
    <para>
     In addition to containing build items, build trees can contain
     other attributes.  Among these are references to other build
     trees, a list of <firstterm>supported traits</firstterm>, and a
     list of <firstterm>plugins</firstterm>.  We will discuss these
     topics later in the document.  Most of a build tree's attributes
     appear in the root build item's <filename>Abuild.conf</filename>
     file.
    </para>
   </sect1>
   <sect1 id="ref.build-item-types">
    <title>Special Types of Build Items</title>
    <para>
     In further describing build items and their attributes, it is
     useful to classify build items into several types.  Most build
     items serve the purpose of providing code to be compiled.  There
     are a number of special types of build items that serve other
     purposes.  We discuss these here:
     <variablelist>
      <varlistentry>
       <term>root</term>
       <listitem>
        <para>
         <indexterm>
          <primary>root build item</primary>
         </indexterm>
         <indexterm>
          <primary>build item</primary>
          <secondary>root</secondary>
         </indexterm>
         The root build item of a build tree is the item in that tree
         that has no <property>parent-dir</property> key.  It is often
         the case that the root build item is unnamed and therefore
         lacks a <property>this</property> key.  (See below for a
         discussion of unnamed build items.)  Keys that define
         attributes of the build tree may appear only in the root
         build item's <filename>Abuild.conf</filename>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>unnamed</term>
       <listitem>
        <para>
         <indexterm>
          <primary>unnamed build item</primary>
         </indexterm>
         <indexterm>
          <primary>build item</primary>
          <secondary>unnamed</secondary>
         </indexterm>
         In order to refer to one build item from another, both build
         items must have names.  &Abuild; requires that every named
         build item in a build tree be named uniquely within that
         tree.  A name is given to a build item by setting the
         <property>this</property> key in its
         <filename>Abuild.conf</filename>.
         <footnote>
          <para>
           Perhaps <property>name</property> would have been a better
           name for this key, but it's too late to change it now.
           This key might be renamed in a future major release of
           &abuild;.
          </para>
         </footnote>
         Sometimes, a build item exists for the sole purpose of
         bridging its parent with its children in the file system.
         Such items do not need to be referenced by other build items,
         so they do not need names.  The only use of an unnamed build
         item is to serve as an intermediary during traversal of the
         file system.  Such a build item's
         <filename>Abuild.conf</filename> may only contain the
         <property>parent-dir</property> and
         <property>child-dirs</property> keys.  &Abuild; doesn't
         retain any information about these build items.  It simply
         traverses through them when locating build items at startup
         time.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>interface-only</term>
       <listitem>
        <para>
         <indexterm>
          <primary>interface-only build item</primary>
         </indexterm>
         <indexterm>
          <primary>build item</primary>
          <secondary>interface-only</secondary>
         </indexterm>
         Interface-only build items are build items that contain (in
         addition to <filename>Abuild.conf</filename>) an
         <filename>Abuild.interface</filename> file.  They do not
         build anything and therefore do not contain build files (such
         as <filename>Abuild.mk</filename> or
         <filename>Abuild-ant.properties</filename>).  Since they have
         nothing to build, &abuild; never actually invokes a backend
         on them.  They are, however, included in all dependency and
         integrity checks.  A typical use of interface-only build
         items would be to add the locations of external libraries to
         the include and library paths (or to the classpaths for Java
         items).  There may also be some interface-only build items
         that consist solely of static files (templated C++ classes,
         lists of constants, etc.).
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>pass-through</term>
       <listitem>
        <para>
         <indexterm>
          <primary>pass-through build item</primary>
         </indexterm>
         <indexterm>
          <primary>build item</primary>
          <secondary>pass-through</secondary>
         </indexterm>
         Pass-through build items are useful for solving some more
         advanced &abuild; problems.  They contain no build or
         interface files, but they are named and have dependencies.
         This makes pass-through build items useful as top-level
         facades for hiding more complicated build item structures.
         This could include build items that have private names
         relative to the pass-through item, and it could also include
         structures containing build items that cross language and
         platform boundaries.  Several examples in the documentation
         use pass-through build items to hide private build item
         names.  For further discussion of using pass-through build
         items in a cross-platform environment, please see <xref
         linkend="ref.cross-platform-dependencies"/>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>plugin</term>
       <listitem>
        <para>
         Plugins are capable of extending the functionality of
         &abuild; beyond what can be accomplished in regular build
         items.  Plugins must be named and not have any dependencies.
         No other build items may depend on them.  Plugins are a topic
         in their own right.  They are discussed in depth in <xref
         linkend="ref.plugins"/>.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </sect1>
   <sect1 id="ref.third-party-software">
    <title>Integrating with Third-Party Software</title>
    <para>
     Virtually every software development project has some need to
     integrate with third-party software libraries.  In a traditional
     build system, you might list the include paths, libraries, and
     library directories right in your <filename>Makefile</filename>
     or configuration file for whatever build system you are using.
     With &abuild;, the best way to integrate with a third-party
     library is to use a build item whose sole purpose is to export
     that library's information using an
     <filename>Abuild.interface</filename> file.  In the simplest
     cases, a third-party library build item might be an interface
     only build item (described above) that just includes the
     appropriate library directives in a static
     <filename>Abuild.interface</filename> file.  For example, a build
     item that provides access to the PCRE (Perl-compatible regular
     expression) libraries on a Linux distribution that has them
     installed in the system's standard include path might just
     include an <filename>Abuild.interface</filename> with the
     following contents:

     <programlisting>LIBS = pcrecpp pcre
</programlisting>
     For Java build items, a third-party JAR build item would
     typically append the path to the JAR file to the
     <varname>abuild.classpath.external</varname> interface variable.
     Sometimes, the process may be more involved.  For example, on a
     UNIX system, it is often desirable to use
     <application>autoconf</application> to determine what interface
     is required for a particular library.  We present an example of
     using <application>autoconf</application> with &abuild; in <xref
     linkend="ref.example.autoconf"/>.  Still other libraries may use
     <application>pkg-config</application>.  For those libraries, it
     may make sense to create a simple set of build rules that
     automatically generate an <filename>Abuild.interface</filename>
     <function>after-build</function> file (also discussed in <xref
     linkend="ref.example.autoconf"/>) by running the
     <command>pkg-config</command> command.
     <footnote>
      <para>
       An example <application>pkg-config</application> build item may
       be found in the <filename>abuild-contrib</filename> package
       available at <ulink url="http://www.abuild.org">&abuild;'s web
       site</ulink>.
      </para>
     </footnote>
    </para>
    <para>
     Whichever way you do it for a given package, the idea is that you
     should always create a build item whose job it is to provide the
     glue between &abuild; and the third-party library.  Other build
     items that need to use the third-party library can then just
     declare a dependency on the build item that provides the
     third-party library's interface.  This simplifies the process of
     using third-party libraries and makes it possible to create a
     uniform standard for doing so within any specific &abuild; build
     tree.  It also alleviates the need to duplicate information about
     the third-party library throughout your source tree.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.platforms">
   <title>Target Types, Platform Types, and Platforms</title>
   <para>
    &Abuild; was designed with multiplatform operation in mind from
    the beginning.  Up to this point, we have largely glossed over how
    &abuild; deals with multiple platforms.  In this chapter, we will
    cover this aspect of &abuild;'s operation in detail.
   </para>
   <sect1 id="ref.platform-structure">
    <title>Platform Structure</title>
    <para>
     &Abuild; classifies platforms into a three-level hierarchy.  The
     three levels are described by the following terms:
    </para>
    <variablelist>
     <varlistentry>
      <term>target type</term>
      <listitem>
       <para>
        <indexterm>
         <primary>target type</primary>
        </indexterm>
        A <firstterm>target type</firstterm> encompasses the overall
        kind of targets that are being built.  A target type
        essentially encapsulates a build paradigm.  &Abuild;
        understands three target types:
        <type>platform-independent</type> for truly
        platform-independent products like scripts and documentation,
        <type>object-code</type> for compiled object code like C and
        C++, and <type>java</type> for Java byte code and related
        products.  One could argue that Java code is
        platform-independent, but since Java code has its own build
        paradigm, &abuild; considers it to be a separate target type.
        Be careful not to confuse <firstterm>target type</firstterm>
        with <firstterm>target</firstterm>, defined in <xref
        linkend="ref.basic-terminology"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>platform type</term>
      <listitem>
       <para>
        <indexterm>
         <primary>platform type</primary>
        </indexterm>
        A <firstterm>platform type</firstterm> essentially defines a
        grouping of platforms.  Platform types belong to target types
        and contain platforms.  When configuring build items,
        developers assign build items to platform types rather than to
        platforms or target types.  The
        <type>platform-independent</type> target type has only platform
        type: <type>indep</type>.  The <type>java</type> target type
        has only one platform type: <type>java</type>.
        <footnote>
         <para>
          At one time, it was planned for &abuild; to support
          different platform types for different versions of Java byte
          code.  Although this would have been useful for build trees
          that had complex requirements for mixing JDKs of different
          versions, this capability would have added a lot of
          complexity to support a practice that is unusual and largely
          undesirable.
         </para>
        </footnote>
        Platform types are most useful in the <type>object-code</type>
        target type.  &Abuild; has only one built-in platform type in
        the <type>object-code</type> target type: <type>native</type>.
        The <type>native</type> platform type applies to build items
        that are expected to be able to be built and run on the host
        platform.  Additional platform types to support embedded
        platforms or cross compilers can be added in plugins (see
        <xref linkend="ref.adding-platform-types-and-platforms"/>).
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>platform</term>
      <listitem>
       <para>
        <indexterm>
         <primary>platform</primary>
        </indexterm>
        The &abuild; <firstterm>platform</firstterm> is the lowest
        level of detail in describing the environment in which a
        target is intended to be used.  The expectation is that
        compiled products (object files, libraries, binary
        executables, java class files, etc.) produced for one platform
        are always compatible with other products produced for that
        platform but are not necessarily compatible with products
        produced for a different platform.  If two different versions
        of a compiler generate incompatible object code (because of
        incompatible runtime library versions or different C++ name
        mangling conventions, for example), then a host running one
        compiler may generate output belonging to a different platform
        from the same host running a different version of the
        compiler.  For the <type>indep</type> platform type in the
        <type>platform-independent</type> target type, there is only
        one platform, which has the same name as the platform type:
        <type>indep</type>.  For the <type>java</type> platform type
        in the <type>java</type> target type, there is also only one
        platform, which also shares its name with the platform type:
        <type>java</type>.  Platforms become interesting within the
        <type>object-code</type> target type.  When we refer to
        platforms, we are almost always talking about
        <type>object-code</type> platforms.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     This table (<xref linkend="table.platforms"/>) shows the target
     types along with the built-in platform types and platforms that
     belong to them.
     <table id="table.platforms" frame="all">
      <title>Built-in Platforms, Platform Types, and Target Types</title>
      <tgroup cols="3" align="left" colsep="1" rowsep="1">
       <thead>
        <row>
         <entry>Target Type</entry>
         <entry>Platform Type</entry>
         <entry>Platform</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><type>object-code</type></entry>
         <entry><type>native</type></entry>
         <entry>based on available tools</entry>
        </row>
        <row>
         <entry><type>java</type></entry>
         <entry><type>java</type></entry>
         <entry><type>java</type></entry>
        </row>
        <row>
         <entry><type>platform-independent</type></entry>
         <entry><type>indep</type></entry>
         <entry><type>indep</type></entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     When a build item is defined with multiple platform types, they
     must all belong to the same target type.  Some interface
     variables are also based on target type.  For example, it may be
     permissible for a java build item to depend on a C++ build item
     if the C++ build item exports native code or provides an
     executable code generator, but it would never make sense for a
     java build item to have an include path or library path in the
     sense of a C/C++ build item.  When one build item depends on
     another, the platforms on which the two build items are being
     built come into play.  We discuss this in <xref
     linkend="ref.cross-platform-dependencies"/>.
    </para>
   </sect1>
   <sect1 id="ref.platforms.object-code">
    <title>Object-Code Platforms</title>
    <para>
     For target type <type>object-code</type>, platform identifiers
     are of the form
     <type>os</type>.<type>cpu</type>.<type>toolset</type>.<type>compiler</type>[.<type>option</type>],
     described below.  In all cases, each field of the platform
     identifier must consist only of lower-case letters, numbers,
     dash, or underscore.  The fields of the platform identifier are
     as follows:
    </para>
    <variablelist>
     <varlistentry>
      <term>os</term>
      <listitem>
       <para>
        A broad description of the operating system, such as
        <type>linux</type>, <type>solaris</type>,
        <type>windows</type>, <type>cygwin</type>, or
        <type>vxworks</type>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>cpu</term>
      <listitem>
       <para>
        A CPU type identifier such as <type>ix86</type>,
        <type>x86_64</type>, <type>ppc</type>, <type>ppc64</type>, or
        <type>sparc</type>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>toolset</term>
      <listitem>
       <para>
        A user-defined label for a collection of tools.  This is a
        convenience field to separate things like different versions
        of compilers or runtime libraries.  It can be set to any
        string, at which point the user is responsible for ensuring
        that it does in fact define a meaningful collection of tools.
        By default, &abuild; will create a toolset name based on the
        operating system distribution or similar factors.  Examples
        include <type>rhel4</type> on a Red Hat Enterprise Linux 4
        system, or <type>deb4_0</type> on a Debian GNU/Linux 4.0
        system.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>compiler</term>
      <listitem>
       <para>
        An identifier for the compiler C/C++ compiler toolchain to be
        used.  &Abuild; has built-in support for gcc on UNIX systems
        and for Microsoft Visual C++ and mingw on Windows systems.
        Users can provide their own compiler toolchains in addition to
        these.  The mechanism for adding new compilers is described in
        <xref linkend="ref.adding-platform-types-and-platforms"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>option</term>
      <listitem>
       <para>
        An optional field that is used to pass additional information
        to the <application>GNU Make</application> code that
        implements support for the compiler.  Typical uses for options
        would be to define different debugging, profiling, or
        optimization levels.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     All of the fields of the platform identifier are made available
     in separate variables within the interface parsing system.  In
     addition, for <type>object-code</type> build items, the make
     variable <varname>$(CCXX_TOOLCHAIN)</varname> is set to the value
     of the compiler field.  Here are some example platform
     identifiers:
     <simplelist>
      <member>linux.ppc64.proj1default.gcc</member>
      <member>linux.ppc64.proj1default.gcc.release</member>
      <member>linux.ppc64.proj1default.gcc.debug</member>
      <member>linux.x86.fc5.gcc</member>
      <member>linux.x86.fc5.gcc.release</member>
      <member>linux.x86.fc5.gcc.debug</member>
      <member>windows.ix86.nt5.msvc</member>
      <member>windows.ix86.cygwin-nt5.mingw</member>
      <member>vxworks.pc604.windriver.vxgcc</member>
     </simplelist>
    </para>
   </sect1>
   <sect1 id="ref.output-directories">
    <title>Output Directories</title>
    <indexterm>
     <primary>output directories</primary>
    </indexterm>
    <para>
     When &abuild; builds an item, it creates an output directory
     under that item's directory for every platform on which that item
     is built.  The output directory is of the form
     <filename>abuild-<replaceable>platform-name</replaceable></filename>.
     &Abuild; itself and all &abuild;-supplied rules create files only
     inside of &abuild; output directories.
     <footnote>
      <para>
       &Abuild; considers any directory whose name starts with
       <filename>abuild-</filename> and which contains a file named
       <filename>.abuild</filename> to be an output directory.
      </para>
     </footnote>
    </para>
    <para>
     When &abuild; invokes a backend to perform the actual compilation
     steps, it always does so from an output directory.  This is true
     even for platform-independent build items.  In this way, even
     temporary files created by compilers or other build systems will
     not appear in the build item's local directory.  This makes it
     possible to build a specific item for multiple platforms in
     parallel without having to be concerned about the separate builds
     overwriting each other's files.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.build-item-dependencies">
   <title>Build Item Dependencies</title>
   <indexterm>
    <primary>dependency</primary>
   </indexterm>
   <para>
    Management of dependencies among build items is central to
    &abuild;'s functionality.  We have already gotten a taste of this
    capability in the basic examples included in <xref
    linkend="ref.basic-operation"/>.  In this chapter, we will examine
    dependencies in more depth.
   </para>
   <sect1 id="ref.dependencies.direct-and-indirect">
    <title>Direct and Indirect Dependencies</title>
    <indexterm>
     <primary>dependency</primary>
     <secondary>direct</secondary>
    </indexterm>
    <indexterm>
     <primary>dependency</primary>
     <secondary>indirect</secondary>
    </indexterm>
    <indexterm>
     <primary>dependency</primary>
     <secondary>circular</secondary>
    </indexterm>
    <para>
     The principle mechanism for declaring dependencies among build
     items in &abuild; is the <property>deps</property> key in a build
     item's <filename>Abuild.conf</filename>.  Suppose build item
     <classname>A</classname> declares build item
     <classname>B</classname> as a dependency.  The following line
     would appear in <classname>A</classname>'s
     <filename>Abuild.conf</filename>:

     <programlisting>deps: B
</programlisting>
     This declaration causes two things to happen:
     <itemizedlist>
      <listitem>
       <para>
        It ensures that <classname>B</classname> will be built before
        <classname>A</classname> in any dependency-aware build.
       </para>
      </listitem>
      <listitem>
       <para>
        It enables <classname>A</classname> to see all of the variable
        declarations and assignments in <classname>B</classname>'s
        <filename>Abuild.interface</filename> file.
       </para>
      </listitem>
     </itemizedlist>
     We illustrate both of these principles later in this chapter.
     For an in-depth discussion of build ordering and dependency-aware
     builds, see <xref linkend="ref.what-to-build"/>.  For an in-depth
     discussion of &abuild;'s interface system, see <xref
     linkend="ref.abuild-interface-system"/>.
    </para>
    <para>
     Another very important point about dependencies in &abuild; is
     that they are <firstterm>transitive</firstterm>.  In other words,
     if <classname>A</classname> depends on <classname>B</classname>
     and <classname>B</classname> depends on <classname>C</classname>,
     then <classname>A</classname> also implicitly depends on
     <classname>C</classname>.  This means that the conditions above
     apply to <classname>A</classname> and <classname>C</classname>.
     That is, <classname>C</classname> is built before
     <classname>A</classname> (which it would be anyway since it is
     built before <classname>B</classname> and
     <classname>B</classname> is built before
     <classname>A</classname>), and <classname>A</classname> sees
     <classname>C</classname>'s interface in addition to seeing
     <classname>B</classname>'s interface.
     <footnote>
      <para>
       In fact, since <classname>B</classname> depends on
       <classname>C</classname>, <classname>C</classname>'s interface
       is effectively included as part of <classname>B</classname>'s
       interface.  This makes <classname>C</classname>'s interface
       visible to all build items that depend on
       <classname>B</classname>.  The exact mechanism by which this
       works is described in <xref
       linkend="ref.abuild-interface-system"/>.
      </para>
     </footnote>
     Assuming that
     <classname>A</classname> does not explicitly list
     <classname>C</classname> in its <property>deps</property> key, we
     would call <classname>B</classname> a <firstterm>direct
     dependency</firstterm> of <classname>A</classname> and
     <classname>C</classname> an <firstterm>indirect
     dependency</firstterm> of <classname>A</classname>.  We also say
     that build item dependencies are <firstterm>inherited</firstterm>
     when we wish to refer to the fact that build ordering and
     interface visibility are influenced by both direct and indirect
     dependencies.
    </para>
    <para>
     &Abuild; performs various validations on dependencies.  The most
     important of these is that no cyclic dependencies are permitted.
     In other words, if <classname>A</classname> depends on
     <classname>B</classname> either directly or indirectly, then
     <classname>B</classname> cannot depend on
     <classname>A</classname> directly or indirectly.  There are other
     dependency validations which are discussed in various places
     throughout the document.
    </para>
    <para>
     By default, any build item can depend on any other build item by
     name.  &Abuild; offers two mechanisms to restrict which items can
     depend on which other items.  One mechanism is through build item
     name scoping rules, discussed below.  The other mechanism is
     through use of external build trees, discussed in <xref
     linkend="ref.externals"/>.
    </para>
   </sect1>
   <sect1 id="ref.build-item-name-scoping">
    <title>Build Item Name Scoping</title>
    <para>
     In this section, we discuss build item name scoping rules.  Build
     item name scoping is one mechanism that can be used to restrict
     which build items may directly depend on which other build items.
    </para>
    <para>
     <indexterm>
      <primary>build item</primary>
      <secondary>scope</secondary>
     </indexterm>
     <indexterm>
      <primary>scope</primary>
     </indexterm>
     <indexterm>
      <primary>scope</primary>
      <secondary>ancestor</secondary>
     </indexterm>
     <indexterm>
      <primary>scope</primary>
      <secondary>descendant</secondary>
     </indexterm>
     Build item names consist of period-separated segments.  The
     period separator in a build item's name is a namespace scope
     delimiter that is used to determine which build items may
     directly refer to which other build items in their
     <filename>Abuild.conf</filename> files.  It is a useful mechanism
     for allowing a build item to hide the fact that it is composed of
     lower-level build items by blocking others from accessing those
     lower-level items directly.
    </para>
    <para>
     Each build item belongs to a namespace scope equal to the name of
     the build item after removing the last period and everything
     following it.  For example, the build item
     &ldquo;<classname>A.B.C.D</classname>&rdquo; is in the scope
     called &ldquo;<classname>A.B.C</classname>&rdquo;.  We would
     consider &ldquo;<classname>A.B</classname>&rdquo; and
     &ldquo;<classname>A</classname>&rdquo; to be <firstterm>ancestor
     scopes</firstterm>.  The build item name itself also defines a
     scope.  In this case, the scope
     &ldquo;<classname>A.B.C.D</classname>&rdquo; would contain
     &ldquo;<classname>A.B.C.D.E</classname>&rdquo;.  Any build item
     name scope that starts with
     &ldquo;<classname>A.B.C.D.</classname>&rdquo; (including the
     period) would be a <firstterm>descendant scope</firstterm> to
     &ldquo;<classname>A.B.C.D</classname>&rdquo;.  Any build item
     whose name does not contain a period is considered to belong to
     the global scope and is accessible by all build items.
    </para>
    <para>
     One build item is allowed to access another build item by name if
     the referenced build item belongs to the accessing build item's
     scope or any of its ancestor scopes.  <xref
     linkend="fig.build-item-scopes"/>, shows a number of build items
     arranged by scope.  In this figure, each build item defines a
     scope whose members appear in a gray box at the end of a
     semicircular arrowhead originating from the defining build item.
     Each build item in this figure can see the build items that are
     direct members of the scope that it defines, the build items that
     are siblings to it in its own scope, and the build items inside
     of any of its ancestor scopes.  You may wish to study the figure
     while you follow along with the text below.
     <figure id="fig.build-item-scopes">
      <title>Build Item Scopes</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="build-item-scopes.png"/>
       </imageobject>
       <caption>
        <para>
         Build items are shown here grouped by scope.  Each build item
         is connected to the scope that it defines.
        </para>
       </caption>
      </mediaobject>
     </figure>
     To illustrate, we will consider item
     <classname>A1.B1.C1</classname>.  The build item
     <classname>A1.B1.C1</classname> can access the following items
     for the following reasons:
     <itemizedlist>
      <listitem>
       <para>
        <classname>A1.B1.C1.D1</classname> because it belongs to the
        scope that <classname>A1.B1.C1</classname> defines:
        <classname>A1.B1.C1</classname>
       </para>
      </listitem>
      <listitem>
       <para>
        <classname>A1.B1.C2</classname> because it is in the same
        scope as <classname>A1.B1.C1</classname>:
        <classname>A1.B1</classname>
       </para>
      </listitem>
      <listitem>
       <para>
        <classname>A1.B1</classname> and <classname>A1.B2</classname>
        because they belong to an ancestor scope:
        <classname>A1</classname>
       </para>
      </listitem>
      <listitem>
       <para>
        <classname>A1</classname> and <classname>Q</classname> because
        they are global
       </para>
      </listitem>
     </itemizedlist>
     It cannot access these items:
     <itemizedlist>
      <listitem>
       <para>
        <classname>A1.B1.C1.D1.E1</classname> because it is hidden in
        scope <classname>A1.B1.C1.D1</classname>
       </para>
      </listitem>
      <listitem>
       <para>
        <classname>A1.B1.C2.D1</classname> because it is hidden in
        scope <classname>A1.B1.C2</classname>
       </para>
      </listitem>
      <listitem>
       <para>
        <classname>Q.R</classname> because it is hidden in scope
        <classname>Q</classname>
       </para>
      </listitem>
     </itemizedlist>
     The item <classname>A1.B1.C1</classname> can <emphasis>be
     accessed by</emphasis> the following items:
     <itemizedlist>
      <listitem>
       <para>
        <classname>A1.B1</classname> because it is its parent
       </para>
      </listitem>
      <listitem>
       <para>
        <classname>A1.B1.C2</classname> because it is its sibling
       </para>
      </listitem>
      <listitem>
       <para>
        <classname>A1.B1.C1.D1</classname> and
        <classname>A1.B1.C1.D1.E1</classname> because they are its
        descendants
       </para>
      </listitem>
      <listitem>
       <para>
        <classname>A1.B1.C2.D1</classname> because it can see
        <classname>A1.B1.C1</classname> as a member of its ancestor
        scope <classname>A1.B1</classname>
       </para>
      </listitem>
     </itemizedlist>
     It cannot be accessed by these items:
     <itemizedlist>
      <listitem>
       <para>
        <classname>A1.B2</classname>, <classname>A1</classname>,
        <classname>Q</classname>, and <classname>Q.R</classname>, none
        of which can see inside of <classname>A1.B1</classname>
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     To give a more concrete example, suppose you have a globally
     accessible build item called <classname>networking</classname> that
     was internally divided into private build items
     <classname>networking.src</classname> and
     <classname>networking.test</classname>.  A separate build item
     called <classname>logger</classname> would be permitted to declare a
     dependency on <classname>networking</classname> but not on
     <classname>networking.src</classname> or
     <classname>networking.test</classname>.  Assuming that it did not
     create any circular dependencies,
     <classname>networking.test</classname> would also be allowed to
     depend on <classname>logger</classname>.
    </para>
    <para>
     Note that these restrictions apply only to explicitly declared
     dependencies.  It is common practice to implement a
     &ldquo;public&rdquo; build item as multiple &ldquo;private&rdquo;
     build items.  The public build item itself would not have an
     <filename>Abuild.interface</filename> file, but would instead
     depend on whichever of its own private build items contain
     interfaces it wants to export.  It would, in fact, be a
     pass-through build item.  Because dependencies are inherited,
     items that depend on the public build item will see the
     interfaces of those private build items even though they would
     not be able to depend on them directly.  In this way, the public
     build item becomes a facade for the private build items that
     actually do the work.  For example, the build item
     <classname>networking</classname> would most likely not have its
     own <filename>Abuild.interface</filename> or
     <filename>Abuild.mk</filename> files.  Instead, it might depend
     on <classname>networking.src</classname> which would have those
     files.  It would probably not depend on
     <classname>networking.test</classname> since
     <classname>networking.test</classname> doesn't have to be built
     in order to use <classname>networking</classname>.
     <footnote>
      <para>
       Although <classname>networking</classname> doesn't have to
       depend on <classname>networking.test</classname>, you might be
       tempted to put the dependency in so that when you run the
       <command>check</command> target for all dependencies of
       <classname>networking</classname>, you would get the test suite
       implemented in <classname>networking.test</classname>.  Rather
       than using a dependency for this purpose, you can use a trait
       instead.  For information about traits, see <xref
       linkend="ref.traits"/>.  A specific example of using traits for
       this purpose appears in that section.
      </para>
     </footnote>
     This means that it would be okay for
     <classname>networking.test</classname> to depend on
     <classname>networking</classname> since doing so would not create
     any circular dependencies.  Then, any build items that depend on
     <classname>networking</classname> indirectly depend on
     <classname>networking.src</classname> and would see
     <classname>networking.src</classname>'s
     <filename>Abuild.interface</filename>.
    </para>
    <para>
     There is nothing that a build item can do to allow itself to
     declare a direct dependency on another build item that is hidden
     within another scope: the only way to gain direct access to a
     build item is to be its ancestor or to be a descendant of its
     parent.  (There are no restrictions on indirect access.)  There
     are times, however, when it is desirable for a build item to
     allow itself to <emphasis>be seen</emphasis> by build items who
     would ordinarily not have access to it.  This is accomplished by
     using the <property>visible-to</property> key in
     <filename>Abuild.conf</filename>.  We defer discussion of this
     feature until later; see <xref
     linkend="ref.build-item-visibility"/>.
    </para>
   </sect1>
   <sect1 id="ref.example.simple-build-tree">
    <title>Simple Build Tree Example</title>
    <para>
     Now that the topic of build items and build trees has been
     explored in somewhat more depth, let's take a look at a simple but
     complete build tree.  The build tree in
     <filename>doc/example/general/reference/common</filename> illustrates many of
     the concepts described above.
    </para>
    <para>
     The first file to look at is the <filename>Abuild.conf</filename>
     belonging to this tree's root build item:
     <?example general/reference/common/Abuild.conf?>
     This is a root build item configuration file.  Notice that it
     lacks a <property>this</property> key, as is often the case with
     the root build item.  This <filename>Abuild.conf</filename>
     contains the names of some child directories and also a build tree
     attribute: <property>supported-traits</property>, which lists the
     traits that are allowed in the build tree.  We will return to the
     topic of traits in <xref linkend="ref.traits"/>.  In the mean
     time, we will direct our focus to the child build items.
    </para>
    <para>
     The first child of the root build item of this tree is in the
     <filename>lib1</filename> directory.  We examine its
     <filename>Abuild.conf</filename>:
     <?example general/reference/common/lib1/Abuild.conf?>
     This build item is called <classname>common-lib1</classname>.
     Notice that the name of the build item is not the same as the name
     of the directory, but it is based on the name of the directory.
     This is a typical strategy for naming build items.  &Abuild;
     doesn't care how you name build items as long as they conform to
     the syntactic restrictions and are unique within a build tree.
     Coming up with a naming structure that parallels your system's
     architecture and/or your file system layout is a good way to help
     ensure that you do not create conflicting build item names.
    </para>
    <para>
     This build item does not have any build or interface files.  It is
     a <firstterm>pass-through build item</firstterm>.  It declares a
     single dependency: <classname>common-lib1.src</classname>, and two
     child directories: <filename>src</filename> and
     <filename>test</filename>.
    </para>
    <para>
     Next, look at the <classname>common-lib1.src</classname> build
     item's <filename>Abuild.conf</filename> in the
     <filename>common/lib1/src</filename> directory:
     <?example general/reference/common/lib1/src/Abuild.conf?>
     The first thing to notice is this build item's name.  It contains
     a period and is therefore private to the
     <classname>common-lib1</classname> scope.  That means that it is
     not accessible to build items whose names are not also under that
     scope.  In particular, a build item called
     <classname>common-lib2</classname> would not be able to depend
     directly on <classname>common-lib1.src</classname>.  It would
     instead depend on <classname>common-lib1</classname> and would
     inherit the dependency on <classname>common-lib1.src</classname>
     indirectly.
    </para>
    <para>
     This build item doesn't list any child directories and, as such,
     is a leaf in the file system hierarchy.  It also happens not to
     declare any dependencies, so it is also a leaf in the dependency
     tree, though one does not imply the other.  This build item
     configuration file contains the
     <property>platform-types</property> key, as is required for all
     build items that contain build or interface files.  In addition
     to the <filename>Abuild.conf</filename> file, we have an
     <filename>Abuild.mk</filename> file and an
     <filename>Abuild.interface</filename> file:
     <?example general/reference/common/lib1/src/Abuild.mk?>
     <?example general/reference/common/lib1/src/Abuild.interface?>
     There is nothing in these files that is fundamentally different
     from the basic C++ library example shown in <xref
     linkend="ref.example.basic.cxx-library"/>.  We can observe,
     however, that the <varname>INCLUDES</varname> variable in
     <filename>Abuild.interface</filename> actually points to
     <filename>../include</filename> rather than the current
     directory.  This simply illustrates that &abuild; doesn't impose
     any restrictions on how you might want to lay out your build
     items, though it is recommended that you pick a consistent way
     and stick with it for any given build tree.  We will not study
     the source and header files in this example here, but you are
     encouraged to go to the
     <filename>doc/example/general/reference/common</filename> directory in your
     &abuild; source tree or installation directory to study the files
     further on your own.
    </para>
    <para>
     Next, look at the <filename>test</filename> directory.  Here is
     its <filename>Abuild.conf</filename>:
     <?example general/reference/common/lib1/test/Abuild.conf?>
     Notice that it declares a dependency on
     <classname>common-lib1</classname>.  Since its name is also
     private to the <classname>common-lib1</classname> scope, it would
     have been okay for it to declare a dependency directly on
     <classname>common-lib1.src</classname>.  Declaring its dependency
     on <classname>common-lib1</classname> instead means that this
     test code is guaranteed to see the same interfaces as would be
     seen by any outside user of <classname>common-lib1</classname>.
     This may be appropriate in some cases and not in others, but it
     demonstrates that it is okay for a build item that is inside of a
     particular namespace scope to depend on its parent in the
     namespace hierarchy.  This build item also declares a trait, but
     we will revisit this when we discuss traits later in the document
     (see <xref linkend="ref.traits"/>).
    </para>
    <para>
     In addition to the <filename>lib1</filename> directory, we also
     have <filename>lib2</filename> and <filename>lib3</filename>.
     These are set up analogously to <filename>lib1</filename>, so we
     will not inspect every file.  We will draw your attention to one
     file in particular: observe that the
     <classname>common-lib2.src</classname> build item in
     <filename>reference/common/lib2/src</filename> declares a dependency
     on <classname>common-lib3</classname>:
     <?example general/reference/common/lib2/src/Abuild.conf?>
    </para>
    <para>
     We will return to this build tree later to study build sets,
     traits, and examples of various ways to run builds.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.externals">
   <title>External Build Trees</title>
   <para>
    In large development environments, it is common to have
    collections of code that may be shared across multiple projects.
    Ideally, such collections of shared code should be accessible by
    multiple projects but should not be able to access code from the
    those projects.  By creating this one-way relationship between
    project code and common code, it is possible to ensure that the
    common code is not modified to <emphasis>accidentally</emphasis>
    depend on project code.  &Abuild; provides the ability to do this
    through the use of <firstterm>external build trees</firstterm>,
    also referred to as <firstterm>externals</firstterm>.  We define
    the following additional terms:
    <variablelist>
     <varlistentry>
      <term>local build tree</term>
      <listitem>
       <para>
        <indexterm>
         <primary>build tree</primary>
         <secondary>local</secondary>
        </indexterm>
        <indexterm>
         <primary>local build tree</primary>
        </indexterm>
        The <firstterm>local build tree</firstterm> is the build tree
        that contains the current directory.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>external build tree</term>
      <listitem>
       <para>
        <indexterm>
         <primary>build tree</primary>
         <secondary>external</secondary>
        </indexterm>
        <indexterm>
         <primary>external build tree</primary>
        </indexterm>
        <indexterm>
         <primary>external</primary>
        </indexterm>
        An <firstterm>external build tree</firstterm> is a separate
        build tree that can supplement the local build tree.  Build
        items in the local build tree can resolve the names of build
        items in external build trees, but build items in external
        build trees cannot see items in the local tree.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>
   <sect1 id="ref.usign-externals">
    <title>Using External Build Trees</title>
    <para>
     There is nothing special about a build tree that makes it able to
     be an external: any tree can be an external.  In order for one
     build tree to reference another build tree as an external, the
     first tree must configure its root build item's
     <filename>Abuild.conf</filename> to point to the external tree's
     root directory.  This is done by adding an
     <property>external-dirs</property> key to the root build item's
     <filename>Abuild.conf</filename>.  The
     <property>external-dirs</property> key, like the
     <property>child-dirs</property> key, contains a space-separated
     list of paths.  Unlike with <property>child-dirs</property>, in
     this case, there is no reciprocation; <emphasis>i.e.</emphasis>,
     nothing in the external tree points back to the referring tree.
     External trees can be specified as either relative paths or as
     absolute paths.  If an external tree is specified as a relative
     path, then &abuild; will attempt to resolve it in a backing area
     (see <xref linkend="ref.backing-areas.resolving-externals"/>) if
     it is not found.
    </para>
    <para>
     In addition to paths, there are two options that may be specified
     for each external: the <option>-ro</option> option, which makes
     an external read-only, and the
     <option>-winpath=<replaceable>windows-path</replaceable></option>
     option, which allows an alternative path to be used only when
     running in a Windows environment.
     <footnote>
      <para>
       Our syntax does not allow spaces to appear in any external path
       names, including the argument to <option>-winpath</option>.  In
       Windows, you can always use the short form of the name, which
       you can find using the <command>dir /x</command> command from
       the Windows command prompt.
      </para>
     </footnote>
     For example, this line makes <filename>../common</filename> a
     regular external and <filename>/opt/abuild_library</filename> a
     read-only external that can be found at
     <filename>O:/abuild_library</filename> on Windows systems and
     <filename>/opt/abuild_library</filename> on non-Windows systems:

     <programlisting>external-dirs: ../common /opt/abuild_library -winpath=O:/abuild_library -ro
</programlisting>
     &Abuild; will never attempt to build an item in a read-only
     external tree when the build is started in a tree that declares
     it as a read-only external.  You must therefore make sure that
     all your read-only externals are fully built for all platforms on
     which you will use their items.  Read-only externals can be
     useful for making libraries of utility build items available to a
     large number of projects, or they can just be used to speed up
     your builds if your external area is relatively static and you
     don't mind manually rebuilding it when you make changes to it.
     If more than one developer is making use of the same physical
     external tree, it is recommended that they all declare that tree
     as a read-only external since this will prevent multiple users
     from trying to build the same items at the same time.
    </para>
    <para>
     Once you set up another tree as an external to your tree, all
     build items defined in the external build tree are available to
     you (subject to normal scoping rules) as if they were in your
     local build tree.  This means that none of the build items in
     your build tree may have the same name as any build item in the
     external tree.  Note that the external build tree is not affected
     in any way by being referred to as an external.  In order to
     avoid build item name clashes, it's a good idea to pick a naming
     convention for your build items that includes some kind of
     tree-based prefix, as we have done with names like
     <classname>common-lib1</classname>.
    </para>
    <para>
     When declaring an external, you must give some thought as to
     whether you wish to use a relative path or an absolute path.  In
     general, if your intention is to use an external tree to contain
     code that is parallel to your development environment, such as
     having a collection of shared code used by many related projects
     that live together in a version control system, you will probably
     want to use relative paths to external trees.  On the other hand,
     if your externals contain libraries of build items that are
     required to be installed in a certain location on your
     development systems, an absolute path may be more appropriate.
     Just keep in mind that using absolute paths for your externals
     creates a dependency from inside your build tree to files located
     in a specific place outside of your build tree.  This may be
     appropriate in some cases, but it may not always be what you
     want.
     <footnote>
      <para>
       For example, if your backing area declares an external using an
       absolute path and your root <filename>Abuild.conf</filename> is
       a copy of your backing area's root
       <filename>Abuild.conf</filename>, you can't shadow the external
       locally without modifying your root
       <filename>Abuild.conf</filename>.  (Backing areas are discussed
       in <xref linkend="ref.backing-areas"/>.)  If your external were
       specified as a relative path, you would be able to shadow it by
       simply creating it in the correct location, thus preventing it
       from being resolved in the backing area.
      </para>
     </footnote>
    </para>
   </sect1>
   <sect1 id="ref.example.external-build-tree">
    <title>External Build Tree Example</title>
    <para>
     We will examine a new build tree that uses the build tree from
     our previous example (see <xref
     linkend="ref.example.simple-build-tree"/>) as an external.  This
     new tree, which we will call the project build tree, can be found
     at <filename>doc/example/general/reference/project</filename>.  The first
     file we examine is the new build tree's root build item's
     <filename>Abuild.conf</filename>:
     <?example general/reference/project/Abuild.conf?>
     This build item configuration file, in addition to having the
     <property>child-dirs</property> key, also has an
     <property>external-dirs</property> key.  In this case, the value
     of this key is the relative path <filename>../common</filename>.
     It is common for an external tree to be in a parallel directory
     structure to your build tree, so having the location start with
     &ldquo;<filename>..</filename>&rdquo; is not unusual.  There are
     also valid reasons to have an external build tree nested inside
     of your own tree.  As always, it's best to come up with some
     conventions and to follow them uniformly.
    </para>
    <para>
     Inside the project build tree, the
     <classname>project-lib</classname> build item is defined inside
     the <filename>lib</filename> directory.  It is set up exactly the
     same way as <classname>common-lib1</classname> and the other
     libraries in the external tree.  Here is its
     <filename>Abuild.conf</filename>:
     <?example general/reference/project/lib/Abuild.conf?>
     Now look at <classname>project-lib.src</classname>'s
     <filename>Abuild.conf</filename>:
     <?example general/reference/project/lib/src/Abuild.conf?>
     Notice that it declares a dependency on
     <classname>common-lib1</classname>, which is defined in the
     external tree.  This works because &abuild; automatically makes
     available to you all the build items in any external build tree.
    </para>
    <para>
     This build tree also includes a main program, but we will not go
     through the rest of the files in depth.  You are encouraged to
     study the files on your own.  There are also examples of traits in
     this build tree.  We will return to this build tree during our
     discussion of traits (see <xref linkend="ref.traits"/>).
    </para>
    <para>
     When you declare another build tree as an external, you
     automatically inherit any externals that
     <emphasis>that</emphasis> tree declared as externals as well.  If
     this were not the case, &abuild; would not be able to resolve
     dependencies declared in the external if those dependencies were
     resolved in <emphasis>its</emphasis> externals.  To illustrate
     this, we have a third build tree located in
     <filename>doc/example/general/reference/derived</filename>.  This
     build tree is for a second project that is derived from the first
     project.  This build tree declares
     <filename>../project</filename> as an external build tree.  For a
     diagram of the entire <filename>general/reference</filename>
     collection of build tress, see <xref
     linkend="fig.general-reference"/>.
     <figure id="fig.general-reference">
      <title>Build Trees in <filename>general/reference</filename></title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="general-reference.png"/>
       </imageobject>
       <caption>
        <para>
         The <filename>derived</filename> build tree declares the
         <filename>project</filename> build tree as an external.  The
         <filename>project</filename> build tree declares the
         <filename>common</filename> build tree as an external.
        </para>
       </caption>
      </mediaobject>
     </figure>
     Here is its root <filename>Abuild.conf</filename>:
     <?example general/reference/derived/Abuild.conf?>
     It contains a <classname>derived-main</classname> build item
     structure identically to the C++ program build items we've seen
     earlier.  Here at the main program's
     <filename>Abuild.conf</filename>:
     <?example general/reference/derived/main/src/Abuild.conf?>
     In this file, you can see that
     <classname>derived-main.src</classname> depends on
     <classname>project-lib</classname> from the
     <filename>../project</filename> build tree and also
     <classname>common-lib2</classname> which is found in
     <filename>../project</filename>'s external located at
     <filename>../common</filename>.  We will return to this build
     tree in the examples at the end of <xref
     linkend="ref.what-to-build"/>.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.what-to-build">
   <title>Telling &Abuild; What to Build</title>
   <para>
    Up to this point, we have seen only simple invocations of &abuild;
    to build a single item or an item with all of its dependencies.
    &Abuild; offers several ways of creating sets of build items to
    build or clean.  These are known as <firstterm>build
    sets</firstterm>.  In addition, &abuild;'s list of items to build
    can be expanded or restricted based on
    <firstterm>traits</firstterm> that are assigned to build items.
   </para>
   <sect1 id="ref.targets">
    <title>Build Targets</title>
    <para>
     As defined in <xref linkend="ref.basic-terminology"/>, the term
     <firstterm>target</firstterm> refers to a specific build product.
     In most cases, &abuild; passes any targets specified on the
     command line to the backend build system.  &Abuild; provides
     several standard targets (see <xref
     linkend="ref.command-line"/>).  We have already encountered
     <command>all</command> and <command>clean</command> in earlier
     examples.  It is also possible to add new targets through
     mechanisms that are covered later in the document.  For now, you
     really only need to know a few things about targets:
     <itemizedlist>
      <listitem>
       <para>
        Different targets tell &abuild; to build different things.
       </para>
      </listitem>
      <listitem>
       <para>
        The <command>all</command> target is &abuild;'s default
        target.  When &abuild; builds a build item in order to satisfy
        a dependency, building the <command>all</command> target is
        required to be sufficient to satisfy the needs of items that
        depend on it.  This means that the <command>all</command>
        target is responsible for building all parts of a build item
        that are potentially needed by any of its dependencies.  This
        may seem significant, but it's a detail that takes care of
        itself most of the time.
       </para>
      </listitem>
      <listitem>
       <para>
        With the exception of two <firstterm>special
        targets</firstterm>, &abuild; doesn't do anything itself with
        targets other than pass them onto the backend build tool.
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     &Abuild; defines two <firstterm>special targets</firstterm>:
     <command>clean</command> and <command>no-op</command>.  These
     targets are special in two ways: &abuild; does not allow them to
     be combined with other targets, and &abuild; handles them itself
     without passing them to a backend.
    </para>
    <para>
     The <command>clean</command> target is used to remove the
     artifacts that are built by the other targets.  &Abuild;
     implements the <command>clean</command> target by simply removing
     all &abuild;-generated output directories (see <xref
     linkend="ref.output-directories"/>).  When &abuild; processes the
     <command>clean</command> target, it ignores any dependency
     relationships among build items.  Since it ignores dependencies
     and performs the cleanup itself without invoking a backend,
     running the <command>clean</command> target or cleaning multiple
     items using a clean set (described below) is very fast.
    </para>
    <para>
     The <command>no-op</command> target is used primarily for
     debugging build tree problems.  When &abuild; is invoked with the
     <command>no-op</command> target, it goes through all the motions
     of performing a build except that it does not read any
     <filename>Abuild.interface</filename> files or invoke any
     backends.  It does, however, perform full validation of
     <filename>Abuild.conf</filename> files including dependency and
     integrity checking.  This makes <command>abuild no-op</command>,
     especially with a build set (described below), very useful for
     taking a quick look at what items would be built on what
     platforms and in what order.  We make heavy use of the
     <command>no-op</command> target in the examples at the end of
     this chapter so that we can illustrate certain aspects of build
     ordering without being concerned about the actual output of the
     builds.
    </para>
   </sect1>
   <sect1 id="ref.build-sets">
    <title>Build Sets</title>
    <indexterm>
     <primary>build sets</primary>
    </indexterm>
    <para>
     We have already seen the <option>--with-deps</option> option,
     which tells &abuild; to build all the build items on which the
     current item depends (directly or indirectly) in addition to
     building the current item.  Now we generalize on this concept by
     introducing <firstterm>build sets</firstterm>.  A build set is a
     collection of build items defined by certain criteria.  Build
     sets can be used both to tell &abuild; which items to build and
     also to tell it which items to clean.
     <footnote>
      <para>
       In retrospect, the term <firstterm>build item set</firstterm>
       would probably have been a better name for this.  Just keep in
       mind that build sets can be used for both building and
       cleaning, and that when we use build sets for cleaning, we
       sometimes call them <firstterm>clean sets</firstterm> instead.
      </para>
     </footnote>
     When &abuild; is invoked with no build set specified and without
     the <option>--with-deps</option>, it builds the build item whose
     <filename>Abuild.conf</filename> is in the current directory,
     assuming that all items that this build item depends on are up to
     date.
     <footnote>
      <para>
       Ideally, one would never invoke &abuild; in this way: the
       maximum reliability would be achieved if &abuild; always
       checked all dependent build items.  In practice, however, the
       typical development process involves multiple cycles of
       changing files and recompiling individual units of code while
       the rest of the system stays the same.  In these cases, having
       &abuild; re-evaluate all the dependencies when you know that
       nothing has changed would cause an unnecessary increase in the
       amount of time you spend waiting for &abuild; to run.
      </para>
     </footnote>
     When any build set is specified, &abuild; attempts to build all
     dependencies, just like when <option>--with-deps</option> is
     specified.
    </para>
    <para>
     To instruct &abuild; to build all the items in a specific build
     set, run <command>abuild
     --build=<replaceable>set-name</replaceable></command> (or
     <command>abuild -b
     <replaceable>set-name</replaceable></command>).  To instruct
     &abuild; to clean all the items in a specific build set, run
     <command>abuild
     --clean=<replaceable>set-name</replaceable></command> (or
     <command>abuild -c
     <replaceable>set-name</replaceable></command>).  When building a
     build set, &abuild; will also automatically build any items that
     are direct or indirect dependencies of any items in the build
     set.  However, if you specify any explicit targets on the command
     line, &abuild; will not, by default, apply those targets to items
     that it only added to the build set to satisfy dependencies; it
     will build those items with the <command>all</command> target
     instead.  If you want &abuild; to build those items with
     explicitly named targets as well, use the
     <option>--apply-targets-to-deps</option> option.  When cleaning
     with a build set, &abuild; does not ordinarily also clean the
     dependencies of the items in the set.  To apply the
     <command>clean</command> target to all the dependencies as well,
     we also use the <option>--apply-targets-to-deps</option> option.
     This is a bit subtle, so we present several examples below.
    </para>
    <para>
     The following build sets are defined:
     <variablelist>
      <varlistentry>
       <term><option>current</option></term>
       <listitem>
        <para>
         the current build item (<emphasis>i.e.</emphasis>, the build
         item whose <filename>Abuild.conf</filename> is in the current
         directory); <option>--with-deps</option> is equivalent to
         <option>--build=current</option>
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>deps</option></term>
       <listitem>
        <para>
         all direct and indirect dependencies of the current build item
         but not the item itself
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>desc</option></term>
       <listitem>
        <para>
         all build items located at or below the current directory
         (items that are <emphasis>desc</emphasis>endants of the
         current directory)
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>local</option></term>
       <listitem>
        <para>
         all items in the build tree containing the item in the current
         directory; <emphasis>i.e.</emphasis>, the local build tree
         without any of its externals
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>all</option></term>
       <listitem>
        <para>
         all items in the local build tree and all writable external
         build trees
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>name:<replaceable>item-name[,item-name,...]</replaceable></option></term>
       <listitem>
        <para>
         all build items whose names are listed
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><option>pattern:<replaceable>regular-expression</replaceable></option></term>
       <listitem>
        <para>
         all build items whose names match the given perl-compatible
         regular expression
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <sect2 id="ref.build-set.invocation-examples">
     <title>Example Build Set Invocations</title>
     <variablelist>
      <varlistentry>
       <term><command>abuild</command></term>
       <listitem>
        <para>
         builds the current directory without building any of its
         dependencies
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --with-deps</command></term>
       <listitem>
        <para>
         builds the <command>all</command> target for all dependencies
         of the current directory's build item and for the current
         directory; equivalent to <command>abuild
         --build=current</command>
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <command>abuild --with-deps check</command>
        (or <command>abuild --build=current check</command>)
       </term>
       <listitem>
        <para>
         builds the <command>check</command> target for the current
         build item and the <command>all</command> target for all of
         its direct and indirect dependencies
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --build=current --apply-targets-to-deps check</command></term>
       <listitem>
        <para>
         builds the <command>check</command> target for the current
         build item and all of its direct and indirect dependencies
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --build=local check</command></term>
       <listitem>
        <para>
         builds the <command>check</command> target for all build items
         in the local build tree and the <command>all</command> target
         for any dependencies of any local items that may be satisfied
         in external trees
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
        <command>abuild --clean=current</command> (or <command>abuild
        clean</command>)
       </term>
       <listitem>
        <para>
         removes all output directories for the current build item but
         not for any of its dependencies
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --clean=desc</command></term>
       <listitem>
        <para>
         removes all output directories for all build items at or below
         the current directory
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --clean=current --apply-targets-to-deps</command></term>
       <listitem>
        <para>
         removes all output directories for the current build item and
         everything it depends on; useful when you want to try a
         completely clean build of a particular item
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --apply-targets-to-deps --clean=desc</command></term>
       <listitem>
        <para>
         removes all output directories for all build items at or
         below the current directory and all of their direct or
         indirect dependencies
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --build=name:lib1,lib2 xyz</command></term>
       <listitem>
        <para>
         builds the custom <command>xyz</command> target for the
         <classname>lib1</classname> and <classname>lib2</classname>
         build items and the <command>all</command> target for their
         direct or indirect dependencies
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --build=pattern:'.*\.test'</command></term>
       <listitem>
        <para>
         builds the <command>all</command> target for any item whose
         name ends with <literal>.test</literal> and any of those
         items' direct or indirect dependencies
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </sect2>
   </sect1>
   <sect1 id="ref.traits">
    <title>Traits</title>
    <indexterm>
     <primary>traits</primary>
    </indexterm>
    <para>
     In &abuild;, it is possible to assign certain traits to a build
     item.  Traits are a very powerful feature of &abuild;.  This
     material is somewhat more complicated than anything introduced up
     to this point, so don't worry if you have to read this section
     more than once.
    </para>
    <para>
     Traits are used for two main purposes.  Throughout this material,
     we will refer back to the two purposes.  We will also provide
     clarifying examples later in the chapter.
    </para>
    <para>
     The first purpose of traits is creation of semantically defined
     groups of build items.  In this case, a trait corresponding to
     the grouping criteria would be applied to a build item directly.
     For example, all build items that can be deployed could be
     assigned the <property>deployable</property> trait.
    </para>
    <para>
     A second purpose of traits is to create specific relationships
     among build items.  These relationships may or may not correspond
     to dependencies among build items.  These traits may be applied
     to a build item by itself or in reference to other build items.
     For example, the <property>tester</property> trait may be applied
     to a general system test build item by itself and may be applied
     to every test suite build item with a reference to the specific
     item being tested.
    </para>
    <para>
     Traits are used to assist in the construction of build sets.  In
     particular, you can narrow a build set by removing all items that
     don't have all of a specified list of traits.  You can also
     expand a build set to add any build items that relate to any
     items already in the set by referring to them through all of a
     specified list of traits.  This makes it possible to say things
     like &ldquo;run the <command>deploy</command> target for every
     build item that has the <property>deployable</property>
     trait,&rdquo; or &ldquo;run the <command>test</command> target
     for every item that tests my local build item or anything it
     depends on.&rdquo;
    </para>
    <para>
     Since traits are visible in abuild's <option>--dump-data</option>
     output (see <xref linkend="ref.dump-data"/>), they are available
     to scripts or front ends to &abuild;.  They may also be used for
     purely informational purposes such as specifying the
     classification level of a build item or applying a uniform label
     to all build items that belong to some group.  Trait names are
     subject to the same constraints as build item names: they are
     case-sensitive and may consist of mixed case alphanumeric
     characters, numbers, underscores, dashes, and periods.  Unlike
     with build items, the period does not have any semantic meaning
     when used in a trait name.
    </para>
    <sect2 id="ref.declaring-traits">
     <title>Declaring Traits</title>
     <para>
      Any named build item may include a <property>traits</property>
      key that lists one or more of the traits that are supported in
      its build tree.  The list of traits supported in a build tree is
      given as the value of the <property>supported-traits</property>
      key in the root build item's <filename>Abuild.conf</filename>.
      The list of supported traits is inherited through external
      trees, so any trait declared as valid in any external trees are
      also available.  The set of traits that can be specified on the
      command line is the union of all traits allowed by all known
      trees.
     </para>
     <para>
      Traits listed in the <property>traits</property> key can be made
      referent to other build items by listing the other build items
      in an <option>-item</option> option.  For example, the following
      <filename>Abuild.conf</filename> fragment declares that the
      <classname>potato.test</classname> build item is deployable,
      unclassified, and a tester for the
      <classname>potato.lib</classname> and
      <classname>potato.bin</classname> build items:

      <programlisting>this: potato.test
traits: deployable tester -item=potato.lib -item=potato.bin unclassified
</programlisting>
     </para>
    </sect2>
    <sect2 id="ref.specifying-traits">
     <title>Specifying Traits at Build Time</title>
     <para>
      To modify the build set or clean set based on traits, use the
      <option>--only-with-traits</option> and
      <option>--related-by-traits</option> command-line options to
      &abuild;.  These options must be combined with the specification
      of a build set.  They correspond to the two purposes of traits
      discussed above.
     </para>
     <para>
      To build all build items that have all of a specified list of
      traits, run <command>abuild
      --build=<replaceable>set</replaceable> --only-with-traits
      <replaceable>trait</replaceable>[,<replaceable>trait</replaceable>,...]</command>.
      This is particularly useful when semantically grouped build
      items share a common custom target.  For example, if all the
      deployable build items had a special <command>deploy</command>
      target, you could run the <command>deploy</command> target for
      all deployable items in the local build tree with the command

      <programlisting>abuild --build=local --only-with-traits deployable deploy
</programlisting>
      If multiple traits are specified at once, only build items with
      all of the specified traits are included.
     </para>
     <para>
      Once a build set has been constructed, you may want to add
      additional items to the set based on traits.  Specifically, you
      may want to add all items related by a trait to items already in
      the build set.  To expand a build set in this way, run
      <command>abuild --build=<replaceable>set</replaceable>
      --related-by-traits
      <replaceable>trait</replaceable>[,<replaceable>trait</replaceable>,...]</command>
      For example, if you wanted to run the <command>test</command>
      target for all build items are declared as testers (using the
      <property>tester</property> trait) of your build item or any of
      its dependencies, you could run the command

      <programlisting>abuild --build=current --related-by-traits=tester test
</programlisting>
      As above, if multiple traits are specified at once, only build
      items that are related by all of the specified traits are
      included.  Note that the same trait may be used referent to
      another build item or in isolation.  The
      <option>--related-by-traits</option> option only applies to
      traits used in reference to other build items.  For example, if
      a build item had the <property>tester</property> trait not
      referent to any build item, it would not be picked up by the
      above command.  The <option>--only-with-traits</option> option
      picks up all build items that have the named traits either in
      isolation or referent to other build items.
     </para>
     <para>
      It is also possible to combine these options.  In that case, the
      build set is first restricted using
      <option>--only-with-traits</option> and then expanded using the
      <option>--related-by-traits</option> as shown in examples below.
      The order of the arguments has no effect on this behavior.
     </para>
     <para>
      Ordinarily, when a specific target is specified as an argument
      to &abuild; (as in <command>abuild test</command> or
      <command>abuild deploy</command> rather than just
      <command>abuild</command>), &abuild; runs that target for every
      item initially in the build set (before dependency expansion).
      When the build set is expanded or restricted based on traits,
      any explicitly specified targets are run only for build items
      that have the specified traits.  This is important because it
      enables you to use traits to group build items that define
      specific custom targets.
     </para>
     <para>
      If <option>--related-by-traits</option> and
      <option>--only-with-traits</option> are both specified, any
      explicit targets are applied only to traits named in
      <option>--related-by-traits</option> as the effect of that
      option is applied last.  All other build items are built with
      the <command>all</command> target.  Note that the
      <option>--apply-targets-to-deps</option> option will cause any
      explicit targets to be applied to all build items, as always.
      Later in this chapter, we review the exact rules that &abuild;
      uses to decide which targets to apply to which build items.
     </para>
     <para>
      The <option>--list-traits</option> flag provides information
      about which traits can be used on the command line.  To see more
      detailed information about which traits were made available in
      which build trees, you can examine the output of <command>abuild
      --dump-data</command> (see <xref linkend="ref.dump-data"/>).
     </para>
     <para>
      For more information about how traits are handled with respect
      to backing areas and externals, please see <xref
      linkend="ref.computing-valid-traits"/>.  For more detailed
      information about how build sets are constructed with respect to
      traits, please see <xref
      linkend="ref.construction-of-build-sets"/>.
     </para>
    </sect2>
    <sect2 id="ref.trait.invocation-examples">
     <title>Example Trait Invocations</title>
     <variablelist>
      <varlistentry>
       <term><command>abuild --build=desc --only-with-traits
       deployable deploy</command></term>
       <listitem>
        <para>
         Run the <command>deploy</command> target for all items at or
         below the current directory that have the
         <property>deployable</property> trait, and run the
         <command>all</command> target for all items that they depend
         on.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --build=current --related-by-traits
       tester test</command></term>
       <listitem>
        <para>
         Build the current build item and all of its dependencies with
         the <command>all</command> target, and run the
         <command>test</command> target for any build items that
         declared themselves as a tester for any of those items.  Any
         additional dependencies of the testers would also be built
         with the <command>all</command> target.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --build=local --only-with-traits
       deployable,tester deploy test</command></term>
       <listitem>
        <para>
         Run both the <command>deploy</command> and the
         <command>test</command> targets for any build items in the
         local build tree (the current build item's tree excluding its
         externals) that have both the <property>deployable</property>
         and the <property>tester</property> traits either specified
         alone or in reference to other build items.  Run the
         <command>all</command> target for their dependencies.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><command>abuild --build=all
       --only-with-traits requires-hw --related-by-traits tester
       hwtest</command></term>
       <listitem>
        <para>
         Run the <command>all</command> target for all items that have
         the <property>requires-hw</property> trait as well as any of
         their dependencies, and run the <command>hwtest</command>
         target for all items that test any of them.  Additional
         dependencies of the testers would also be built with the
         <command>all</command> target.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </sect2>
    <sect2 id="ref.target-selection">
     <title>Target Selection</title>
     <para>
      Although we have described how various options affect which
      build items are built with which targets, we summarize that
      information here so that it all appears in one place.  Put
      simply, the default behavior is that &abuild; applies any
      explicitly named targets to all build items that directly match
      the criteria for belonging to the named build set.  Any build
      items that &abuild; is building just to satisfy dependencies are
      built with the <command>all</command> target.  This behavior is
      overridden by specifying
      <option>--apply-targets-to-deps</option>, which causes &abuild;
      to build all build items with the explicit targets.  The exact
      rules are described in the list below.  These rules apply only
      when a build set is specified with <option>--build</option> or
      <option>-b</option>.  There are several mutually exclusive
      cases:
      <orderedlist>
       <listitem>
        <para>
         The <option>--apply-targets-to-deps</option> option was
         specified or the explicit target is <command>no-op</command>.
         In this case, any explicitly named targets are applied to all
         items in the build set.
        </para>
       </listitem>
       <listitem>
        <para>
         The <option>--apply-targets-to-deps</option> option was not
         specified, the target is not <option>no-op</option>, and no
         trait arguments were specified.  In this case, all items that
         were initially added to the build set are built with any
         explicitly specified targets.  Any build items added to the
         build set to satisfy dependencies are built with the
         <command>all</command> target.
        </para>
       </listitem>
       <listitem>
        <para>
         The <option>--apply-targets-to-deps</option> option was not
         specified, the target is not <option>no-op</option>,
         <option>--only-with-traits</option> <emphasis>was</emphasis>
         specified, and <option>--related-by-traits</option>
         <emphasis>was not</emphasis> specified.  In this case, all
         items belonging to the original build set and having all of
         the named traits are built with the explicit targets.  Other
         items (dependencies of build items with the named traits but
         that do not have the named traits themselves) are built with
         the <command>all</command> target.
        </para>
       </listitem>
       <listitem>
        <para>
         The <option>--apply-targets-to-deps</option> option was not
         specified, the target is not <option>no-op</option>, and
         <option>--related-by-traits</option> <emphasis>was</emphasis>
         specified.  In this case, the build set is first constructed
         normally and then restricted to any items that have all the
         traits specified in the <option>--only-with-traits</option>
         option, if any.  Then it is expanded to include any build
         item related to one of the original build set members by all
         the traits named in <option>--related-by-traits</option>.
         These related items are built with the explicit targets.
         Other items, including additional dependencies of related
         items, are built with the <command>all</command> target.
        </para>
       </listitem>
      </orderedlist>
      For more detailed information on how the build set is
      constructed, please see <xref
      linkend="ref.construction-of-build-sets"/>.
     </para>
    </sect2>
   </sect1>
   <sect1 id="ref.general-build-examples">
    <title>Build Set and Trait Examples</title>
    <para>
     Now that we've seen the topics of build sets and traits, we're
     ready to revisit our previous examples.  This time, we will talk
     about how traits are used in a build tree, and we will
     demonstrate the results of running &abuild; with different build
     sets.  We will also make use of the special target
     <command>no-op</command> which can be useful for debugging your
     build trees.
    </para>
    <sect2 id="ref.example.common-code-area">
     <title>Common Code Area</title>
     <para>
      Any arguments to &abuild; that are not command-line options are
      interpreted as targets.  By default, &abuild; uses the
      <command>all</command> target to build each build item in the
      build set.  If targets are named explicitly, for the build items
      to which they apply, they are passed directly to the backend.
      There are two exceptions to this rule: the special targets
      <command>clean</command> and <command>no-op</command> are
      trapped by &abuild; and handled separately without invocation of
      the backend.  We have already seen the <command>clean</command>
      target: it just removes any &abuild; output directories in the
      build item directory.  The special <command>no-op</command>
      target causes &abuild; to go through all the motions of building
      except for actually invoking the backend.  The
      <command>no-op</command> command is useful for seeing what build
      items would be built and what platforms in a particular
      invocation of &abuild;.  It does all the same validation on
      <filename>Abuild.conf</filename> files as a regular build, but
      it doesn't look at <filename>Abuild.interface</filename> files
      or build files (<filename>Abuild.mk</filename>, etc.).
     </para>
     <para>
      We return now to the <filename>reference/common</filename>
      directory to demonstrate both the <command>no-op</command>
      target and some build sets.  From the
      <filename>reference/common</filename> directory, we can run
      <command>abuild --build=local no-op</command> to tell &abuild;
      to run the special <command>no-op</command> target for every
      build item in the local build tree.  Since this tree has no
      externals, there is no chance that there are any dependencies
      that are satisfied outside of the local build tree.  Running
      this command produces the following results (with the native
      platform again replaced by the string
      <literal>&lt;native&gt;</literal>):
      <?qtest example.reference-common-no-op.out?>
      Of particular interest here is the order in which &abuild;
      visited the items.  &Abuild; makes no specific commitments about
      the order in which items will be built except that no item is
      ever built before its dependencies are built.
      <footnote>
       <para>
        In fact, when &abuild; creates a build order, it starts with a
        lexically sorted list of build items and overrides the
        ordering based on dependencies.  The exact order of build
        items, other than that dependencies are built before items
        that depend on them, should be considered an implementation
        detail and not relied upon.
       </para>
      </footnote>
      Since <classname>common-lib2.src</classname> depends on
      <classname>common-lib3.src</classname> (indirectly through its
      dependency on <classname>common-lib3</classname>), &abuild;
      automatically builds <classname>common-lib3.src</classname>
      before it builds <classname>common-lib2.src</classname>.  On the
      other hand, since <classname>common-lib2.test</classname> has no
      dependency on <classname>common-lib3.test</classname>, no
      specific ordering is necessary in that case.  If you were to run
      <command>abuild --clean=local</command> from this directory, you
      would not observe the same ordering of build items since
      &abuild; does not pay any attention to dependencies when it is
      running the clean target, as shown:
      <?qtest example.reference-common-clean-local.out?>
      Note also that only the build items that have
      <filename>Abuild.mk</filename> files are cleaned.  &Abuild;
      knows that there is nothing to build in items without
      <filename>Abuild.mk</filename> files and skips them when it is
      building or cleaning multiple items.
     </para>
     <para>
      If you are following along, then go to the
      <filename>reference/common</filename> directory and run
      <command>abuild --build=desc check</command>.  This will build
      and run the test suites for all build items at or below that
      directory, which in this case, is the same collection of build
      items as the <option>local</option> build set.
      <footnote>
       <para>
        The test suites in this example are implemented with <ulink
        url="http://qtest.qbilt.org">QTest</ulink>, which therefore
        must be installed for you to run them.  See <xref
        linkend="ref.test-integration"/>.
       </para>
      </footnote>
      This produces the following output, again with some
      system-specific strings replaced with generic values:
      <?qtest example.reference-common-check.out?>
      This example includes the output of
      <application>qtest</application> test suites.
      <application>QTest</application> is a simple and robust
      automated test framework that is integrated with &abuild; and
      used for &abuild;'s own test suite.  For information, see <xref
      linkend="ref.qtest"/>.
     </para>
     <para>
      By default, when &abuild; builds multiple build items using a
      build set, it will stop after the first build failure.
      Sometimes, particularly when building a large build tree, you
      may want &abuild; to try to build as many build items as it can,
      continuing on failure.  In this case, you may pass the
      <option>-k</option> option to &abuild;.  When run with the
      <option>-k</option> option, &abuild; will continue building
      other items after one item fails.  Note, however, that if one
      build item fails, &abuild; will not attempt to build any other
      items that depend on the failed item even when run with
      <option>-k</option>.  It will also exit with an abnormal exit
      status after it builds everything that it can.  When run with
      <option>-k</option>, &abuild; also passes the corresponding
      flags to the backends so that they will try to build as much as
      they can without stopping on the first error.  Both
      <application>make</application> and
      <application>ant</application> behave similarly to &abuild;:
      they will keep going on failure, skip any targets that depend on
      failed targets, and exit abnormally if any failures are
      detected.
     </para>
    </sect2>
    <sect2 id="ref.example.project-code-area">
     <title>External Build Tree Example: Project Code Area</title>
     <para>
      Returning to the project area, we demonstrate how dependencies
      may be satisfied in externals and the effect this has on the
      build set.  Under <filename>reference/project</filename>, we have
      just two public build items called
      <classname>project-main</classname> and
      <classname>project-lib</classname>.  The
      <classname>project-lib</classname> build item is structured like
      the libraries in the common area.  The
      <classname>project-main</classname> build item has a
      <filename>src</filename> directory that builds an executable and
      has its own test suite.  We have already seen that
      <filename>reference/project/Abuild.conf</filename> has an
      <property>external-dirs</property> key that points to
      <filename>../common</filename> and that items from the project
      tree depend on build items from <filename>../common</filename>.
      Specifically, <classname>project-lib</classname> depends on
      <classname>common-lib1</classname> and
      <classname>project-main</classname> depends on
      <classname>common-lib2</classname> which in turn depends on
      <classname>common-lib3</classname>.
     </para>
     <para>
      If we go to <filename>reference/project/main/src</filename> and run
      <command>abuild --build=current no-op</command>, we see the
      following output:
      <?qtest example.reference-project-main-no-op.out?>
      Notice here that &abuild; only built the build items whose names
      end with <classname>.src</classname>, and that it built the
      items in dependency order.  We can also run <command>abuild
      --build=current --apply-targets-to-deps check</command> to run
      the <command>check</command> target for each of these build
      items.  This generates the following output:
      <?qtest example.reference-project-main-check.out?>
      The presence of the <option>--apply-target-to-deps</option> flag
      caused the <command>check</command> target will be run for our
      dependencies as well as the current build item.  In this case,
      there were no actions performed building the files in
      <filename>common</filename> because they were already built.  If
      individual files had been modified in any of these build items,
      the appropriate targets would have been rebuilt subject to the
      ordinary file-based dependency management performed by make or
      ant.
     </para>
    </sect2>
    <sect2 id="ref.example.trait">
     <title>Trait Example</title>
     <para>
      In our previous example, we saw the <command>check</command>
      target run for each item (that has a build file).  Since the
      items other than <classname>project-main</classname> don't
      contain their own test suites, we see the test suite only for
      <classname>project-main</classname>.  Sometimes we might like to
      run all the test suites of all the build items we depend on,
      even if we don't depend on their test suites directly.  We can
      do this using traits, assuming our build tree has been set up to
      use traits for this purpose.  Recall from earlier that our
      <filename>common</filename> build tree declared the
      <property>tester</property> trait in its root build item's
      <filename>Abuild.conf</filename>.  Here is that file again:
      <?example general/reference/common/Abuild.conf?>
      Also, recall that all the test suites declared themselves as
      testers of the items that they tested.  Here again is
      <classname>common-lib1.test</classname>'s
      <filename>Abuild.conf</filename>, which declares
      <classname>common-lib1.test</classname> to be a tester of
      <classname>common-lib1.src</classname>:
      <?example general/reference/common/lib1/test/Abuild.conf?>
      Given that all of our build items are set up in this way, we can
      instruct &abuild; to run the test suites for everything that we
      depend on.  We do this by running <command>abuild --with-deps
      --related-by-traits tester check</command>.  This runs the
      <command>check</command> target for every item that declares
      itself as a tester of the current build item or any of its
      dependencies, and the <command>all</command> target for
      everything else, including any additional dependencies of any of
      those test suites.  That command generates the following output:
      <?qtest example.reference-project-main-trait-test.out?>
      Observe that the previously unbuilt
      <classname>project-lib.test</classname> build item was built
      using the <command>check</command> target by this command, and
      that all the test suites were run.  If your development area has
      good test suites, you are encouraged to use a trait to indicate
      which items they test as we have done here using the
      <property>tester</property> trait.  This enables you to run the
      test suites of items in your dependency chain.  This can give
      you significant assurance that everything you depend on is
      working the way it is supposed to be each time you start a
      development or debugging session.
     </para>
    </sect2>
    <sect2 id="ref.example.derived-project">
     <title>Derived Project Example</title>
     <para>
      Finally, we return to our derived project build tree in
      <filename>reference/derived</filename>.  This build tree
      declares <filename>../project</filename> as an external.  As
      pointed out before, although <filename>derived</filename> does
      not declare <filename>../common</filename> as an external, it
      can still use build items in <filename>../common</filename>
      because a build tree automatically inherits externals from its
      externals.  If we run <command>abuild --build=desc
      check</command> from <filename>reference/derived</filename>, we
      will see all our dependencies in <filename>../common</filename>
      and <filename>../project</filename> being built (though all are
      up to date at this point) before our own test suite is run.
      This is the case even though they are not all descendants of the
      current directory.  This again illustrates how &abuild; adds
      additional items to the build set as required to satisfy
      dependencies:
      <?qtest example.reference-derived-check.out?>
      We can also observe that we do not see this behavior with the
      special <command>clean</command> target.  Both <command>abuild
      --clean=desc</command> and <command>abuild
      --clean=local</command> produce this output when run from
      <filename>reference/derived</filename>:
      <?qtest example.reference-derived-clean-local.out?>
     </para>
     <para>
      As another demonstration of the transitive nature of externals
      (that externals are inherited through other externals), run
      <command>abuild --clean=all</command> from the root of the
      <filename>derived</filename> build tree.  That generates this
      output:
      <?qtest example.reference-derived-clean.out?>
      Here are a few things to notice:
      <itemizedlist>
       <listitem>
        <para>
         We clean all build items in <filename>common</filename> and
         <filename>project</filename> as well as in
         <filename>derived</filename>.
        </para>
       </listitem>
       <listitem>
        <para>
         Only build items that contain build files are visited.
        </para>
       </listitem>
       <listitem>
        <para>
         Build items are cleaned in an order that completely
         disregards any dependencies that may exist among them.
        </para>
       </listitem>
      </itemizedlist>
     </para>
    </sect2>
   </sect1>
  </chapter>
  <chapter id="ref.test-integration">
   <title>Integration with Automated Test Frameworks</title>
   <para>
    &Abuild; is integrated with two automated test frameworks: QTest,
    and JUnit.  Additional integrations can be performed with plugins
    or build item rules or hooks.
   </para>
   <sect1 id="ref.qtest">
    <title>Integration with QTest</title>
    <para>
     &Abuild; is integrated with the <ulink
     url="http://qtest.qbilt.org">QTest</ulink> test framework.  The
     QTest framework is a perl-based test framework intended to
     support a <emphasis>design for testability</emphasis> testing
     mentality.  &Abuild;'s own test suite is implemented using QTest.
     When using either the <application>make</application> or the
     <application>ant</application> backends, if a directory called
     <filename>qtest</filename> exists, then the
     <command>test</command> and <command>check</command> targets will
     invoke <command>qtest-driver</command> to run qtest-based test
     suites.  If a single file with the <filename>.testcov</filename>
     extension exists in the build item directory, &abuild; will
     invoke <command>qtest-driver</command> so that it can find the
     test coverage file and activate test coverage support.  Note that
     &abuild; runs <command>qtest-driver</command> from the output
     directory, so the coverage output files and
     <filename>test.log</filename> file will appear in that directory.
     If you wish to have a qtest-based test suite be runnable on
     multiple platforms simultaneously, it's best to avoid creating
     temporary files in the <filename>qtest</filename> directory.  If
     you wish to use the &abuild; output directory for your temporary
     files, you can retrieve the full path to this directory by
     calling the <function>get_start_dir</function> method of the
     qtest <classname>TestDriver</classname> object.
    </para>
   </sect1>
   <sect1 id="ref.junit">
    <title>Integration with JUnit</title>
    <para>
     When performing property-driven
     <application>ant</application>-based builds, if the
     <varname>abuild.junit.testsuite</varname> property is set to the
     name of a class, then the <command>test</command> and
     <command>check</command> targets will attempt to run a
     JUnit-based test suite.  JUnit is not bundled with &abuild;, so
     it is the responsibility of the build tree maintainer to supply
     the required JUnit JARs to &abuild;.  The easiest way to do this
     is to create a plugin that adds the JUnit JARs to
     <varname>abuild.classpath.external</varname> in a
     <filename>plugin.interface</filename> file.  For more details on
     plugins, please see <xref linkend="ref.plugins"/>.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.backing-areas">
   <!--  This chapter must precede the interface flags chapter     -->
   <!--  since the private interface flags examples are in a tree  -->
   <!--  with a backing area.                                      -->
   <title>Backing Areas</title>
   <para>
    <indexterm>
     <primary>backing area</primary>
    </indexterm>
    In a large development environment, it is very common for a
    developer to have a local work area that contains only the parts
    of the system that he or she is actually working on.  Any
    additional parts of the software that are required in order to
    satisfy dependencies would be resolved through some kind of
    outside, most likely read-only, reference area.  &Abuild; provides
    this functionality through the use of <firstterm>backing
    areas</firstterm>.
   </para>
   <para>
    At first glance, backing areas may seem very similar to externals,
    but they are different in some important ways.  As opposed to
    externals, backing areas are generally of more concern to baseline
    administrators than to developers.  The uses cases for them are
    also different.  We discuss this in more depth during this
    chapter.
   </para>
   <sect1 id="ref.backing-areas.setup">
    <title>Setting Up Backing Areas</title>
    <para>
     Any build tree can be a backing area.  If &abuild; needs to
     reference a build item that is found in the local build tree or
     its externals, it will use that copy of the build item.  If
     &abuild; can't find an item in the local tree or its externals,
     it will use the backing area to resolve that build item.  Since
     &abuild; never attempts to build or otherwise modify an item in a
     backing area, backing areas must always be fully built on all
     platforms for which they will be used as backing areas.  (For
     additional details on platforms, please see <xref
     linkend="ref.platforms"/>.)  To designate another tree as your
     backing area, create a file called
     <filename>Abuild.backing</filename> in the root directory of your
     build tree and place the path (which may be absolute or relative)
     to the backing area in that file on a line by itself.  When one
     tree declares another tree as a backing area, we say that the
     tree <firstterm>backs to</firstterm> its backing area.  Creation
     and maintenance of backing areas is generally a function
     performed by the people who are in charge of maintaining the
     overall software baselines.  Most developers will just set up
     their backing areas according to whatever instructions they are
     given.  Having an external tool to create your
     <filename>Abuild.backing</filename> file is also reasonable.
     Note that <filename>Abuild.backing</filename> files should not
     generally be controlled in a version control system since they
     are a property of the developer's work area rather than of the
     software baseline.  If they are controlled, they should generally
     not be visible outside of the developer's work area.
    </para>
    <note>
     <para>
      Changing backing area configuration should generally be followed
      by a clean build.  This is also true when a build item is
      removed from a local build tree and therefore causes the build
      item with that name to resolve to the copy in backing area.  The
      reason is that changing the location of a build item changes the
      actual files on which the build target depends.  If those
      dependencies are older than the last build time, even if they
      were newer than the files they replaced,
      <application>make</application> and
      <application>ant</application> will not notice because the use
      modification time-based dependencies.  In other words, any
      operation that can replace one file with another file in such a
      way that the new file is not more recent than the last build
      should be followed by a clean build.
     </para>
    </note>
   </sect1>
   <sect1 id="ref.backing-areas.resolving-items">
    <title>Resolving Build Items to Backing Areas</title>
    <para>
     In this section, we will discuss backing areas from a
     functionality standpoint.  This section presents a somewhat
     simplified view of how backing areas actually work, but it is
     good enough to cover the normal cases.  To understand the exact
     mechanism that &abuild; uses to handle backing areas and
     externals with enough detail to fully understand the subtleties
     of how they work, please see <xref
     linkend="ref.traversal-details"/>.
    </para>
    <para>
     The purpose of a backing area is to enable a developer to create
     a partially populated build tree and to fall back to a more
     complete area for build items that are omitted in the local build
     tree.  A build tree may have at most one backing area, but its
     backing area's backing area is also searched, thus creating a
     chain of backing areas.  When &abuild; attempts to resolve a name
     to a path, if it is unable to resolve the name in your local
     build tree or its externals, it effectively searches for the name
     in your backing area chain, using whichever location it finds
     first.
     <footnote>
      <para>
       The actual implementation differs from this description, but
       the effect is the same.  For the real story, see <xref
       linkend="ref.traversal-details"/>.
      </para>
     </footnote>
     In this respect, your local build tree may
     <emphasis>shadow</emphasis> build items in your backing area.  We
     should draw a contrast here between backing areas and externals.
     Although they are both separate build trees that &abuild; uses to
     discover build items, a local build tree can only shadow build
     items in its backing area chain.  It cannot shadow build items in
     its externals.  If a local build tree and one of its externals
     define build items with the same name, this is an error.  If a
     local build tree and its backing area define build items with the
     same name, this is a normal case of using your local build area
     to modify code that may exist in the backing area in an earlier
     version.
    </para>
    <para>
     There is one important point about how &abuild; resolves build
     items in backing areas.  When &abuild; looks for a build item, it
     looks for it only by name, not by path.  This means that a build
     item in your local build tree does not have to have the same
     location relative to the root of the tree as that item has in the
     backing area.  This is very important as it allows you to use a
     local build tree to reorganize build items.  Note that this means
     that if you delete a build item from your local build tree and
     that build item exists in your backing area, the build item
     doesn't really go away from &abuild;'s perspective; rather it
     moves from the local build tree to the backing area.  If it is
     actually your intention to <emphasis>remove</emphasis> the build
     item so that its name is not known to other build items in your
     build tree, you can do this by adding the name of the build item
     to the <property>deleted</property> key of the root build item's
     <filename>Abuild.conf</filename> file.  If a build item is listed
     there, &abuild; requires that the build item be present in the
     backing area chain but not in the local build tree.  We present
     an example that illustrates the use of the
     <property>deleted</property> key in <xref
     linkend="ref.example.deleted-item"/>.
    </para>
   </sect1>
   <sect1 id="ref.backing-areas.resolving-externals">
    <title>Resolving Externals to Backing Areas</title>
    <para>
     In addition to being able to resolve build items to backing
     areas, it is also possible to resolve externals to backing areas.
     Specifically, if &abuild; can't find the specified external
     relative to the root of the current build tree, it will search
     for it relative to the roots of each tree in the backing area
     chain.
     <footnote>
      <para>
       &Abuild; only attempts to resolve externals to backing areas
       when the externals are specified with relative paths.  Since an
       absolute path is absolute, it doesn't make any sense to
       consider it relative to one location or another.
      </para>
     </footnote>
     This is illustrated in <xref linkend="fig.backed-external"/>.  In
     this case, we have a build tree at
     <filename>/backing/1</filename> that declares
     <filename>../ext</filename> as an external in its root
     <filename>Abuild.conf</filename>.  &Abuild; finds this external
     at <filename>/backing/ext</filename>.  We also have a tree at
     <filename>/tree/1</filename> that declares
     <filename>/backing/1</filename> as a backing area.  As is typical
     with build trees that have backing areas, the new build tree's
     root <filename>Abuild.conf</filename> is initially a copy of the
     root <filename>Abuild.conf</filename> from its backing area.  It
     therefore also declares <filename>../ext</filename> as an
     external.  When &abuild; attempts to find the external, it looks
     first in <filename>../ext</filename> relative to
     <filename>/tree/1</filename>, which would be
     <filename>/tree/ext</filename>.  Since that path does not exist,
     &abuild; will look for <filename>../ext</filename> relative to
     each backing area in the backing area chain.  In this case, it
     finds <filename>/backing/ext</filename> as
     <filename>../ext</filename> relative to backing area
     <filename>/backing/1</filename>, thus successfully resolving the
     external to the backing area.
     <figure id="fig.backed-external">
      <title>External Resolved in a Backing Area</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="backed-external.png"/>
       </imageobject>
       <caption>
        <para>
         <filename>/tree/1</filename> resolves external
         <filename>../ext</filename> to
         <filename>/backing/ext</filename>.
        </para>
       </caption>
      </mediaobject>
     </figure>
     The upshot of this behavior is that, when you wish to shadow
     build items in a particular build tree but you don't need to
     shadow any of the build items in its externals, you can just
     ignore the externals.  &Abuild; will resolve them to the backing
     area just as it would resolve any build items you omitted from
     your local tree.
    </para>
    <para>
     There is one corner case with backing areas and externals.  It
     will very seldom occur, but it's worth mentioning for
     completeness.  Understanding this case is not essential to make
     use of &abuild; for the vast majority of cases, so if this
     doesn't make sense to you, just continue reading at the beginning
     of the next section.
    </para>
    <para>
     For this case, suppose that you still didn't actually want to
     shadow any of the build items in the external tree but you wanted
     your local tree to see the external in some location other than
     <filename>/backing/ext</filename>, say
     <filename>/other/ext</filename>.  As illustrated in <xref
     linkend="fig.external-with-backing-area"/>, you could create a
     directory called <filename>/tree/ext</filename> and place within
     that directory an <filename>Abuild.backing</filename> containing
     <filename>/other/ext</filename> as the only file in
     <filename>/tree/ext</filename>; <emphasis>i.e.</emphasis>, there
     would be no <filename>/tree/ext/Abuild.conf</filename> file.  In
     this case, the build tree at <filename>/tree/ext</filename> would
     be an empty build tree that resolves <emphasis>all</emphasis> of
     its build items from its backing area,
     <filename>/other/ext</filename>.
     <figure id="fig.external-with-backing-area">
      <title>External with Separate Backing Area</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="external-with-backing-area.png"/>
       </imageobject>
       <caption>
        <para>
         <filename>/tree/1</filename>'s external
         <filename>../ext</filename> backs to
         <filename>/other/ext</filename> rather than
         <filename>/backing/ext</filename>.
        </para>
       </caption>
      </mediaobject>
     </figure>
     This is the only case in which &abuild; will allow a build tree
     to not contain an <filename>Abuild.conf</filename> file at its
     root.
    </para>
   </sect1>
   <sect1 id="ref.integrity-checks">
    <title>Integrity Checks</title>
    <para>
     In plain English, &abuild; guarantees that if
     <classname>A</classname> depends on <classname>B</classname> and
     <classname>B</classname> depends on <classname>C</classname>,
     <classname>A</classname> and <classname>B</classname> see the
     same copy of <classname>C</classname>.  To be more precise,
     &abuild; checks to make sure that no build item in a backing area
     references as a dependency or plugin an item that is shadowed in
     the local tree.  (Plugins are covered in <xref
     linkend="ref.plugins"/>.)
    </para>
    <para>
     We illustrate this in <xref linkend="fig.shadowed-dependency"/>.
     Suppose that build items <classname>A</classname>,
     <classname>B</classname>, and <classname>C</classname> are
     defined in build tree <filename>T2</filename> and that
     <classname>A</classname> depends on <classname>B</classname> and
     <classname>B</classname> depends on <classname>C</classname>.
     Now suppose you have a local build tree called
     <filename>T1</filename> that has <filename>T2</filename> as its
     backing area, and that you have build items
     <classname>A</classname> and <classname>C</classname> copied
     locally into <filename>T1</filename>, but that
     <classname>B</classname> is resolved in the backing area.
     <figure id="fig.shadowed-dependency">
      <title>Shadowed Dependency</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="shadowed-dependency.png"/>
       </imageobject>
       <caption>
        <para>
         <classname>A</classname> in <filename>/T1</filename> sees
         <classname>B</classname> in <filename>/T2</filename> and
         <classname>C</classname> in <filename>/T1</filename>, but
         <classname>B</classname> in <filename>/T2</filename> sees
         <classname>C</classname> in <filename>/T2</filename>.  This
         means <classname>A</classname> in <filename>/T1</filename>
         builds with two different copies of <classname>C</classname>.
        </para>
       </caption>
      </mediaobject>
     </figure>
     If you were to attempt to build <classname>A</classname>,
     <classname>A</classname> would refer to files in
     <classname>B</classname>, which comes from a backing area.
     <classname>B</classname> would therefore already be built, and it
     would have been built with the copy of <classname>C</classname>
     from the backing area.  <classname>A</classname>, on the other
     hand, would see <classname>C</classname> in the local build tree.
     That means that <classname>A</classname> is indirectly using two
     different copies of <classname>C</classname>.  Depending on what
     changes were made to <classname>C</classname> in the local build
     tree, this would likely cause the build of
     <classname>A</classname> to be unreproducible at best and
     completely unstable at worst.  The situation of
     <classname>B</classname> coming from a backing area and depending
     on <classname>C</classname>, which is shadowed locally, is what
     we mean when we say that <classname>B</classname> has shadowed
     dependencies.  The way to resolve this would be to copy
     <classname>B</classname> into <filename>T1</filename>.
    </para>
   </sect1>
   <sect1 id="ref.backing-areas-vs-externals">
    <title>Comparison of Backing Areas and Externals</title>
    <para>
     Although backing areas an externals serve completely different
     purposes, there are a number of similarities between them.  For
     this reason, people often get confused initially about which one
     to use for a particular case.  Here is a list of use cases, each
     of which is accompanied by a discussion of which type of outside
     build tree to use.
     <variablelist>
      <varlistentry>
       <term>Common Code Area</term>
       <listitem>
        <para>
         If you had a collection of build items implementing common
         code, you would reference the common code build tree as an
         external.  The common code build tree would be expected to be
         a stand-alone build tree (possibly with its own additional
         externals and backing area) that could exist completely
         independently from your local build tree.  Your local tree
         would include additional build items that may depend on
         these, but it would not override or replace any build items
         from the common code area.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Pre-built Read-only Reference Area</term>
       <listitem>
        <para>
         Suppose you had a large software baseline consisting of
         thousands of build items, and that you didn't want your
         developers to all have to have fully populated local copies
         of the build tree.  Instead, you wanted to provide a
         read-only reference area that was fully built, say, once a
         day.  Then your developers could create local work areas
         populated only with the portions of the code that they were
         actually modifying.  Each developer could set their backing
         area to the location of this read-only reference area.  Each
         developer's local tree would most likely shadow some build
         items from the backing area, and they may also add new build
         items corresponding to development of new code.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Third-Party Support Area</term>
       <listitem>
        <para>
         If you had a collection of build items that provided &abuild;
         wrappers around third-party software, such as
         <filename>Abuild.interface</filename> files that add those
         libraries to the library path or classpath, you would likely
         put those utility items in an external.  As with the common
         code area, developers would depend on the items from the
         third-party support area but would not override or replace
         them.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Task Branch Development Area</term>
       <listitem>
        <para>
         Suppose you wanted to make modifications to a project to
         complete a particular task.  You may create a side branch for
         that task in your version control system.  In this case, you
         might have a build tree based on the branch point of your
         side branch that would serve as the backing area for the task
         branch.  You could modify some components in your local work
         area and simply omit any unmodified portions of the system
         from that work area.  We provide an example of this usage
         below.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     A good rule of thumb is this: if your purpose is to make
     modifications to a part of a build tree without having to have
     local copies of the part of the system that you are not changing,
     you should be using a backing area.  If your purpose is to make
     use of a separate and self-contained collection of build items,
     you should be using an external.  It is very common for externals
     to correspond to separate development efforts.  Backing areas
     typically correspond to earlier or more stable versions of the
     same development effort.
    </para>
    <para>
     Here we will draw a comparison to how &abuild; treats certain
     situations with respect to backing areas and externals:
     <variablelist>
      <varlistentry>
       <term>Duplicated Build Item Name</term>
       <listitem>
        <para>
         If a build item in your local tree has the same name as a
         build item in one of its externals, &abuild; considers this
         to be an error and reports it as a duplicated build item
         name.  If a build item in your local tree has the same name
         as a build item in its backing area, this is the normal case
         of using a local tree to shadow a backing area.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Resolving Dependencies</term>
       <listitem>
        <para>
         A build item in a local tree is free to depend on a build
         item located in either an external or a backing area.  If a
         build item in an external tried to depend on a build item in
         the local tree, &abuild; would report this a dependency on an
         unknown build item because the build items in the external
         have no knowledge of the build items in the local tree.  If a
         build item in a backing area had a dependency on a build item
         that was shadowed in the local tree, &abuild; would report
         this as an integrity error and require you to make a local
         copy of the build item from the backing area, as discussed
         above in <xref linkend="ref.integrity-checks"/>.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </sect1>
   <sect1 id="ref.example.task-branch">
    <title>Task Branch Example</title>
    <para>
     In this example, we'll demonstrate a task branch.  Suppose our
     task branch makes changes to <filename>project</filename> but not
     to <filename>common</filename>.  We can set up a new build tree
     in which to do our work.  We would populate this build tree with
     whatever parts of <filename>project</filename> we wanted to
     modify.  We have set up this build tree in
     <filename>doc/example/general/task/project</filename>.
     Additionally, we have set this build tree's backing area to
     <filename>../../reference/project</filename> so that it would
     resolve any missing build items or externals to that location:
     <?example general/task/project/Abuild.backing?>
     Note that, although we used a relative path for our backing area
     in this example, we would ordinarily set our backing area to an
     absolute path.  We use a relative path here only so that the
     examples can remain independent of the location of
     <filename>doc/example</filename>.  Our task branch also includes
     the derived project.  Since we are not making modifications to
     any build items in <filename>common</filename>, we don't have to
     create a build tree at <filename>task/common</filename>, even
     though our root <filename>Abuild.conf</filename> lists
     <filename>../common</filename> as an external:
     <?example general/task/project/Abuild.conf?>
     Since that relative path exists as a valid build tree relative to
     our backing area, &abuild; will just use
     <filename>../common</filename> relative to the backing area
     (<filename>../../reference/project/../common</filename>, which is
     <filename>../../reference/common</filename>) to resolve the
     external.  For a diagram of the task branch build trees, see
     <xref linkend="fig.general-task"/>.
     <figure id="fig.general-task">
      <title>Build Trees in <filename>general/task</filename></title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="general-task.png"/>
       </imageobject>
       <caption>
        <para>
         The <filename>derived</filename> build tree in the
         <filename>task</filename> branch declares the
         <filename>project</filename> build tree as an external.  The
         <filename>project</filename> build tree in the
         <filename>task</filename> branch declares the
         <filename>common</filename> build tree as an external, but
         since the <filename>common</filename> build tree isn't
         shadowed in the <filename>task</filename> branch, that
         external is resolved to the <filename>reference</filename>
         tree instead.  The <filename>derived</filename> and
         <filename>project</filename> build trees in the
         <filename>task</filename> branch both back to their
         corresponding build trees in <filename>reference</filename>.
        </para>
       </caption>
      </mediaobject>
     </figure>
     As always, for this example to work properly, our
     backing area must be fully built.  If you are following along, to
     make sure this is the case, you should run <command>abuild
     --build=all</command> in <filename>reference/derived</filename>.
     Next run <command>abuild --build=all no-op</command> in
     <filename>task/project</filename>.  This generates the following
     output:
     <?qtest example.task-project-no-op.out?>
     This includes only items in our task branch.  No items in our
     backing area are included because &abuild; never attempts to
     build or modify build items in backing areas.
    </para>
    <para>
     If you study <filename>include/ProjectLib.hpp</filename> and
     <filename>src/ProjectLib.cpp</filename> in
     <filename>task/project/lib</filename> in comparison to their
     counterparts in <filename>reference/project/lib</filename>, you'll
     notice that the only change we made in this task branch is the
     addition of an optional parameter to
     <classname>ProjectLib</classname>'s constructor.  We also updated the
     test suite to pass a different argument to
     <classname>ProjectLib</classname>.  This new value comes from a new
     build item we added: <classname>project-lib.extra</classname>.  To
     add the new build item, we created
     <filename>task/project/lib/extra/Abuild.conf</filename>:
     and also added the <filename>extra</filename> directory in
     <filename>task/project/lib/Abuild.conf</filename>:
     <?example general/task/project/lib/extra/Abuild.conf?>
     <?example general/task/project/lib/Abuild.conf?>
     We didn't modify anything under
     <filename>task/project/main</filename> at all, but we included it
     in our task branch so we could run its test suite.  Remember that
     &abuild; won't try to build the copy of
     <classname>project-main</classname> there, and even if it did,
     that copy of <classname>project-main</classname> would not see
     our local copy of <classname>project-lib</classname>: it would
     see the copy in its own local build tree, which we have shadowed.
     This is an example of a shadowed dependency as described in <xref
     linkend="ref.integrity-checks"/>.  This is the output we see when
     running <command>abuild --build=all check</command> from
     <filename>task/project</filename>:
     <?qtest example.task-project-check.out?>
     As with the <command>no-op</command> build, we only see output
     relating to local build items, not to build items in our backing
     areas as they are assumed to be already built.
    </para>
   </sect1>
   <sect1 id="ref.example.deleted-item">
    <title>Deleted Build Item</title>
    <para>
     Here we present a new series of build trees located under
     <filename>doc/example/general/user</filename>.  These build trees
     back to our <filename>task</filename> and
     <filename>reference</filename> build trees from earlier examples.
     We will use these build trees to illustrate the use of the
     <property>deleted</property> key in a build tree's root build
     item's <filename>Abuild.conf</filename>.
    </para>
    <para>
     Suppose we have a user who is working on changes that are related
     in some way to the task branch.  We want to create a user branch
     that backs to the task branch.  Our user branch contains all
     three areas: <filename>common</filename>,
     <filename>project</filename>, and <filename>derived</filename>.
     We will ignore <filename>derived</filename> for the moment and
     focus only <filename>common</filename> and
     <filename>project</filename>.  Observe that
     <filename>common</filename> contains only the
     <filename>lib1</filename> directory and that
     <filename>project</filename> contains only the
     <filename>lib</filename> directory.  We make a gratuitous change
     to a source file in <classname>common-lib1.src</classname> just
     as another example of shadowing a build item from our backing
     area.  Since our task branch didn't contain
     <filename>common</filename>, the <filename>common</filename> in
     our <filename>user</filename> branch has to back to
     <filename>reference</filename>.  Here is
     <filename>user/common/Abuild.backing</filename>:
     <?example general/user/common/Abuild.backing?>
     For a diagram of the user build trees, see <xref
     linkend="fig.general-user"/>.
     <figure id="fig.general-user">
      <title>Build Trees in <filename>general/user</filename></title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="general-user.png"/>
       </imageobject>
       <caption>
        <para>
         The <filename>derived</filename> build tree in the
         <filename>user</filename> area declares the
         <filename>project</filename> build tree as an external.  The
         <filename>project</filename> build tree in the
         <filename>user</filename> area declares the
         <filename>common</filename> build tree as an external.  Each
         backs to its corresponding build tree in
         <filename>task</filename> except <filename>common</filename>.
         Since <filename>common</filename> does not exist in the
         <filename>task</filename> branch, <filename>common</filename>
         in the <filename>user</filename> area backs directly to
         <filename>common</filename> in
         <filename>reference</filename>.
        </para>
       </caption>
      </mediaobject>
     </figure>
    </para>
    <para>
     In <filename>project</filename>, we have made changes to
     <filename>project-lib</filename> to make use of private
     interfaces, which we discuss in <xref
     linkend="ref.interface-flags"/> and will ignore for the moment.
     We have also deleted the new build item
     <classname>project-lib.extra</classname> that we added in the
     task branch.  To delete the build item, we removed the
     <filename>extra</filename> directory from
     <filename>project/lib</filename> and from the
     <property>child-dirs</property> key in
     <filename>project/lib/Abuild.conf</filename>:
     <?example general/user/project/lib/Abuild.conf?>
     That in itself was not sufficient since, even though the
     <filename>extra</filename> directory is no longer present in the
     <property>child-dirs</property> key of
     <classname>project-lib</classname>'s
     <filename>Abuild.conf</filename>, we would just inherit
     <classname>project-lib.extra</classname> from our backing area.
     To really delete the build item, we also had to add a
     <property>deleted</property> key in
     <filename>user/project</filename>'s
     <filename>Abuild.conf</filename>:
     <?example general/user/project/Abuild.conf?>
     This has effectively prevented &abuild; from looking for
     <classname>project-lib.extra</classname> in the backing area
     chain.  If any build item in the local tree references
     <classname>project-lib.extra</classname>, an error will be
     reported because &abuild; now considers that to be an unknown
     build item.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.interface-flags">
   <!--  This chapter must follow the backing areas chapter since  -->
   <!--  the private interface flags examples are in a tree with   -->
   <!--  a backing area.                                           -->
   <title>Interface Flags</title>
   <para>
    In this chapter, we will example interface flags.  Ordinarily,
    when a an interface variable is set in an
    <filename>Abuild.interface</filename> file, that assignment is
    automatically visible to all build items that depend on the
    assigning build item.  Interface flags provide a mechanism to make
    certain variable assignments conditional upon the presence of a
    specified flag.  In this chapter, we will explore the interface
    system enough to see how to use it to implement private
    interfaces.  For a complete understanding of &abuild;'s interface
    system, please see <xref linkend="ref.abuild-interface-system"/>.
    For a discussion of how it is implemented, please see <xref
    linkend="ref.interface-implementation"/>.
   </para>
   <sect1 id="ref.using-flags">
    <title>Using Interface Flags</title>
    <para>
     There are three parts to interface flags.  The first part is that
     a build item declares what flags it supports by listing them in
     the <property>supported-flags</property> key of its
     <filename>Abuild.conf</filename>.  The second part is that a
     build item specifies which flags it wants set for its direct
     dependencies, if any, by specifying them in the
     <property>deps</property> key of its
     <filename>Abuild.conf</filename> file.  The third part is that a
     build item may associate a variable assignment (and only a
     variable assignment) in its <filename>Abuild.interface</filename>
     file with a particular flag.
    </para>
    <para>
     When one build item indicates that it should depend on other
     build item with a particular flag set, &abuild; checks to make
     sure that the dependent build item supports that flag, reporting
     an error if it does not.  Abuild also allows a build item to
     associate an interface variable assignment with a flag only if
     that flag is one of that build item's supported flags.
    </para>
    <para>
     When an <filename>Abuild.interface</filename> file is read by
     another build item, assignments associated with a particular flag
     are processed only if the depending build item has explicitly
     requested the flag through a
     <option>-flag=<replaceable>interface-flag</replaceable></option>
     option to a dependency in the <property>deps</property> key of
     its <filename>Abuild.conf</filename> file.  Flag-based
     assignments are not evaluated until interface data is passed to
     the backends.  This means that flag-based assignments are not
     inherited through dependencies.  As such, the effects of these
     variable assignments are not visible in other
     <filename>Abuild.interface</filename> files.
     <footnote>
      <para>
       If you're getting the feeling that we're covering something up,
       you're right.  If your goal is to just understand how to use
       private interfaces, read on.  If you're getting confused about
       why it works this way and how it could possibly work, you may
       want to bite the bullet and read <xref
       linkend="ref.interface-implementation"/>.  All is revealed
       there.
      </para>
     </footnote>
     Also, a build item always implicitly has all its own flags set
     when its own interfaces are exported to itself.  For example, in
     <xref linkend="fig.private-flag"/>, <classname>B</classname> has
     an <filename>include</filename> directory and a
     <filename>private-include</filename> directory.  It wants the
     <filename>include</filename> directory to be visible to all build
     items that depend on it, but the
     <filename>private-include</filename> directory should be visible
     only to other build items that specifically ask for it.
     <classname>B</classname> could indicate that it supports the
     <property>private</property> flag and could add the
     <filename>private-include</filename> directory to
     <varname>INCLUDES</varname> conditionally upon that flag.  If
     <classname>A</classname> wanted to see the
     <filename>private-include</filename> directory, it could indicate
     that it wants the <property>private</property> flag set when it
     reads <classname>B</classname>'s
     <filename>Abuild.interface</filename>.  Then, when
     <classname>A</classname> reads <classname>B</classname>'s
     <filename>Abuild.interface</filename> file, it will see the
     <filename>private-include</filename> assignment.
     <classname>B</classname> will also see it because build items
     always see all of their own flag-based assignments.  If a third
     build item <classname>X</classname> depended on
     <classname>A</classname>, it would not see
     <classname>B</classname>'s <filename>private-include</filename>
     directory as that assignment would not be inherited through
     <classname>A</classname>'s interface.
     <figure id="fig.private-flag">
      <title>Private Interface Flag</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="private-flag.png"/>
       </imageobject>
       <caption>
        <para>
         <classname>A</classname> and <classname>B</classname> see
         <filename>private-include</filename>, but
         <classname>X</classname> does not.
        </para>
       </caption>
      </mediaobject>
     </figure>
     This is a bit tricky to understand.  For additional
     clarification, see the example below, <xref
     linkend="ref.example.private-interface"/>.
    </para>
    <para>
     Although we have used a single and generically named
     <property>private</property> flag for this example, there is
     nothing special about the name
     &ldquo;<property>private</property>&rdquo;.  There's no reason
     that other special-purpose flags couldn't be introduced to
     provide fine-grained control over which parts of a build item are
     to be visible to other build items.  In most cases, use of a
     simple flag like <property>private</property> should suffice.  To
     reduce confusion among developers in a project, it is recommended
     that a project adopt its own conventions about how interface
     flags will be used.
    </para>
   </sect1>
   <sect1 id="ref.example.private-interface">
    <title>Private Interface Example</title>
    <indexterm>
     <primary>private interfaces</primary>
    </indexterm>
    <para>
     Here we return to our <filename>user</filename> trees in
     <filename>doc/example/general/user</filename>.  In our user
     branch, we have modified the <classname>project-lib</classname>
     library to make use of private interfaces.  If you look at the
     <filename>Abuild.conf</filename> in the <filename>src</filename>
     directory, you will see that it lists
     <property>private</property> in its
     <property>supported-flags</property> key:
     <?example general/user/project/lib/src/Abuild.conf?>
     In its <filename>Abuild.interface</filename> file, it adds
     <filename>../private-include</filename> to
     <varname>INCLUDES</varname> only when the
     <property>private</property> flag is set:
     <?example general/user/project/lib/src/Abuild.interface?>
     This makes the headers in the
     <filename>private-include</filename> directory visible to it and
     any build item that depends on it with
     <option>-flag=private</option>.
     <footnote>
      <para>
       Note that when the <property>private</property> flag is set,
       <emphasis>both</emphasis> assignments to
       <varname>INCLUDES</varname> take effect.  To understand why
       this is, please see <xref
       linkend="ref.interface-implementation"/>.
      </para>
     </footnote>
     Note that the
     <classname>project-lib.src</classname> build item didn't have to
     do anything special to see its own private interfaces.  This is
     because a build item automatically operates with all of its own
     interface flags set for itself.  Another thing we've done in this
     build item is to put the new source file
     <filename>ProjectLib_private.cpp</filename> in a
     <filename>private</filename> subdirectory:
     <?example general/user/project/lib/src/Abuild.mk?>
     The only reason we did this was to demonstrate that &abuild;
     allows multi-element paths (<emphasis>i.e.</emphasis>, paths
     with subdirectories in them) in your source variables.  Just
     avoid putting &ldquo;<filename>..</filename>&rdquo; anywhere in
     the path.
     <footnote>
      <para>
       Such constructs, if permitted, would potentially cause &abuild;
       to write files outside the output directory.  For example, if
       you had <filename>../A.cc</filename> as a source file, &abuild;
       would construct
       <filename>abuild-<replaceable>platform</replaceable>/../A.o</filename>
       as the object file name.  Fortunately, &abuild; actually
       detects this case and reports an error.
      </para>
     </footnote>
    </para>
    <para>
     If you study <filename>ProjectLib.cpp</filename> in
     <filename>user/project/lib/src</filename>, you will notice that
     we have included the file
     <filename>ProjectLib_private.hpp</filename>, which is located in
     the <filename>private-include</filename> directory, and that we
     have called a function that is declared in that file to get the
     value with which we initialize <varname>cl1</varname>:
     <?example general/user/project/lib/private-include/ProjectLib_private.hpp?>
     <?example general/user/project/lib/src/ProjectLib.cpp?>
     Private interfaces can be particularly useful in any
     implementation that hides implementation details from outside
     users because it can prevent accidentally accessing restricted
     header files.  This type of construct is most useful in straight
     C code rather than C++ code since C doesn't provide any
     encapsulation capability other than use of opaque types defined
     in private header files.  This is somewhat akin to using the
     <function>friend</function> keyword in C++, except that access to
     private interfaces is requested by the accessor rather than the
     accessee.
     <footnote>
      <para>
       Since the build item that supports the
       <property>private</property> flag is also protected by the
       scope of its name, this gives us an added layer of protection.
      </para>
     </footnote>
    </para>
    <para>
     The test code in <filename>main.cpp</filename> in
     <filename>user/project/lib/test</filename> also calls a function
     defined in the private header file.  Note that the
     <filename>Abuild.conf</filename> file in the
     <filename>test</filename> directory mentions
     <classname>project-lib.src</classname> explicitly in its
     dependency list, and that it is followed by
     <option>-flag=private</option>:
     <?example general/user/project/lib/test/Abuild.conf?>
     This means that when <classname>project-lib.test</classname>
     reads <classname>project-lib.src</classname>'s
     <filename>Abuild.interface</filename> file, any assignments that
     are flagged with the <property>private</property> flag will be
     processed.
    </para>
    <para>
     The alert reader may notice that we have also assigned the trait
     <property>interesting</property> to this build item.  Although the
     build item is somewhat interesting, the primary purpose of doing
     this is to illustrate the use of a trait without a referent build
     item and to show how a trait can be added in a specific tree to
     supplement traits that are available because of our externals.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.command-line">
   <title>Command-Line Reference</title>
   <para>
    This chapter presents full detail about how to invoke &abuild;
    from the command line.  Some of functionality described here is
    explained in the chapters of <xref linkend="ref.part3"/>.
   </para>
   <sect1 id="ref.command-line-arguments">
    <title>Basic Invocation</title>
    <para>
     When running &abuild;, the basic invocation syntax is as follows:

     <programlisting><command>abuild [options] [targets]</command>
</programlisting>
     Options and targets may appear in any order.  Any argument that
     starts with a dash (&ldquo;<option>-</option>&rdquo;) is treated
     as an option.  Anything else is considered to be a target.
    </para>
   </sect1>
   <sect1 id="ref.command-line.informational">
    <title>Informational Options</title>
    <para>
     These options print information and exit without building
     anything.
    </para>
    <variablelist>
     <varlistentry>
      <term>--dump-build-graph</term>
      <listitem>
       <para>
        Dump to standard output the complete build graph consisting of
        items and platforms.  This is primarily useful for debugging
        &abuild; or diagnosing unusual problems relating to which
        items are built in which order.  Although nothing is built in
        when this option is specified, &abuild; still performs
        complete validation including reading of all the interface
        files.  The build graph is discussed in <xref
        linkend="ref.construction-of-build-graph"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--dump-data</term>
      <listitem>
       <para>
        Dump to standard output all information computed by &abuild;.
        Useful for debugging or for tools that need in-depth
        information about what &abuild; knows.
        <option>--dump-data</option> is mutually exclusive with
        running any targets.  If you need to see
        <option>--dump-data</option> output and build targets at the
        same time, use <option>--monitored</option> instead (see
        <xref linkend="ref.monitored-mode"/>).  For details about the
        format generated by <option>--dump-data</option>, please see
        <xref linkend="ref.dump-data"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--help|-H</term>
      <listitem>
       <para>
        Print a brief summary of &abuild;'s command-line options.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--list-platforms</term>
      <listitem>
       <para>
        Print the names of all object-code platforms categorized by
        platform type and build tree, and indicate which ones would be
        built by default.  Note that &abuild; may build on additional
        platforms beyond those selected by default in order to satisfy
        dependencies from other items.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--list-traits</term>
      <listitem>
       <para>
        Print the names of all traits known in the local build tree,
        its backing areas, and its externals.  This is the list of
        traits that are available for use on the command line with the
        <option>--only-with-traits</option> and
        <option>--related-by-traits</option> options.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--print-abuild-top</term>
      <listitem>
       <para>
        Print the path to the top of &abuild;'s installation.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>-V|--version</term>
      <listitem>
       <para>
        Print the version number of &abuild;.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
   <sect1 id="ref.command-line.control">
    <title>Control Options</title>
    <para>
     These options change some aspect of how &abuild; starts or runs.
    </para>
    <variablelist>
     <varlistentry>
      <term>--ant</term>
      <listitem>
       <para>
        Terminate argument parsing and pass all remaining arguments
        (up to <option>--make</option>) to ant.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>-C start-directory</term>
      <listitem>
       <para>
        Change directories to the given directory before building.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>-e | --emacs</term>
      <listitem>
       <para>
        Tell ant to run in emacs mode by passing the
        <option>-e</option> flag to it and also setting the property
        <varname>abuild.private.emacs-mode</varname>.  Ant targets can
        use this information to pass to programs whose output may need
        to be dependent upon whether or not emacs mode is in effect.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--find-conf</term>
      <listitem>
       <para>
        Locates the first directory at or above the current directory
        that contains an <filename>Abuild.conf</filename> file, and
        changes directories to that location before building.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--full-integrity</term>
      <listitem>
       <para>
        Performs &abuild;'s integrity checks for all items in the
        local tree, externals, and backing areas.  Ordinarily,
        &abuild; performs its integrity check only for items that are
        being built in the current build.  The
        <option>--full-integrity</option> flag would generally be
        useful only for people who are maintaining backing areas that
        are used by other people.  For detailed information about
        &abuild;'s integrity checks, please see <xref
        linkend="ref.integrity-checks"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>-jn| --jobs=n</term>
      <listitem>
       <para>
        Build up to <emphasis>n</emphasis> build items in parallel by
        invoking up to <emphasis>n</emphasis> simultaneous instances
        of the backend.  Does not cause the backend to run multiple
        jobs in parallel.  See also <option>--make-jobs</option>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>-k | --keep-going</term>
      <listitem>
       <para>
        Don't stop the build after the first failed build item, but
        instead continue building additional build items that don't
        depend on any failed items.  Also tells backend to continue
        after its first failure.  Even with <option>-k</option>,
        &abuild; will never try to build an item if any of its
        dependencies failed.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--make</term>
      <listitem>
       <para>
        Terminate argument parsing and pass all remaining arguments
        (up to <option>--ant</option>) to make.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--make-jobs[=n]</term>
      <listitem>
       <para>
        Allow make to run up to <emphasis>n</emphasis> jobs in parallel.
        Omit <emphasis>n</emphasis> to allow make to run as many jobs as
        it wants.  Be aware that if this option is used in combination
        with <option>--jobs</option>, the total number of threads
        could potentially be the product of the two numerical
        arguments.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--monitored</term>
      <listitem>
       <para>
        Run in monitored mode.  For details, see <xref
        linkend="ref.monitored-mode"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>-n | --just-print | --dry-run | --recon</term>
      <listitem>
       <para>
        For make-based builds only: have make print what it would do
        without actually doing it.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--no-abuild-logger</term>
      <listitem>
       <para>
        Do not tell ant to use the custom
        <classname>AbuildLogger</classname> as its logger.
        <classname>AbuildLogger</classname> is aware of the
        possibility of nested ant targets and also properly suppresses
        output of empty ant targets.  As of ant version 1.7, the
        <classname>DefaultLogger</classname> and
        <classname>NoBannerLogger</classname> loggers produce
        misleading output when there are nested ant targets.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--platform-selector selector | -p selector</term>
      <listitem>
       <para>
        Specify a platform selector for object code platforms.  This
        argument may be repeated any number of times.  Later instances
        supersede earlier ones when they specify selection criteria for
        the same platform type.  When two selectors refer to different
        platform types, both selectors are used.  Platform selectors
        may also be given in the
        <envar>ABUILD_PLATFORM_SELECTION</envar> environment variable.
        For details on platform selectors, see <xref
        linkend="ref.platform-selection"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--silent</term>
      <listitem>
       <para>
        Suppress most non-error output.  Also tells
        <application>make</application> and
        <application>ant</application> to generate less output.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--verbose</term>
      <listitem>
       <para>
        Generate more verbose output.  Also tells
        <application>make</application> and
        <application>ant</application> to generate more output.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
   <sect1 id="ref.command-line.build">
    <title>Build Options</title>
    <para>
     These options tell &abuild; what to build and what targets to
     apply to items being built.
    </para>
    <variablelist>
     <varlistentry>
      <term>--apply-targets-to-deps</term>
      <listitem>
       <para>
        Ordinarily, any explicitly specified targets are applied only
        to items that were directly selected for inclusion in the
        build set.  With this flag, they are applied to all items
        being built, including recursively expanded dependencies.
        When used with a clean set, this option causes the clean set
        to expanded to include dependencies, which is otherwise not
        done.  For detailed information about target selection, please
        see <xref linkend="ref.what-to-build"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--build=set | -b set</term>
      <listitem>
       <para>
        Specify which build items should be built.  The default is to
        have no build set specified.  In that case, &abuild; just
        builds in the local directory without attempting to build any
        dependencies.  For additional details including a list of
        valid values for <replaceable>set</replaceable>, see <xref
        linkend="ref.what-to-build"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--clean=set | -c set</term>
      <listitem>
       <para>
        Run <command>abuild clean</command> in all items in the build
        set.  The same build sets are defined as with the
        <option>--build</option> option.  Unlike build sets, clean
        sets are not expanded to include dependencies, and build
        items are not cleaned in dependency order.  No targets may be
        specified in conjunction with this option.  For additional
        details including a list of valid values for
        <replaceable>set</replaceable>, see <xref
        linkend="ref.what-to-build"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--only-with-traits trait[,trait,...]</term>
      <listitem>
       <para>
        Exclude from the initial build set any items that do not
        contain all of the named traits.  As always, all dependencies
        of any item in the reduced build set will remain in the build
        set regardless of what traits they have.  If not accompanied
        by the <option>--related-by-traits</option> option, any
        explicitly named targets will be applied only to items that
        have all of the named traits.  Other items (those they depend
        on) will be built with the default <command>all</command>
        target.  If accompanied by the
        <option>--related-by-traits</option> option, the
        <option>--related-by-traits</option> option's behavior with
        respect to explicit targets takes precedence.  For more
        information about traits, see <xref linkend="ref.traits"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--related-by-traits=trait[,trait,...]</term>
      <listitem>
       <para>
        Expand the build set with items that have all of the named
        traits relative to any item already in the build set.
        Specifying this option also causes any explicitly specified
        targets to be run only for those items.  The default target
        <command>all</command> is run for all other build items in the
        build set.  For more information about traits, see <xref
        linkend="ref.traits"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>--with-deps | -d</term>
      <listitem>
       <para>
        Alternative for <option>--build=current</option>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
   <sect1 id="ref.targets.general">
    <title>General Targets</title>
    <para>
     &Abuild;'s <application>make</application> and property-driven
     <application>ant</application> backends define several targets
     that are available for use from the command line.  When one of
     those two build methods is used, you can rely on these targets
     being defined.  When the build.xml-driven
     <application>ant</application> method is used (the build file is
     <filename>Abuild-ant.xml</filename>), then it is up to the author
     of the build file to provide these targets.
    </para>
    <variablelist>
     <varlistentry>
      <term>all</term>
      <listitem>
       <para>
        This is the default target.  It is used to build all
        products that are intended for use by the end user or by
        other build items.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>check</term>
      <listitem>
       <para>
        This target ensures that the local build item is built and
        then runs its automated test suite, if any.  For this to do
        anything, the build item must have a test suite implemented
        with a test framework that is integrated with &abuild; or that
        is made available with a plugin.  &Abuild; is integrated with
        QTest and, for Java-based build items, also with JUnit.  The
        <command>check</command> target is not automatically run by
        the default target; it must be requested specifically.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>clean</term>
      <listitem>
       <para>
        This target removes any output directories that &abuild;
        thinks it created.  (Output directories are discussed in <xref
        linkend="ref.output-directories"/>.)  Well-behaved &abuild;
        rules, including all the rules that are a standard part of
        &abuild;, won't create any files or directories outside of
        these locations.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>doc</term>
      <listitem>
       <para>
        This target is provided for building documentation that is
        extracted from source code.  The <command>doc</command> target
        is not automatically run by the default target; it must be
        requested explicitly.  It depends on the
        <command>all</command> target.  There is no internal support
        for document generation, so this capability must be provided
        by a plugin.  For <application>ant</application> builds,
        plugins should define a <command>doc</command> hook.  For
        <application>make</application> builds, they should make the
        document generation a dependency of the <command>doc</command>
        target.  Contributed plugins to support javadoc and doxygen
        are available in <filename>abuild-contrib</filename>, which is
        released separately from &abuild;.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>interface-help</term>
      <listitem>
       <para>
        This target prints help information for authors of the
        <filename>Abuild.interface</filename> file for the current
        build item.  What is printed is based on which backend is
        in use and, for <application>make</application>-based build
        items, the value of the <varname>RULES</varname> variable
        in <filename>Abuild.mk</filename>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>no-op</term>
      <listitem>
       <para>
        This target does nothing other than printing the name and
        platform of each build item in the build set, but using it
        still causes &abuild; to perform all the same validations it
        would perform if it were going to build something.  The
        <command>no-op</command> target can be used to get a complete
        list of all the items and platforms that would be built if
        building a given build set and will also verify that there are
        no errors in any <filename>Abuild.conf</filename> files.  Note
        that <filename>Abuild.interface</filename> files are not read
        when invoking the <command>no-op</command> target.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>rules-help</term>
      <listitem>
       <para>
        For <application>make</application>-based build items, this
        target prints help information for any rules defined in the
        <varname>RULES</varname> variable in
        <filename>Abuild.mk</filename>.  For property-driven
        <application>ant</application>-based build items, it prints
        information about properties that can be set in
        <filename>Abuild-ant.properties</filename>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>test</term>
      <listitem>
       <para>
        This target is a synonym for <command>check</command>.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
   <sect1 id="ref.targets.java">
    <title>Java-specific Targets</title>
    <para>
     Java-based build items that use the property-driven build method
     (<filename>Abuild-ant.properties</filename>) define several
     additional targets, listed below.
    </para>
    <variablelist>
     <varlistentry>
      <term>deploy</term>
      <listitem>
       <para>
        This target will deploy any items that can be deployed.  The
        default implementation doesn't do anything, so
        <command>deploy</command> hooks have to be written in order to
        add functionality.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>hooks-help</term>
      <listitem>
       <para>
        This target shows help information on how to add hooks from
        build items or in a local build file.  It also describes
        what hooks are run and when.  For information on hooks, please
        see <xref linkend="ref.java-hooks-and-generators"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>properties-help</term>
      <listitem>
       <para>
        This is a synonym for <command>rules-help</command>.  It
        describes the properties that you can set in
        <filename>Abuild-ant.properties</filename>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>wrapper</term>
      <listitem>
       <para>
        This target will generate an executable wrapper script around
        a JAR file if certain properties are defined.  The resulting
        script or batch file will invoke the Java runtime environment
        on the JAR file with the specified main class and with the
        proper classpath.  This target is run automatically by the
        <command>all</command> target.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     There are other targets that you can invoke, but they are all
     direct or indirect dependencies of the default
     <command>all</command> target.  For a complete list of supported
     targets, run <command>abuild --ant -p</command> from any Java
     build item.
    </para>
   </sect1>
  </chapter>
 </part>
 <part id="ref.part3" label="III">
  <title>Advanced Functionality</title>
  <partintro id="ref.part3.intro">
   <para>
    In this part of the manual, we cover the remaining information
    about &abuild;'s features in detail.  This part contains complete
    reference guides to &abuild;'s configuration files, discussions of
    more advanced topics, and numerous examples to illustrate how to
    solve specific build problems with &abuild;.  By the end of this
    part, you should be able to use &abuild; for a wide range of build
    problems.
   </para>
  </partintro>
  <chapter id="ref.abuild.conf">
   <title>The <filename>Abuild.conf</filename> File</title>
   <indexterm>
    <primary>Abuild.conf</primary>
   </indexterm>
   <para>
    The <filename>Abuild.conf</filename> file is the fundamental
    configuration file that describes each build item and the
    relationships between build items.  It contains information about
    dependencies, file system locations, and platform support.  It
    explicitly does not contain any information about how to build a
    particular build item or what targets are built.
   </para>
   <sect1 id="ref.abuild.conf-syntax">
    <title><filename>Abuild.conf</filename> Syntax</title>
    <para>
     Every build item must contain <filename>Abuild.conf</filename>.
     The <filename>Abuild.conf</filename> file is a simple text file
     consisting of colon-separated key/value pairs.  Blank lines and
     lines that start with <literal>#</literal> are ignored.  Long
     lines may be continued to the next line by ending them with a
     backslash character (<literal>\</literal>).  Certain keys are
     permitted for some kinds of build items and not for others.  For a
     discussion of different types of build items, please see <xref
     linkend="ref.build-item-types"/>.
    </para>
    <para>
     The <function>Abuild.conf</function> is optional in an external or
     backing area root if <function>Abuild.backing</function> is present.
     For details about configuration backing areas, see
     <xref linkend="ref.backing-areas"/>.
    </para>
    <para>
     The following keys are supported in
     <filename>Abuild.conf</filename>:
     <variablelist>
      <varlistentry>
       <term><property>this</property></term>
       <listitem>
        <para>
         This key is used to set the name of the build item.  Build
         item names consist of period-delimited segments.  Each
         segment consists of one or more alphanumeric characters,
         dashes, or underscores.  Some
         <filename>Abuild.conf</filename> files exist just to connect
         parent directories with child directories in the file system,
         as shown in examples below.  In those cases, the
         <property>this</property> key may be omitted.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>description</property></term>
       <listitem>
        <para>
         This optional key can be used to add an information
         description to the build item.  Description information is
         intended to be human readable.  For adding information that
         you may wish to categorize items for build purposes, use
         traits instead (see <xref linkend="ref.traits"/>).  If
         present, it will be included in the output to <command>abuild
         --dump-data</command>.  Providing a description here rather
         than just by using a comment in the
         <filename>Abuild.conf</filename> file can be useful to other
         programs that provide additional visualization of build
         items.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>parent-dir</property></term>
       <listitem>
        <para>
         This key is used to specify this item's parent in the file
         system.  It must be a relative path.  All build items except
         for root build items have a <property>parent-dir</property>
         key.  The <filename>Abuild.conf</filename> in a build item's
         parent directory must list the child directory in its
         <property>child-dirs</property> key.  For a complete
         description of how &abuild; reads
         <filename>Abuild.conf</filename> files, see <xref
         linkend="ref.traversal-details"/>.  The most common value for
         <property>parent-dir</property> is
         &ldquo;<filename>..</filename>&rdquo;.  Although &abuild;
         allows <property>parent-dir</property> to point other than to
         a parent or ancestor directory in the file system, this usage
         is not recommended and will likely lead to confusion.
         <footnote>
          <para>
           The main reason that &abuild; allows you to do this it all
           is that it can be handy as a short-term measure during
           reorganization of a build tree or to work around disk space
           issues.
          </para>
         </footnote>
         In particular, the <command>desc</command> build set uses
         actual file system paths, not
         <property>parent-dir</property>/<property>child-dirs</property>
         relationships.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>child-dirs</property></term>
       <listitem>
        <para>
         This key is used to specify all subdirectories of this item
         that contain additional <filename>Abuild.conf</filename>
         files.  The value is a whitespace-separated list of relative
         paths.  Every child directory's
         <filename>Abuild.conf</filename> must have a
         <property>parent-dir</property> key that points back to this
         directory.  Generally, the <property>child-dirs</property>
         key contains a list of single-element paths
         (<emphasis>i.e.</emphasis> paths with no directory names in
         them), but &abuild; does allow lower-level directories to be
         specified (corresponding with more
         &ldquo;<filename>..</filename>&rdquo;'s in the lower-level
         items' <property>parent-dir</property> keys), though, for
         clarity, this practice is not recommended.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>platform-types</property></term>
       <listitem>
        <para>
         This key is used to specify which platform types a given
         build item is expected to work on.  It includes a
         whitespace-separated list of platform types.  For details
         about platform types, see <xref linkend="ref.platforms"/>.
         If a build item has a build file or an interface file, the
         <property>platform-types</property> key is mandatory.
         Otherwise, it must not be present.  Note that a build item
         may have multiple platform types, but all platform types for
         a given build item must belong to the same target type.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>deps</property></term>
       <listitem>
        <para>
         This key's value is a whitespace-separated list of the names
         of build items on which this build item depends.  This is the
         sole mechanism within &abuild; to specify inter-build-item
         dependencies.  Any dependency in this list may be optionally
         followed by one or more
         <option>-flag=<replaceable>interface-flag</replaceable></option>
         arguments.  This causes the
         <replaceable>interface-flag</replaceable> interface flag to
         be set when this build item reads the interface of the
         dependent build item (see <xref
         linkend="ref.interface-flags"/>).  It is also possible to
         specify a
         <option>-platform=<replaceable>selector</replaceable></option>
         option to a dependency to specify which of the dependent
         item's platforms applies to this dependency (see <xref
         linkend="ref.cross-platform-dependencies"/>).
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>visible-to</property></term>
       <listitem>
        <para>
         This optional key's value is an indicator of the scope at
         which this build item is visible.  It is used to allow other
         build items to access this build item directly when they
         would ordinarily be prevented from doing so by normal scoping
         rules.  For information about build item name scopes and
         build item visibility, see <xref
         linkend="ref.build-item-name-scoping"/>.  For a discussion of
         the <property>visible-to</property> key in particular, see
         <xref linkend="ref.build-item-visibility"/>
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>external-dirs</property></term>
       <listitem>
        <para>
         This key contains a list of whitespace-separated paths to the
         root directories of external build trees.  It may appear in
         the <filename>Abuild.conf</filename> of a root build item
         only.  For a discussion of using externals, please see <xref
         linkend="ref.externals"/>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>supported-flags</property></term>
       <listitem>
        <para>
         This key contains a list of whitespace-separated flags that
         are supported by this build item.  When a flag is listed
         here, it becomes available to this item's
         <filename>Abuild.interface</filename> file for flag-specific
         variable assignments.  Other items can specify that this flag
         should be turned on when they depend on this item by using
         the
         <option>-flag=<replaceable>interface-flag</replaceable></option>
         option in their <property>deps</property> key.  For more
         information, see <xref linkend="ref.interface-flags"/>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>supported-traits</property></term>
       <listitem>
        <para>
         This key contains a list of whitespace-separated traits that
         are supported by build items in the build tree.  This key is
         valid only for root build items.  For more information about
         traits, see <xref linkend="ref.traits"/>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>traits</property></term>
       <listitem>
        <para>
         This key contains a list of whitespace-separated traits that
         apply to this build item.  A trait may be referent to one or
         more additional build items.  To name a referent build item,
         follow the trait with the
         <option>-item=<replaceable>build-item</replaceable></option>
         option.  For more information about traits, see <xref
         linkend="ref.traits"/>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><property>deleted</property></term>
       <listitem>
        <para>
         This key is allowed only in a root build item.  It contains a
         list of the names of build items that should be removed from
         this build tree's namespace because they have been deleted.
         The build item must not be present in the local build tree
         but must be present in the build item's direct backing area
         chain (i.e., traversal of backing areas is permitted, but not
         externals).  &Abuild; would ordinarily inherit build items
         that are not defined in the local tree but exist in a backing
         area.  Listing an item in the deleted key prevents this from
         happening.  Since all items listed here must be found in a
         backing area, this key would never appear in a build tree
         with no backing area.  For more information, see <xref
         linkend="ref.example.deleted-item"/>.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     Note that the <property>parent-dir</property>,
     <property>child-dirs</property>, and
     <property>external-dirs</property> keys are the only keys that deal
     with paths rather than names.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.abuild-interface-system">
   <title>The &Abuild; Interface System</title>
   <para>
    The &abuild; interface system is the mechanism through which
    &abuild; provides encapsulation.  Its purpose is to allow build
    items to provide information about the products they make
    available to other build items.  Build items provide their
    interfaces in the <filename>Abuild.interface</filename> file.
    This chapter describes the interface system and provides details
    about the syntax and semantics of
    <filename>Abuild.interface</filename> and other &abuild; interface
    files.
   </para>
   <sect1 id="ref.abuild-interface-functionality-overview">
    <title>&Abuild; Interface Functionality Overview</title>
    <para>
     This section contains a prose description of the interface
     system's functionality and presents the basic syntax of
     <filename>Abuild.Interface</filename> without providing all of
     the details.  This material provides the basis for understanding
     how the interface functionality works.  In the next section, we
     go over the details.
    </para>
    <para>
     The <filename>Abuild.interface</filename> file has a fairly
     simple syntax that supports variable declarations, variable
     assignments, and conditionals.  Interface files are rigorously
     validated.  Any errors detected in an interface file are
     considered build failures which, as such, will prevent &abuild;
     from attempting to build the item with the incorrect interface
     and any items that depend on it.  Most
     <filename>Abuild.interface</filename> files will just set
     existing variables to provide specific information about that
     item's include and library information, classpath information, or
     whatever other standard information may be needed depending upon
     the type of item it is.  For casual users, a full understanding
     of this material is not essential, but for anyone trying to debug
     interface issues or create support within &abuild; for more
     complex cases, it will be important to understand how &abuild;
     reads <filename>Abuild.interface</filename> files.
    </para>
    <para>
     The basic purpose of <filename>Abuild.interface</filename> is to
     set variables that are ultimately used by a build item to access
     its dependencies.  The basic model is that an item effectively
     reads the <filename>Abuild.interface</filename> files of all its
     dependencies in dependency order.  (This is not exactly what
     happens.  For the full story, see <xref
     linkend="ref.interface-implementation"/>.)  As each file is read,
     it adds information to the lists of include paths, libraries,
     library directories, compiler flags, classpath, etc.  All
     variables referenced by <filename>Abuild.interface</filename> are
     global variables, even if they are declared inside the body of a
     conditional, much as is the case with shell scripts or makefiles.
     Although this is not literally what happens, the best way to
     think about how &abuild; reads interface files is to imagine
     that, for each build item, all of the interface files for its
     dependencies along with its own interface file are concatenated
     in dependency order and that the results of that concatenation
     are processed from top to bottom, skipping over any blocks inside
     of false conditional statements.
    </para>
    <para>
     Once &abuild; parses the <filename>Abuild.interface</filename>
     files of all of a build item's dependencies and that of the build
     item itself, the names and values of the resulting variables are
     passed to the backends by writing them to the &abuild;
     <firstterm>dynamic output file</firstterm>, which is called
     <filename>.ab-dynamic.mk</filename> for
     <application>make</application>-based builds and
     <filename>.ab-dynamic-ant.properties</filename> for
     <application>ant</application>-based builds.  The dynamic output
     file is created in the output directory.  Although users running
     &abuild; don't even have to know this file exists, peeking at it
     is a useful way to see the results of parsing all the
     <filename>Abuild.interface</filename> files in a build item's
     dependency chain.
    </para>
    <para>
     The <filename>Abuild.interface</filename> file contains the
     following items:
     <itemizedlist>
      <listitem><para>Comments</para></listitem>
      <listitem><para>Variable declarations</para></listitem>
      <listitem><para>Variable assignments</para></listitem>
      <listitem><para>After-build file specifications</para></listitem>
      <listitem><para>Target type restrictions</para></listitem>
      <listitem><para>Conditionals</para></listitem>
     </itemizedlist>
     Similar to make or shell script syntax, each statement is
     terminated by the end of the line.  Whitespace characters (spaces
     or tabs) are used to separate words.  A backslash
     (<literal>\</literal>) as the last character of the line may be
     used to continue long statements onto the next line of the file,
     in which case the newline is treated as a word delimiter like any
     other whitespace.
     <footnote>
      <para>
       In this way, &abuild;'s handles line continuation like
       <application>GNU Make</application> and the C shell.  This is
       different from how the Bourne shell and the C programming
       language treat line continuation characters: in those
       environments, a quoted newline disappears entirely.  The only
       time this matters is if there are no spaces at the beginning of
       a line following a line continuation character.  For &abuild;,
       make, and the C shell it doesn't matter whether or not space is
       present at the beginning of a line following a line
       continuation character, but for C and the Bourne shell, it
       does.
      </para>
     </footnote>
     Any line that starts with a <literal>#</literal> character
     optionally preceded by whitespace is ignored entirely.  Comment
     lines have no effect on line continuation.  In other words, if
     line one ends with a continuation character and line two is a
     comment, line one is continued on line three.  This makes it
     possible to embed comments in multiline lists of values.  In this
     example, the value of <varname>ODDS</varname> would be
     <literal>one three</literal>:

     <programlisting>ODDS = \
  one \
# odd numbers only, please
  # two \
  three
</programlisting>
    </para>
    <para>
     Characters that have special meanings (space, comma,
     equal, etc.) may be quoted by preceding them by a backslash.  For
     consistency, a backslash followed by any character is treated as
     that character.  This way, the semantics of backslash quoting
     won't change if additional special characters are added in the
     future.
    </para>
    <para>
     All variables must be declared, though most
     <filename>Abuild.interface</filename> files will be assigning to
     variables that have already been declared in other interface
     files.  There are several types of variables.  There are no
     variable scoping rules: all variables are global, even if
     declared inside a conditional block.  Variable names may contain
     alphanumeric characters, dash, underscore, and period.  By
     convention, make-based rules use all uppercase letters in
     variable names.  This convention also has the advantage of
     avoiding potential conflict with reserved statements.  Java-based
     rules typically use lower-case period-separated properties.
     Ultimately &abuild; interface variables become
     <application>make</application> variables or
     <application>ant</application> properties, which is the basis for
     these conventions.  Note, however, that variables of both naming
     styles may be used by either backend, and some of &abuild;'s
     predefined interface variables that are available to both
     <application>make</application> and
     <application>ant</application> are of the all upper-case variety.
    </para>
    <para>
     Once declared, a variable may be assigned to or referenced.  A
     variable is referenced by enclosing its name with parentheses and
     preceding it by a dollar sign (as in
     <varname>$(VARIABLE)</varname>), much like with standard make
     syntax, except that there is no special case for single-character
     variable names.  Other than using the backslash character to
     quote single characters, there is no quoting syntax: the single
     and double quote characters are treated as ordinary characters
     with no special meanings.
    </para>
    <para>
     Environment variables may be referenced using the syntax
     <varname>$(ENV:VARIABLE)</varname>.  Unlike many other systems
     which treat undefined environment variables as the empty string,
     &abuild; will trigger an error condition if the environment
     variable does not exist.  This can be useful for having &abuild;
     interface files initialize interface variables from the
     environment.  Use this feature sparingly as it is possible to
     make a build become overly dependent on the environment in this
     way.  (Even without this feature, there are other ways to fall
     into this trap that are even worse.)  Note that environment
     variables are not &abuild; variables.  They are expanded as
     strings and can be used in the interface file wherever ordinary
     strings can be used.
    </para>
    <para>
     Variables may contain single scalar values or they may contain
     lists of values of one of the three supported types:
     <function>boolean</function>, <function>string</function>, or
     <function>filename</function>.
    </para>
    <para>
     Boolean variables are simple true/false values.  The values
     <constant>1</constant> and <constant>true</constant> are
     interpreted interchangeably as true, and the values
     <constant>0</constant> and <constant>false</constant> are
     interpreted interchangeably as false.  Regardless of whether the
     word or numeric value is used to assign to boolean variables, the
     normalized values of <constant>0</constant> and
     <constant>1</constant> are passed to the backend build system.
     String variables just contain arbitrary text.  It is possible to
     embed spaces in string variables by quoting them with a
     backslash, but keep in mind that not all backends handle spaces
     in single-word variable values cleanly.  For example, dealing
     with embedded spaces in variable names in GNU Make is impractical
     since it uses space as a word delimiter and offers no specific
     quoting mechanisms.  The values of filename variables are
     interpreted to be path names.  Path names may be specified with
     either forward slashes or backslashes on any platform.  Relative
     paths (those that do not start with a path separator character
     or, on Windows, also a drive letter) are interpreted as
     <emphasis>relative to the file in which they are
     assigned</emphasis>, not the file in which they are referenced as
     is the case with <application>make</application>.  This means
     that build items can export information about their local files
     using relative paths without having to use any special variables
     that point to their own local directories.  Although this is
     different from how make works, it is the only sensible semantic
     for files that are referenced from multiple locations.
    </para>
    <para>
     List variables may contain multiple space-separated words.
     Assignments to list variables may span multiple lines by using a
     trailing backslash to indicate continuation to the next line.
     Each element of a list must be the same type.  Lists can be made
     of any of the supported scalar types.  (Lists of boolean values
     are supported, though they are essentially useless.)  List
     variables must be declared as either <function>append</function> or
     <function>prepend</function>, depending upon whether successive
     assignments are appended or prepended to the value of the list.
     This is described in more depth when we discuss variable
     assignment below.
    </para>
    <para>
     Scalar variables may be assigned to in one of three ways: normal,
     override, and fallback.  A normal assignment to a scalar variable
     fails if the variable already has a value.  An override
     assignment initializes a previously uninitialized variable and
     replaces any previously assigned value.  A fallback assignment
     sets the value of the variable only if it has not previously been
     initialized.  Uninitialized variables are passed to the backend
     as empty strings.  It is legal to initialize a string variable to
     the empty string, and doing this is distinct from not
     initializing it.
    </para>
    <para>
     List variables work differently from anything you're likely to
     have encountered in other environments, but they offer
     functionality that is particularly useful when building software.
     List variables may be assigned to multiple times.  The value in
     each individual assignment may contain zero or more words.
     Depending on whether the variable was declared as
     <function>append</function> or <function>prepend</function>, the
     values are appended to or prepended to the list in the order in
     which they appear in the specific assignment.  An example is
     provided below.
    </para>
    <para>
     Scalar and list variables can both be reset using the
     <function>reset</function> statement.  This resets the variable back
     to an uninitialized state.
    </para>
    <para>
     Any variable assignment statement can be made conditional upon
     the presence of a given interface flag.  Interface flags are
     introduced in <xref linkend="ref.interface-flags"/>, and the
     details of how to use them in interface files are discussed later
     in this chapter.
    </para>
    <para>
     &Abuild; supports nested conditionals, each of which may contain
     an <function>if</function> clause, zero or more
     <function>elseif</function> clauses, and an optional
     <function>else</function> clause.  The &abuild; interface syntax
     supports no relational operators: all conditionals are expressed
     in terms of function calls, the details of which are provided
     below.
    </para>
    <para>
     In addition to supporting variables and conditionals, it is
     possible to specify that certain variables are relevant only to
     build items of a specific target type.  A target type restriction
     applies until the next <function>target-type</function> directive
     or until the end of the current file and all the files it loads
     as <function>after-build</function> files.  By default,
     declarations in an <filename>Abuild.interface</filename> file
     apply to all target types.  The vast majority of interface files
     will not have to include any target type restrictions.
    </para>
    <para>
     It is possible for a build item to contain interface information
     intended for items that depend on it but not intended for the
     item itself.  Typical uses cases would include when some of this
     information is a product of the build or when a build item needs
     to modify interface information provided by a dependency after it
     has finished using the information itself.  To support this, an
     <filename>Abuild.interface</filename> file may specify additional
     interface files that are not to be read until after the item is
     built.  The values in any such files are not available to the
     build item itself, but they are available to any items that
     depend on the build item that exports this interface.  Such files
     may be dynamically generated (such as with
     <application>autoconf</application>; see <xref
     linkend="ref.example.autoconf"/>), or they may be hand-generated
     files that are just intended not to apply to the build of the
     current build item (see <xref
     linkend="ref.example.opaque-wrapper"/>).
    </para>
   </sect1>
   <sect1 id="ref.abuild.interface-syntactic-details">
    <title>Abuild.interface Syntactic Details</title>
    <para>
     In this section, we provide the syntactic details for each of the
     capabilities described in the previous section.  There are some
     aspects of how <filename>Abuild.interface</filename> files are
     interpreted that are different from other systems you have likely
     encountered.  If you are already familiar with the basics of how
     these files work, this section can serve as a quick reference.
    </para>
    <note>
     <para>
      If you only read one thing, read about list assignment.
      Assignment to list variables is probably different for
      <filename>Abuild.interface</filename> files than for any other
      variable assignment system you're likely to have encountered.
      It is specifically designed to support building up lists
      gradually by interpreting multiple files in a specific order.
     </para>
    </note>
    <variablelist>
     <varlistentry>
      <term>comment</term>
      <listitem>
       <para>
        Any line beginning with a <literal>#</literal> optionally
        preceded by whitespace is treated as a comment.  Comments are
        completely ignored and, as such, have no effect on line
        continuation.  Note that the <literal>#</literal> does not
        have any special meaning when it appears in another context.
        There is no syntax for including comments within a line that
        contains other content.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>variable declaration</term>
      <listitem>
       <para>
        A scalar variable declaration takes the form

        <programlisting>declare <replaceable>variable</replaceable> <replaceable>type</replaceable>
</programlisting>
        where <replaceable>variable</replaceable> is the name of the
        variable and <replaceable>type</replaceable> is one of
        <type>boolean</type>, <type>string</type>, or
        <type>filename</type>.  Example scalar variable declarations:

        <programlisting>declare CODEGEN filename
declare HAS_CLASS boolean
</programlisting>
       </para>
       <para>
        A list variable declaration takes the form

        <programlisting>declare <replaceable>variable</replaceable> list <replaceable>type</replaceable> <replaceable>append-type</replaceable>
</programlisting>
        where <replaceable>variable</replaceable> is the name of the
        variable, <replaceable>type</replaceable> is one of
        <type>boolean</type>, <type>string</type>, or
        <type>filename</type>, and
        <replaceable>append-type</replaceable> is one of
        <type>append</type> or <type>prepend</type>.  Example list
        variable declarations:

        <programlisting>declare QFLAGS list string append
declare QPATHS list filename prepend
</programlisting>
       </para>
       <para>
        Scalar variables start off uninitialized.  List variables
        start off containing zero items.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>scalar variable assignment</term>
      <listitem>
       <para>
        Scalar variables may be assigned in one of three ways: normal,
        override, or default.  A normal assignment looks like this:

        <programlisting><replaceable>variable</replaceable> = <replaceable>value</replaceable>
</programlisting>
        where <replaceable>variable</replaceable> is the variable name
        and <replaceable>value</replaceable> is a single word (leading
        and trailing space ignored).  Extra whitespace is permitted
        around the <literal>=</literal> sign.
       </para>
       <para>
        Override assignments look like this:

        <programlisting>override <replaceable>variable</replaceable> = <replaceable>value</replaceable>
</programlisting>
       </para>
       <para>
        Fallback assignments look like this:

        <programlisting>fallback <replaceable>variable</replaceable> = <replaceable>value</replaceable>
</programlisting>
        Example scalar variable assignments:

        <programlisting>fallback CODEGEN = gen_code.pl
HAS_CLASS = 0
override HAS_CLASS = 1
</programlisting>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>list variable assignment</term>
      <listitem>
       <para>
        List variables are assigned using a simple
        <literal>=</literal> operator:

        <programlisting><replaceable>list-variable</replaceable> = <replaceable>value</replaceable>
</programlisting>
        where <replaceable>value</replaceable> consists of zero or
        more words, and the semantics of the assignment depend on how
        the list was declared.  For <type>append</type> lists, the
        assignment operator appends the words to the existing list in
        the order in which they appear.  For <type>prepend</type>
        lists, the assignment operator <emphasis>prepends</emphasis>
        the words to the existing value of list in the order in which
        they appear.  For example, if the variables
        <varname>LIBS</varname> is declared as a prepend list of
        strings, these two statements would result in
        <varname>LIBS</varname> containing the value <literal>lib3
        lib4 lib1 lib2</literal>:

        <programlisting>LIBS = lib1 lib2
LIBS = lib3 lib4
</programlisting>
        The distinction of whether a list is declared as
        <type>append</type> or <type>prepend</type> generally doesn't
        matter to the user, but there are cases in a build environment
        in which it is important to prepend to a list.  One notable
        example is the list of libraries that are linked into an
        application: if one library calls functions from another
        library, the depending library must come
        <emphasis>before</emphasis> the dependent library in the link
        command.  Since &abuild; reads the dependent library's
        interface file first, the depending library must
        <emphasis>prepend</emphasis> itself to the list of libraries.
        Note that multiple assignments to a single list variable would
        ordinarily not occur in the same
        <filename>Abuild.interface</filename> file, but would instead
        occur over successive files.  It is perfectly valid to assign
        multiple times in the same file, however.  One instance in
        which this would typically occur would be with private
        interfaces, as illustrated in <xref
        linkend="ref.example.private-interface"/>.  Another common
        case would be with conditional assignments.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>variable reset</term>
      <listitem>
       <para>
        List and scalar variables can both be reset.  After a variable
        is reset, its value becomes uninitialized just as if it had
        just been declared.  The syntax for resetting a variable is

        <programlisting>reset <replaceable>variable</replaceable>
</programlisting>
        It is also possible to reset all variables with

        <programlisting>reset-all
</programlisting>
        A reset of a specific variable, either by an explicit
        <function>reset</function> or a
        <function>reset-all</function>, can be blocked within the
        scope of a single <filename>Abuild.interface</filename> file
        or any files it loads with <function>after-build</function>.
        To block a variable from being reset, use

        <programlisting>no-reset <replaceable>variable</replaceable>
</programlisting>
        Any <function>no-reset</function> commands will apply to the
        next <function>reset</function> or
        <function>reset-all</function> that appears in the current
        file or files it explicitly loads.  (Although there would be
        no real reason to use <function>no-reset</function> before a
        specific <function>reset</function> of a specific variable,
        &abuild; does support this construct.)
       </para>
       <para>
        Variable reset operations are used fairly infrequently, but
        there are use cases that justify all of the various reset
        operations.  For examples of using them, please see <xref
        linkend="ref.cross-platform-dependencies"/> and <xref
        linkend="ref.opaque-wrapper"/>.
       </para>
       <para>
        There are some subtleties about the effect of a variable reset
        when interface files are loaded.  For details, see <xref
        linkend="ref.interface-implementation"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>flag-based variable assignment</term>
      <listitem>
       <para>
        An <filename>Abuild.interface</filename> file may prefix any
        variable assignment (<function>normal</function>,
        <function>override</function>, <function>fallback</function>,
        scalar, or list) with a <function>flag</function> statement.
        This indicates that that particular assignment will be ignored
        by build items that don't request the particular flag through
        the
        <option>-flag=<replaceable>interface-flag</replaceable></option>
        syntax in their <filename>Abuild.conf</filename> files.  A
        flag-based assignment looks like this:

        <programlisting>flag <replaceable>interface-flag</replaceable> <replaceable>assignment-statement</replaceable>
</programlisting>
       </para>
       <para>
        &Abuild; enforces that a build item's
        <filename>Abuild.interface</filename> and any
        <function>after-build</function> files that it reads may only
        use the <function>flag</function> statement for a flag
        declared in the build item's
        <property>supported-flags</property> key in its own
        <filename>Abuild.conf</filename>.  For an example of using
        flag-based assignment, see <xref
        linkend="ref.example.private-interface"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>after-build file specification</term>
      <listitem>
       <para>
        &Abuild; allows you to specify the name of an additional
        interface file with the same syntax as
        <filename>Abuild.interface</filename> that is loaded
        immediately after the current item has been built, before any
        items that depend on this item are built.  Because the file is
        loaded after the build has been completed, any directives in
        this file will be visible to items that depend on this item
        but not by this item itself.  To specify the name of such a
        file, use

        <programlisting>after-build <replaceable>filename</replaceable>
</programlisting>
        where <replaceable>filename</replaceable> is the path to the
        file to be loaded.  A relative path is interpreted as relative
        to the original <filename>Abuild.interface</filename> file.
        Note that files loaded by <function>after-build</function> may
        themselves not include <function>after-build</function>
        directives.  It is also not permitted to have
        <function>after-build</function> statements in interface files
        belonging to plugins or build items that have no build files.
        (Having them would be meaningless since such build items are
        not built.)
       </para>
       <para>
        Since interface statements in <function>after-build</function>
        files are visible to items that depend on this build item but
        not to the item itself, this mechanism is useful for changing
        interface variables for the item's reverse dependencies
        without changing what the build item itself sees.  The Java
        code generator example (<xref
        linkend="ref.example.java-code-generator"/>) does this.  It
        also makes this construct useful for automatically generated
        interface data.  For an example of that use, see <xref
        linkend="ref.example.autoconf"/>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>target type restriction</term>
      <listitem>
       <para>
        To specify the target type to which subsequent variable
        declarations belong, use

        <programlisting>target-type <replaceable>type</replaceable>
</programlisting>
        where <replaceable>type</replaceable> is the name of the
        target type.  For information about target types, see <xref
        linkend="ref.platforms"/>.  In addition to the built-in target
        types, the special type <type>all</type> may be used to
        indicate that variables should be made available to all target
        types.  In practice, there is little reason to ever restrict a
        variable to a particular target type, though many of the
        &abuild; predefined variables are restricted.  Restricting the
        target type of a variable only determines whether that
        variable is passed to the backend, so the only reason to
        restrict a variable to a specific target type would be to
        reduce the number of unneeded variables that were passed to
        the backend.  It has no impact on variable scope, visibility,
        or even availability for use in other
        <filename>Abuild.interface</filename> files.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>conditional</term>
      <listitem>
       <para>
        Conditionals in <filename>Abuild.interface</filename> take the
        following form:

        <programlisting>if (<replaceable>condition</replaceable>)
   ...<replaceable>valid code</replaceable>...
elseif (<replaceable>condition</replaceable>)
   ...<replaceable>valid code</replaceable>...
elseif (<replaceable>condition</replaceable>)
   ...<replaceable>valid code</replaceable>...
else
   ...<replaceable>valid code</replaceable>...
endif
</programlisting>
        An <function>if</function> block may contain zero or more
        <function>elseif</function> clauses and an optional
        <function>else</function> clause.  Any valid
        <filename>Abuild.interface</filename> code, including nested
        conditionals, is permitted inside a conditional block.  Recall
        that all variables have global scope including variables
        declared inside of conditional blocks.  Code inside of
        conditions that are not satisfied is ignored but must be
        syntactically valid.
       </para>
       <para>
        The <replaceable>condition</replaceable>s specified above may
        be of one of the following forms:

        <programlisting>$(<replaceable>variable</replaceable>)
</programlisting>
        where <replaceable>variable</replaceable> is a boolean
        variable, or

        <programlisting><replaceable>function</replaceable>(<replaceable>arg</replaceable>, <replaceable>arg</replaceable>, ...)
</programlisting>
        where <replaceable>function</replaceable> is a valid
        <filename>Abuild.interface</filename> conditional function and
        each <replaceable>arg</replaceable> consists of one or more
        words.  Only variables declared as Boolean and specific
        conditional functions, described in the next section, are
        permitted in conditionals.  There are no relational operators,
        and variables of other types whose values happen to be valid
        boolean values are not allowed in conditionals.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
   <sect1 id="ref.abuild.interface-conditional-functions">
    <title>Abuild Interface Conditional Functions</title>
    <para>
     A single <filename>Abuild.interface</filename> conditional must
     appear in parentheses after an <function>if</function> or
     <function>elseif</function> statement.  The conditional may be a
     simple boolean variable reference, or it may be a call to any of
     the provided conditional functions, each of which returns a
     boolean value.  Conditional functions may be nested as needed.
     Any boolean argument described below may a be function call or a
     simple boolean variable reference, thus allowing function calls
     to nest.  The following functions are defined:
    </para>
    <variablelist>
     <varlistentry>
      <term><function>and</function>(<replaceable>bool1</replaceable>, <replaceable>bool2</replaceable>)</term>
      <listitem>
       <para>
        Returns true if both expressions are true and false otherwise.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><function>or</function>(<replaceable>bool1</replaceable>, <replaceable>bool2</replaceable>)</term>
      <listitem>
       <para>
        Returns true if either value is true.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><function>not</function>(<replaceable>bool</replaceable>)</term>
      <listitem>
       <para>
        Returns true if the given value is false, or false otherwise.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><function>equals</function>(<replaceable>scalar1</replaceable>, <replaceable>scalar2</replaceable>)</term>
      <listitem>
       <para>
        Returns true if the two scalars contain the same contents.
        The two values must be the same type.  The
        <function>equals</function> function may not be used to
        compare lists.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><function>matches</function>(<replaceable>string</replaceable>, <replaceable>regex</replaceable>)</term>
      <listitem>
       <para>
        Returns true if the string value matches the given
        Perl-compatible regular expression.  Regular expression
        matches may be applied only to strings.  Note that
        <function>matches</function> returns true if the regular
        expression matches the <emphasis>whole</emphasis> string.  If
        you need to do a partial match, you must add
        <literal>.*</literal> at the beginning and/or end of the
        expression.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><function>contains</function>(<replaceable>list</replaceable>, <replaceable>scalar</replaceable>)</term>
      <listitem>
       <para>
        Returns true if the given list contains the given scalar
        value.  The scalar must have the same type as the list.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><function>containsmatch</function>(<replaceable>string-list</replaceable>, <replaceable>regex</replaceable>)</term>
      <listitem>
       <para>
        Returns true if the given list contains any elements that
        match the given Perl-compatible regular expression.  The list
        must be a list of strings.  As with
        <function>matches</function>, the regular expression must match
        the entirety of some member of the list.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
   <sect1 id="ref.abuild.interface-and-target-types">
    <title><filename>Abuild.interface</filename> and Target Types</title>
    <para>
     &Abuild; maintains a single variable symbol table.  All variables
     are global, and all variables are visible to interface code of
     any item regardless of target type.  Variables may be declared to
     apply to a specific target type.  By default, they apply to all
     target types.  When interface variables are passed to the
     backend, only variables declared in either the special target
     type <type>all</type> or in the item's own target type are
     made available.
    </para>
    <para>
     In general, end users will not have to be concerned about which
     target types a variable applies to.  A build item could, in
     principle, assign to both <varname>INCLUDES</varname> and
     <varname>abuild.classpath</varname> without having to care that
     only C++ items will see <varname>INCLUDES</varname> and only Java
     items will see <varname>abuild.classpath</varname>.
    </para>
   </sect1>
   <sect1 id="ref.predefined-abuild.interface-variables">
    <title>Predefined <filename>Abuild.interface</filename> Variables</title>
    <para>
     Before &abuild; reads any <filename>Abuild.interface</filename>
     files, it provides certain predefined variables.  We divide them
     into categories based on target type.
    </para>
    <para>
     The variables mentioned here, along with any additional variables
     that are declared in <filename>Abuild.interface</filename> files,
     are made available to the backends in the form of identically
     named make variables or ant properties.
    </para>
    <sect2 id="ref.interface.all">
     <title>Interface Variables Available to All Items</title>
     <para>
      The following interface variables are available to build items
      of all target types:
      <variablelist>
       <varlistentry>
        <term>ABUILD_STDOUT_IS_TTY</term>
        <listitem>
         <para>
          A Boolean variable indicate whether &abuild;'s standard output
          is a terminal.  It can be useful to know this so that this
          information can be passed to other programs invoked by
          backends, particularly those (like ant) which redirect output
          through a pipe that ultimately goes to &abuild;'s standard
          output.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>ABUILD_THIS</term>
        <listitem>
         <para>
          The name of the current build item
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>ABUILD_TARGET_TYPE</term>
        <listitem>
         <para>
          The target type of the current build item
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>ABUILD_PLATFORM_TYPE</term>
        <listitem>
         <para>
          The platform type of the platform on behalf of which this
          interface is being read
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>ABUILD_PLATFORM</term>
        <listitem>
         <para>
          The name of the platform on behalf of which this interface is
          being read
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>ABUILD_OUTPUT_DIR</term>
        <listitem>
         <para>
          The output directory in which this item's products are
          generated for this platform.  This is the most often
          referenced &abuild; interface variable as it is normal
          practice to expand this variable when setting the names of
          library directories, classpaths, or anything else that
          references generated targets.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>ABUILD_PLATFORM</term>
        <listitem>
         <para>
          The current platform.  This variable is not used very often.
          When referring to the output directory, always use
          <varname>$(ABUILD_OUTPUT_DIR)</varname> instead of writing
          something in terms of this variable.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </sect2>
    <sect2 id="ref.interface.object-code">
     <title>Interface Variables for Object-Code Items</title>
     <para>
      The following interface variables are available for object-code
      build items:
      <variablelist>
       <varlistentry>
        <term>ABUILD_PLATFORM_OS</term>
        <listitem>
         <para>
          For <type>object-code</type> items, this variable contains the
          <varname>OS</varname> field of the platform (see <xref
          linkend="ref.platforms.object-code"/>).
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>ABUILD_PLATFORM_CPU</term>
        <listitem>
         <para>
          For <type>object-code</type> items, this variable contains the
          <varname>CPU</varname> field of the platform (see <xref
          linkend="ref.platforms.object-code"/>).
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>ABUILD_PLATFORM_TOOLSET</term>
        <listitem>
         <para>
          For <type>object-code</type> items, this variable contains the
          <varname>TOOLSET</varname> field of the platform (see <xref
          linkend="ref.platforms.object-code"/>).
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>ABUILD_PLATFORM_COMPILER</term>
        <listitem>
         <para>
          For <type>object-code</type> items, this variable contains the
          <varname>COMPILER</varname> field of the platform (see <xref
          linkend="ref.platforms.object-code"/>).
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>ABUILD_PLATFORM_OPTION</term>
        <listitem>
         <para>
          For <type>object-code</type> items, this variable contains the
          <varname>OPTION</varname> field of the platform if present or
          the empty string otherwise (see <xref
          linkend="ref.platforms.object-code"/>).
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>INCLUDES</term>
        <listitem>
         <para>
          Include directories that users of this build item should add
          to their include paths
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>LIBS</term>
        <listitem>
         <para>
          The names of libraries (without any prefixes, suffixes, or
          command-line flags) that this build item provides
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>LIBDIRS</term>
        <listitem>
         <para>
          Directories that users linking with this build item's
          libraries should add to their library search paths.
          Typically, this is just set to
          <varname>$(ABUILD_OUTPUT_DIR)</varname> since this is where
          &abuild; creates library files.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>XCPPFLAGS</term>
        <listitem>
         <para>
          Additional preprocessor flags that must be added when using
          this item.  This flag should be used very sparingly as
          changing the value of this variable does not cause things to
          automatically recompile.  It is here primarily to support
          third-party libraries that only work if a certain flag is
          defined.  If you are using this to change the configuration of
          a build item, please consider using another method instead,
          such as defining symbols in a header file or using runtime
          configuration.  For an example of how to do this based on the
          value of a variable, see <xref
          linkend="ref.example.auto-from-variable"/>.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>XCFLAGS</term>
        <listitem>
         <para>
          Additional flags, beyond those in
          <varname>$(XCPPFLAGS)</varname> to be passed to the compiler
          when compiling C code.  This variable will be used very
          infrequently.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>XCXXFLAGS</term>
        <listitem>
         <para>
          Additional flags, beyond those in
          <varname>$(XCFLAGS)</varname> and
          <varname>$(XCPPFLAGS)</varname> to be passed to the compiler
          when compiling C++ code.  This variable will be used very
          infrequently.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>XLINKFLAGS</term>
        <listitem>
         <para>
          Additional flags to be added to the command-line when linking.
          The most common use for this would be to support third-party
          libraries or linker flags required to use third-party
          libraries.  For adding your own libraries, you should always
          use <varname>$(LIBDIRS)</varname> and
          <varname>$(LIBS)</varname> instead.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
     <warning>
      <para>
       Although &abuild; allows you to do so, it is strongly
       recommended that you avoid using these variables to configure
       your build items by passing preprocessor symbol definitions on
       the command line.  There are some times when passing
       preprocessor symbols on the command line is okay, such as when
       you're passing a parameter required by a third-party library or
       passing in some truly static value such as the name of the
       operating system, but passing dynamic configuration information
       this way is dangerous.  A significant reason for this is that
       <application>make</application>'s entire dependency system is
       based on file modification times.  If you change a preprocessor
       symbol in an <filename>Abuild.mk</filename> or
       <filename>Abuild.interface</filename> file, there is nothing
       that triggers anything to get rebuilt.  The result is that you
       can end up with items that build inconsistently with respect to
       that symbol.  Furthermore, &abuild; has no way to perform its
       integrity checks relative to the values of compiler flags in
       build and interface files.  If you need to have
       preprocessor-based static configuration of your code, a better
       way to handle it is by creating a header file and putting your
       <literal>#define</literal>s there.  That way, when you modify
       the header file, anything that depends upon that file will
       rebuild automatically.
      </para>
     </warning>
     <para>
      Note that the various <varname>FLAGS</varname> variables above
      can also be set in <filename>Abuild.mk</filename> files, as can
      additional variables to control flags on a per-file basis.
      Please run <command>abuild rules-help</command> in a C/C++ build
      item or see <xref linkend="ref.ccxx"/> for details.
     </para>
    </sect2>
    <sect2 id="ref.interface.java">
     <title>Interface Variables for Java Items</title>
     <para>
      The following variables are used by <type>java</type> build
      items:
      <variablelist>
       <varlistentry>
        <term>abuild.classpath</term>
        <listitem>
         <para>
          Generated JAR files to add to the classpath.  This is the
          variable that the most ordinary Java build items will assign
          to.  Its value will typically be
          <filename>$(ABUILD_DIR_OUTPUT)/dist/<replaceable>JarFile.jar</replaceable></filename>,
          where <replaceable>JarFile.jar</replaceable> is the name of
          the JAR file you placed in the
          <varname>abuild.jar-name</varname> property in your
          <filename>Abuild-ant.properties</filename> file.  Note that
          although Java allows both files (whose names end with
          <filename>.jar</filename> or <filename>.zip</filename>) and
          directories to be added to your classpath, adding
          directories to the <varname>abuild.classpath</varname>
          variable will not work properly in some cases with
          &abuild;'s ant rules and should therefore be avoided.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>abuild.classpath.external</term>
        <listitem>
         <para>
          Externally supplied JAR files to add to the classpath.  This
          variable is intended to be used for third-party JAR files.
          The difference between it and
          <varname>abuild.classpath</varname> is that JAR files listed
          here are not added to EAR and WAR files while those in
          <varname>abuild.classpath</varname> are.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </sect2>
   </sect1>
  </chapter>
  <chapter id="ref.abuild.mk">
   <title>The <filename>Abuild.mk</filename> File</title>
   <indexterm>
    <primary>Abuild.mk</primary>
   </indexterm>
   <para>
    An <filename>Abuild.mk</filename> file must appear in every
    directory in which something is to be built using the
    <application>GNU Make</application> backend.  In this chapter, we
    describe how to use it in general and provide details specific to
    the built-in rule sets provided by &abuild;.
   </para>
   <sect1 id="ref.abuild.mk.general">
    <title>General <filename>Abuild.mk</filename> Syntax</title>
    <para>
     The <filename>Abuild.mk</filename> file is read by GNU Make and is
     a GNU Make fragment.  It therefore has GNU Make syntax.  The
     <filename>Abuild.mk</filename> file is intended to contain only
     variable settings.  It contains no make rules or include
     directives.  &Abuild; automatically includes your
     <filename>Abuild.mk</filename> file at the appropriate time and in
     the appropriate context.
    </para>
    <para>
     The most important line in <filename>Abuild.mk</filename> is the
     setting of the <varname>RULES</varname> variable.  Its purpose is
     to tell &abuild; which rule set should be used to generate
     targets from sources.  Most of the remaining variables that are
     set are dependent upon which rules are being used.  It is always
     possible to run <command>abuild rules-help</command> to get
     detailed rule-specific help about what variables you are expected
     to define in your <filename>Abuild.mk</filename> for a specific
     set of rules.
    </para>
    <para>
     Sometimes, other build items may provide additional rules to
     support code generators and similar functionality.  To specify
     that you wish to use rules provided by another build item,
     include the name of the build item in the
     <varname>BUILD_ITEM_RULES</varname> variable.  This causes that
     build item's <filename>Rules.mk</filename> to be loaded.  You
     must also list that build item as a dependency in your
     <filename>Abuild.conf</filename> file, and you must be allowed to
     see the item subject to scoping rules (see <xref
     linkend="ref.build-item-name-scoping"/>).
    </para>
    <para>
     In rare instances, it may be necessary to create local rules for
     a specific build item.  Examples may include one-off,
     special-purpose code generators that are specific to a particular
     build item.  To use local rules, place a list of files that
     contain definitions of your rules in the
     <varname>LOCAL_RULES</varname> variable.  Files listed there are
     resolved relative to the <filename>Abuild.mk</filename>.  They
     may contain any valid <application>GNU Make</application> code.
     If you have written the same local rule in more than one or two
     places, you are probably doing something wrong and should be
     using build item-specific rules or plugins (<xref
     linkend="ref.plugins"/>) instead.
    </para>
    <para>
     Please note that local rules are run from the context of the
     output directory&mdash;you must keep this in mind when using
     relative paths from your local rules.  The make variable
     <varname>SRCDIR</varname> is always set to a relative path to the
     directory that contains the <filename>Abuild.mk</filename> file.
     Also, local rules should avoid creating files outside of the
     output directory since these files will not be removed by the
     <command>clean</command> target.
     <footnote>
      <para>
       Defining your own <command>clean</command> target can be
       useful, but remember that it is only run if you manually run
       &abuild; from inside the output directory, which most people
       would never do except when debugging &abuild;.  For details
       about running &abuild; from an output directory, see <xref
       linkend="ref.running-in-output-directory"/>.
      </para>
     </footnote>
    </para>
   </sect1>
   <sect1 id="ref.make-rule-specific-targets">
    <title>Make Rule-specific Targets</title>
    <para>
     The following sections describe special targets that are available
     in particular sets of rules for make-based builds.
    </para>
    <sect2 id="ref.ccxx">
     <title>C and C++: <filename>ccxx</filename> Rules</title>
     <indexterm>
      <primary>C code</primary>
     </indexterm>
     <indexterm>
      <primary>C++ code</primary>
     </indexterm>
     <indexterm>
      <primary>ccxx</primary>
     </indexterm>
     <para>
      Rules for compiling C and C++ code are provided by the
      <filename>ccxx</filename> rules.  These rules also include
      support for Flex, Bison, and Sun RPC.  It is possible for a
      single build item to build multiple targets including any
      mixture of static library, shared library, and executable
      targets.
     </para>
     <para>
      When building C and C++ code, you must define at least one of
      <varname>TARGETS_lib</varname> or
      <varname>TARGETS_bin</varname>.  These variables contain a list
      of library and executable targets respectively.  Targets should
      be specified without any operating system-specific prefixes or
      suffixes.  For example, the library target
      <filename>moo</filename> might generate
      <filename>libmoo.a</filename> on a UNIX system or
      <filename>moo.lib</filename> on a Windows system.  Likewise, the
      executable target <filename>quack</filename> might generate
      <filename>quack</filename> on a UNIX system and
      <filename>quack.exe</filename> on a Windows system.
     </para>
     <para>
      For each target <replaceable>target</replaceable> listed in
      <varname>TARGETS_lib</varname>, you must define the variable
      <varname>SRCS_lib_<replaceable>target</replaceable></varname>
      to contain a list of source files used to build the library.
      Likewise, for each binary target in
      <varname>TARGETS_bin</varname>, you must define
      <varname>SRCS_bin_<replaceable>target</replaceable></varname>.
      These variables can contain any mixture of C and C++ files.
      There are variables that can be used to control the creation of
      shared libraries.  For details, see <xref
      linkend="ref.building-shared-libraries"/>.  Files whose names
      end with <filename>.c</filename> are treated as C code.  Files
      whose names end with either <filename>.cc</filename> or
      <filename>.cpp</filename> are considered to be C++ code.
      Although you can have any mixture of binary and library targets
      in a build item, no single source file should be listed in more
      than one target.  Additionally, &Abuild; will automatically
      include any library targets at the beginning of the library list
      when linking any binary targets in the build item.  All targets
      are created directly in the abuild output directory.
     </para>
     <para>
      In addition to the standard targets, the
      <filename>ccxx</filename> rules provide a special target
      <command>ccxx_debug</command>.  This target prints the current
      include and library path as well as the list of libraries that
      we are linking against.  This can be a useful debugging tool for
      solving dependency declaration problems.
     </para>
     <para>
      It is also possible to add additional preprocessor, compiler, or
      linker flags globally or on a per-file basis and to specifically
      override debug, optimization, or warning flags globally or on a
      per-file basis.  This is done by setting the values of certain
      make variables, some of which may also be set in
      <filename>Abuild.interface</filename>.  Details about these
      variables may be obtained by running <command>abuild
      rules-help</command> from any C/C++ build item.  The following
      variables are available:
      <variablelist>
       <varlistentry>
        <term>XCPPFLAGS</term>
        <listitem>
         <para>
          additional flags passed to the preprocessor, C compiler, and
          C++ compiler (but not the linker)
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>XCFLAGS</term>
        <listitem>
         <para>
          additional flags passed to the C compiler, C++ compiler, and
          linker
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>XCXXFLAGS</term>
        <listitem>
         <para>
          additional flags passed to the C++ compiler and linker
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>XLINKFLAGS</term>
        <listitem>
         <para>
          additional flags passed to the linker
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>DFLAGS</term>
        <listitem>
         <para>
          debug flags passed to the processor, compilers, and linker
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>OFLAGS</term>
        <listitem>
         <para>
          optimization flags passed to the processor, compilers, and
          linker
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>WFLAGS</term>
        <listitem>
         <para>
          warning flags passed to the processor, compilers, and linker
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
     <para>
      Note that the <varname>XCPPFLAGS</varname>,
      <varname>XCFLAGS</varname>, <varname>XCXXFLAGS</varname>, and
      <varname>XLINKFLAGS</varname> variables may be set in
      <filename>Abuild.interface</filename> as well.  Therefore,
      although you assign to them normally with <literal>=</literal>
      in <filename>Abuild.interface</filename>, when assigning to them
      in <filename>Abuild.mk</filename>, it is generally better to
      append to these variables (using <literal>+=</literal>) rather
      than to set them outright.  Also, keep in mind that flags are
      often compiler-specific.  It may often make sense to set certain
      flags conditionally upon the value of the
      <varname>$(ABUILD_PLATFORM_COMPILER)</varname> variable or other
      platform field variables.  This can be done using regular
      <application>GNU Make</application> conditional syntax.
     </para>
     <para>
      Each of the above variables also has a file-specific version.
      For the <varname>X*FLAGS</varname> variables, the file-specific
      values are added to the general values.  For
      <varname>DFLAGS</varname>, <varname>OFLAGS</varname>, and
      <varname>WFLAGS</varname>, the file-specific values
      <emphasis>replace</emphasis> the general vales.  For example,
      setting <varname>XCPPFLAGS_File.cc</varname> will cause the
      value of that variable to be added to the preprocessor, C
      compiler and C++ compiler invocations for
      <filename>File.cc</filename>.  File-specific versions of
      <varname>XCPPFLAGS</varname>, <varname>XCFLAGS</varname>, and
      <varname>XCXXFLAGS</varname> are used only for compilation and,
      if appropriate, preprocessing of those specific files.  They are
      not used at link time.  The file-specific versions of
      <varname>DFLAGS</varname>, <varname>OFLAGS</varname>, and
      <varname>WFLAGS</varname> <emphasis>override</emphasis> the
      default values rather than supplementing them.  This makes it
      possible to completely change debugging flags, optimization
      flags, or warning flags for specific source files.  For example,
      if <filename>Hardware.cc</filename> absolutely cannot be
      compiled with any optimization, you could set
      <varname>OFLAGS_Hardware.cc</varname> to the empty string to
      suppress optimization on that file regardless of the value of
      OFLAGS.  Similarly, if <filename>autogen.c</filename> were an
      automatically generated file with lots of warnings, you could
      explicitly set <varname>WFLAGS_autogen.c</varname> to the empty
      string or to the flag that suppresses warnings.  This would
      suppress warnings for that file without affecting other files.
      If you wish to append to the default flags instead of replacing
      them, include the regular variable name in the value, as in
      <literal>WFLAGS_File.cc := $(WFLAGS) -Wextra</literal> or even
      <literal>WFLAGS_File.cc := $(filter-out
      -Wall,$(WFLAGS))</literal>.
     </para>
     <para>
      The <filename>ccxx</filename> rules provide a mechanism for you
      to generate preprocessed output for any C or C++ file.  For
      <filename><replaceable>file</replaceable>.c</filename>,
      <filename><replaceable>file</replaceable>.cc</filename>, or
      <filename><replaceable>file</replaceable>.cpp</filename>, run
      <command>abuild <replaceable>file</replaceable>.i</command>.
      This will generate
      <filename><replaceable>file</replaceable>.i</filename> in the
      output directory.  Its contents will be the output of running
      the preprocessor over the specified source file with all the
      same flags that would be used during actual compilation.
      <footnote>
       <para>
        The <filename>.i</filename> suffix is a traditional UNIX
        suffix for preprocessed C code and was created as an
        intermediate file by some compilers.  GCC recognizes this as
        preprocessed C code and also recognizes
        <filename>.ii</filename> as a suffix for preprocessed C++
        code.  When &abuild; is given a <filename>.i</filename> file
        as a suffix, its make rules use a pattern-based rule to run
        the preprocessor over the file, it never uses the resulting
        files as input to the compiler.  &Abuild; uses the original
        suffix of the file (<filename>.c</filename>,
        <filename>.cc</filename>, or <filename>.cpp</filename>) to
        determine whether the file is a C or C++ source file and does
        not therefore need to distinguish between
        <filename>.i</filename> and <filename>.ii</filename>.
       </para>
      </footnote>
     </para>
     <para>
      As is the case for any rule set, you can run <command>abuild
      rules-help</command> and <command>abuild
      interface-help</command> for complete information.
     </para>
     <para>
      When invoking &abuild; to build C or C++ executables or shared
      libraries, it is possible to set the make variable
      <varname>LINKWRAPPER</varname> to the name of a program that
      should wrap the link command.  This makes it possible to use
      programs such as <application>Purify</application> or
      <application>Quantify</application> that wrap the link step in
      this fashion.
     </para>
     <para>
      Ordinarily, &abuild; uses a C++ compiler or linker to link all
      executables and shared libraries.  If you are writing straight C
      code that doesn't make any call to C libraries and you want to
      link your program as a C program to avoid runtime dependencies
      on the C++ standard libraries, set the variable
      <varname>LINK_AS_C</varname> to some non-empty value in your
      <filename>Abuild.mk</filename>.  This applies to all shared
      libraries and executables in the build item.
     </para>
     <para>
      Most of the time, &abuild; manages all the dependencies of the
      source and object files automatically, but there are some rare
      instances in which you may have to create dependencies on your
      own, such as when an object file depends on an automatically
      generate header file that is generated in the same build item.
      (For an example of this, see <xref
      linkend="ref.example.auto-from-variable"/>.)  To make it
      possible to express such dependencies in a portable fashion, the
      <filename>ccxx</filename> rules provide the variables
      <varname>LOBJ</varname> and <varname>OBJ</varname> which are set
      to the object file suffixes for library object files and
      non-library object files respectively.  For example, if you have
      a source file called <filename>File.cc</filename> that is part
      of a library, the name of the object file will be
      <filename>File.<varname>$(LOBJ)</varname></filename>, and the
      file will be created inside the &abuild; output directory.  If
      <filename>File.cc</filename> were part of an executable instead,
      the object file would be
      <filename>File.<varname>$(OBJ)</varname></filename> instead.
      <footnote>
       <para>
        <varname>LOBJ</varname> and <varname>OBJ</varname> usually
        have the same value as each other, and the value is usually
        &ldquo;<literal>o</literal>&rdquo; on UNIX systems and
        &ldquo;<literal>obj</literal>&rdquo; on Windows systems.
        However, there are some circumstances under which either of
        these conditions may not be true, so it is best to use
        <varname>LOBJ</varname> or <varname>OBJ</varname> explicitly
        as required.
       </para>
      </footnote>
     </para>
     <para>
      There is a lot more to &abuild;'s C and C++ generation than is
      discussed here.  For a complete understanding of how it works,
      you are encouraged to read <filename>make/ccxx.mk</filename> in
      the &abuild; distribution (<xref linkend="ref.ccxx.mk"/>).
      There you will find copious comments and a lot of pretty hair
      <application>GNU Make</application> code.
     </para>
    </sect2>
    <sect2 id="ref.autoconf">
     <title>Autoconf: <filename>autoconf</filename> Rules</title>
     <indexterm>
      <primary>Autoconf</primary>
     </indexterm>
     <para>
      The <filename>autoconf</filename> rules provide rules for
      including autoconf fragments for a build item.
      <footnote>
       <para>
        <ulink
        url="http://www.gnu.org/software/autoconf">Autoconf</ulink> is
        a package used to help software developers create portable
        code.  This section assumes some familiarity with autoconf.
       </para>
      </footnote>
      Rather than having a monolithic autoconf-based component in a
      source tree, it is recommended that individual build items use
      autoconf for only those things they need.  This reduces the
      likelihood that something may fail to build due to lack of
      support for something it doesn't need (but that is checked for
      by a monolithic autoconf component).  The
      <filename>autoconf</filename> rules don't supply any special
      targets.  Please run <command>abuild rules-help</command> and
      <command>abuild interface-help</command> from a build item that
      uses <filename>autoconf</filename> rules for full information on
      using these rules.  (Creating an <filename>Abuild.mk</filename>
      with the one line <literal>RULES := autoconf</literal> and
      running <command>abuild rules-help</command> would suffice.)  An
      example of using autoconf follows in <xref
      linkend="ref.example.autoconf"/>.
     </para>
     <para>
      Autoconf properly honors your C/C++ toolchain and runs
      <filename>configure</filename> with the proper C/C++ compilation
      environment defined.  The usual approach for autoconf-based
      build items is that, if make variables need to be defined based
      on the results of running <filename>configure</filename>,
      <filename>configure.ac</filename> generates a file called
      <filename>autoconf.interface</filename> which is specified as an
      <function>after-build</function> file in
      <filename>Abuild.interface</filename>.  This means that the
      autoconf-based build item itself may not include code that is
      conditional upon the results of running autoconf.  It is okay,
      however, for build items that depend on an autoconf-based build
      item to include conditional code in their
      <filename>Abuild.interface</filename> and
      <filename>Abuild.mk</filename> files based on variables defined
      in its <filename>autoconf.interface</filename> should this be
      required.
     </para>
    </sect2>
    <sect2 id="ref.empty">
     <title>Do Nothing: <filename>empty</filename> Rules</title>
     <para>
      In some rare cases, it may be desirable to create an
      <filename>Abuild.mk</filename> file that does nothing.  One
      reason for doing this would be if you had a library that
      contained some code that should only exist on certain platforms.
      You might want to create an <filename>Abuild.mk</filename> file
      that was conditional upon some value of the
      <varname>ABUILD_PLATFORM_OS</varname> variable, for example.
      Since &abuild; requires that you set at least one of
      <varname>RULES</varname>, <varname>BUILD_ITEM_RULES</varname>,
      or <varname>LOCAL_RULES</varname>, you can set the
      <varname>RULES</varname> variable to the value
      <filename>empty</filename>.  &Abuild; will still attempt to
      build the item in this case, but the build will not do
      anything.  The <filename>empty</filename> rule set is available
      to both <type>object-code</type> and
      <type>platform-independent</type> build items.
     </para>
    </sect2>
   </sect1>
   <sect1 id="ref.example.autoconf">
    <title>Autoconf Example</title>
    <para>
     This example demonstrates how to use autoconf and also shows one
     use of the <function>after-build</function> statement within
     <filename>Abuild.interface</filename>.  In this example, we
     create a stub library that replaces functionality from an
     external library if that library is not available.  Our example
     is somewhat contrived, but it demonstrates the core functionality
     and patterns required to do this.  Our example resides in
     <filename>doc/example/general/user/derived/stub-library</filename>.
     <note>
      <para>
       In our example, we have used build item names containing the
       word <classname>stub</classname>.  This is because it is our
       stub library example.  In an actual implementation of this
       pattern, you would be much more likely to name the build items
       after the library that was potentially being stubbed and
       letting the fact that stubs are being substituted behind the
       scenes be a private detail not reflected in the names of the
       public build items.
      </para>
     </note>
    </para>
    <para>
     Notice that the <filename>Abuild.conf</filename> in the
     <filename>stub-library</filename> directory itself defines a
     pass-through build item that depends on the
     <classname>stub-library.implementation</classname> build item:
     <?example general/user/derived/stub-library/Abuild.conf?>
     The <classname>stub-library.implementation</classname> build
     item, in turn, depends on the
     <classname>stub-library.autoconf</classname> build item:
     <?example general/user/derived/stub-library/implementation/Abuild.conf?>
    </para>
    <para>
     The <classname>stub-library.autoconf</classname> build item's
     <filename>Abuild.interface</filename> file adds its output
     directory to the <varname>INCLUDES</varname> variable since this
     where the autoconf-generated header file will go.  Then it
     declares <filename>autoconf.interface</filename> in its output
     directory as an after-build file using the
     <function>after-build</function> statement:
     <?example general/user/derived/stub-library/autoconf/Abuild.interface?>
     This means that the <filename>autoconf.interface</filename> file
     won't be included when this build item is built but will be
     included when other build items that depend on this one are
     built.  This is important since the file won't actually exist yet
     when this build item is being built from a clean state.
    </para>
    <para>
     Next, look at the <filename>autoconf/Abuild.mk</filename> file:
     <?example general/user/derived/stub-library/autoconf/Abuild.mk?>
     Here, we set the variables that the <varname>autoconf</varname>
     rules require.  You can learn more about these variables by run
     <command>abuild interface-help</command> from an autoconf-based
     build item.  The <varname>AUTOFILES</varname> variable is set to
     the value <filename>autoconf.interface</filename>, which is the
     same as the file name used as the
     <function>after-build</function> file in the
     <filename>Abuild.interface</filename> file.  Additionally, we set
     the variable <varname>AUTOCONFIGH</varname> to the name of the
     header file that we will be generating.  This must match the
     output file we create in
     <filename>autoconf/configure.ac</filename>.
    </para>
    <para>
     Here is the <filename>autoconf/configure.ac</filename> file:
     <?example general/user/derived/stub-library/autoconf/configure.ac?>
     This contains normal autoconf macros.  The main things to note
     here are the <varname>AC_CONFIG_FILES</varname> macro which tells
     autoconf to generate the <filename>autoconf.interface</filename>
     file from <filename>autoconf.interface.in</filename> as well as
     the <varname>AC_CONFIG_HEADERS</varname> call which takes name of
     the file set as value of the <varname>AUTOCONFIGH</varname>
     variable in <filename>Abuild.mk</filename>.  The need to
     duplicate this information is unfortunate, and this may be
     improved in a future version of &abuild;.  Note that the autoconf
     macros don't have any knowledge of the &abuild; output directory.
     This works because we actually run autoconf inside the output
     directory with copies of the input files.
    </para>
    <para>
     Next, we examine the <filename>autoconf.interface.in</filename>
     file:
     <?example general/user/derived/stub-library/autoconf/autoconf.interface.in?>
     This is just like any other file generated by autoconf: it
     contains substitution tokens surrounded by @ signs.  Since it is
     an &abuild; interface file, it has &abuild; interface syntax.
    </para>
    <para>
     In our example, our <filename>configure.ac</filename> file checks
     to see whether we have two functions: <function>printf</function>
     and <function>create_world_peace</function>.  Unfortunately, only
     the first of these two functions is defined on most systems.  Our
     <filename>autoconf.interface.in</filename> file will set &abuild;
     boolean variables to the values determined by autoconf.  Then, if
     the <function>create_world_peace</function> function is
     available, we will add its library (which, in a real case, you
     would know or test for explicitly in
     <filename>configure.ac</filename>) to the library path.  If the
     library were not installed in the default library and include
     paths, it probably would also have add something to the
     <varname>LIBDIRS</varname> and <varname>INCLUDES</varname>
     variables.
    </para>
    <para>
     Now we turn our attention to the
     <filename>implementation</filename> directory.  This directory
     contains our stub implementation of
     <function>create_world_peace</function>.  It is a poor substitute
     for the real thing, but it will at least allow our software to
     compile.  The implementation protects the definition of the
     function with the <constant>HAVE_CREATE_WORLD_PEACE</constant>
     preprocessor symbol as generated by autoconf.  It also makes use
     of printf and checks to make sure it's there, just to demonstrate
     how you might do such a thing:
     <?example general/user/derived/stub-library/implementation/stub.cc?>
     The implementation provides a header file called
     <filename>world_peace.hh</filename>, which is presumably the same
     as the name of the header provided by the real implementation and
     which would have been made available by the
     <filename>stub-library.autoconf</filename> build item if the
     library were found:
     <?example general/user/derived/stub-library/implementation/world_peace.hh?>
     The <filename>Abuild.interface</filename> file in the
     <filename>implementation</filename> directory actually adds
     <filename>stub-library</filename> to the list of libraries only
     if the <varname>HAVE_CREATE_WORLD_PEACE</varname> variable, as
     provided by <filename>stub-library.autoconf</filename>'s
     <filename>autoconf.interface</filename> file, is false.  So if we
     had a real <function>create_world_peace</function> function, we
     wouldn't have to use our stub library:
     <?example general/user/derived/stub-library/implementation/Abuild.interface?>
    </para>
    <para>
     Note that users of the <filename>stub-library</filename> build
     item actually don't even have to know whether they are using the
     stub library or the real library&mdash;those details are all
     completely hidden inside of its private build items.  Declaring a
     dependency on <classname>stub-library</classname> will make sure
     that you have the appropriate interfaces available.  You can see
     an example of this by looking at <filename>main.cpp</filename> in
     <filename>user/derived/main/src</filename>:
     <?example general/user/derived/main/src/main.cpp?>
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.ant-build-files">
   <title>The Apache Ant Build Files</title>
   <para>
    There are two different Java build files:
    <filename>Abuild-ant.properties</filename> for property-driven
    builds, and <filename>Abuild-ant.xml</filename> for
    build.xml-driven builds.
    <note>
     <para>
      The goal is and always has been to have property-driven builds
      be the standard method for building Java code with &abuild;.  By
      the time of the first &abuild; release, &abuild;'s
      property-based <application>ant</application> framework was
      still not definitely able to handle everything that we might
      want for the Java Enterprise Environment and full Eclipse build
      integration.  Since <application>Apache Ant</application> is
      already relatively declarative in nature and is not really
      designed to be a system with which one would create a general
      framework, it is less suitable than <application>GNU
      Make</application> for being the basis of a general-purpose
      build framework such as what we would want for an &abuild;
      backend.  At the same time, <application>Apache
      Ant</application> appears to be the best option for Java as it
      is already very portable, flexible, written in Java, and widely
      supported.  Introduction of build.xml-based Java build support
      in &abuild; is a compromise as it leaves more to the developer
      than would be desirable, but it allows for greater flexibility
      in experimenting with alternative Java build approaches.  This
      mechanism for building Java code may disappear in a future major
      release of &abuild;, so developers are encouraged to use it only
      if the property-driven approach is not able to satisfy their
      requirements.
     </para>
    </note>
   </para>
   <sect1 id="ref.the-abuild-ant.properties-file">
    <title>The <filename>Abuild-ant.properties</filename> File</title>
    <indexterm>
     <primary>Abuild-ant.properties</primary>
    </indexterm>
    <para>
     The <filename>Abuild-ant.properties</filename> file is the build
     configuration file for Java build items.  It serves the same
     function for Java build items as <filename>Abuild.mk</filename>
     serves for platform-independent and C/C++ build items.
    </para>
    <para>
     Below is a list of supported properties.  You can also see this
     list by running <command>abuild properties-help</command> (or,
     equivalently, <command>abuild rules-help</command>) from any Java
     build item.
     <!--  This list of properties is also documented in            -->
     <!--  ant/properties-help.txt                                  -->
     <variablelist>
      <varlistentry>
       <term>abuild.java-source-version</term>
       <listitem>
        <para>
         If specified, the value of this property will be used for the
         source attribute of the javac tasks.  Otherwise,
         the value will come from the Java environment used to run ant.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.java-target-version</term>
       <listitem>
        <para>
         If specified, the value of this property will be used for the
         target attribute of the javac task.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.use-ant-runtime</term>
       <listitem>
        <para>
         If set, ant runtime libraries will be included in the
         compilation classpath.  This can be useful for compiling
         custom ant tasks.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.jar-name</term>
       <listitem>
        <para>
         The name of the JAR file, including the
         <filename>.jar</filename> or other archive suffix, to be
         created by this build item.  This must be set in order for
         compilation or packaging to take place.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.main-class</term>
       <listitem>
        <para>
         The name of a class, if any, that implements main.  Used when
         abuild.wrapper-name is set.
         <footnote>
          <para>
           Ideally setting <property>abuild.main-class</property>
           would also cause the manifest file to contain a
           <property>Main-Class</property> attribute, but this is not
           presently done in the ant code.
          </para>
         </footnote>
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.wrapper-name</term>
       <listitem>
        <para>
         If this property and <varname>abuild.main-class</varname> are
         both set, a script by this name will be generated that will
         invoke the Java runtime environment using this JAR file to
         invoke this main.  The script will include the classpath as
         determined by &abuild;.  On Windows, a stand-alone batch file
         (that does not reference the script) is generated as well,
         but the script is usable to invoke the application from a
         Cygwin environment.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.ear-name</term>
       <listitem>
        <para>
         The name of the EAR file, including the
         <filename>.ear</filename> suffix, to be generated.  This must
         be set for an EAR file to be generated.  EAR files contain any
         archive files in the <varname>abuild.classpath</varname>
         property and any locally generated JAR files.  They do not
         contain JAR files in the
         <varname>abuild.classpath.external</varname> property.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.application-xml</term>
       <listitem>
        <para>
         The name of the <filename>application.xml</filename> to put
         into an EAR file.  This must be set (along with
         <varname>abuild.ear-name</varname>) for an EAR file to be
         generated.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.war-name</term>
       <listitem>
        <para>
         The name of the WAR file, including the
         <filename>.war</filename> suffix, to be generated.  This must
         be set for a WAR file to be generated.  WAR files contain any
         JAR files in the <varname>abuild.classpath</varname> property.
         They do not contain JAR files in the
         <varname>abuild.classpath.external</varname> property.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.war-type</term>
       <listitem>
        <para>
         The type of the WAR file, which must be either
         <varname>client</varname> or <varname>server</varname>.  This
         property determines where items in
         <varname>abuild.classpath</varname> are copied.  For
         <varname>client</varname> WAR files, classpath JAR files are
         copied into the root of the WAR file where the are accessible
         to clients' browsers.  For <varname>server</varname> WAR
         files, they are copied into the
         <filename>WEB-INF/lib</filename> directory of the WAR file.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.web-xml</term>
       <listitem>
        <para>
         The name of the <filename>web.xml</filename> to put into a WAR
         file.  This must be set (along with
         <varname>abuild.war-name</varname>) for a WAR file to be
         generated.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.hook-build-items</term>
       <listitem>
        <para>
         A comma-separated list of build items from which hooks should
         be loaded.  For details about using hooks, please run
         <command>abuild hooks-help</command> and see <xref
         linkend="ref.java-hooks-and-generators"/>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.local-buildfile</term>
       <listitem>
        <para>
         The name of a local build file, specified relative to the
         build item's directory, that will be imported by
         <application>ant</application>.  It may contain additional
         properties that can't be specified in a property file,
         resource collections, or even additional targets.  If you are
         using this too often, please consider whether a build item
         hooks file should be used instead, or whether there is some
         functionality that is missing from the core &abuild; ant
         framework code.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.use-local-hooks</term>
       <listitem>
        <para>
         If this and <varname>abuild.local-buildfile</varname> are both
         set, &abuild; will attempt to run hooks from the local build file
         as well as from any hook build items.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>abuild.junit.testsuite</term>
       <listitem>
        <para>
         This property contains the name of the class that implements
         this build item's junit test suite.  It must be set in order
         for the <varname>test</varname> target to attempt to run a
         junit test suite.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     Note that at most of one <varname>abuild.jar-name</varname>,
     <varname>abuild.war-name</varname>, or
     <varname>abuild.ear-name</varname> may be set for any given build
     item.
    </para>
   </sect1>
   <sect1 id="ref.directory-structure-for-java-builds">
    <title>Directory Structure For Java Builds</title>
    <para>
     &Abuild;'s <application>ant</application> code assumes a
     particular directory structure for Java-based build items.  The
     following table describes the directories &abuild; looks for and
     what they mean.  All paths are relative to the build item
     directory.  Note that <filename>abuild-java</filename> is the
     &abuild; output directory for Java builds.  All directories under
     <filename>abuild-java</filename> are created automatically.  All
     other directories are optional: &abuild; will use them if they
     exist but will not complain if they are missing.  Note that the
     <command>clean</command> target removes the entire &abuild;
     output directory, which includes all the unused empty
     directories.
    </para>
    <variablelist>
     <varlistentry>
      <term><filename>src/java</filename></term>
      <listitem>
       <para>
        This directory contains java source code.  Any files it
        contains will be compiled into class files and included in the
        JAR or WAR file.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>src/resources</filename></term>
      <listitem>
       <para>
        Any files contained here will be copied to the JAR file named
        in the <varname>abuild.jar-name</varname> property or the EAR
        file named in the <varname>abuild.ear-name</varname> property.
        Standard ant exclusions (for CM directories, editor backup
        files, etc.) are in effect.  Files will be placed under the
        root of the JAR or EAR in the same relative location as they
        are to <filename>src/resources</filename> in the source tree.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>src/web</filename></term>
      <listitem>
       <para>
        Any files contained here will be copied to the WAR file named
        in the <varname>abuild.war-name</varname> property.  Standard
        ant exclusions (for CM directories, editor backup files, etc.)
        are in effect.  Files will be placed under the root of the WAR
        in the same relative location as they are to
        <filename>src/web</filename> in the source tree.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>src/conf</filename></term>
      <listitem>
       <para>
        Any files contained here will be added to the
        <filename>META-INF</filename> directory in the JAR or EAR file
        named in the <varname>abuild.jar-name</varname> property or
        <varname>abuild.ear-name</varname> property or the
        <filename>WEB-INF</filename> directory in the WAR file named in
        the <varname>abuild.war-name</varname> property.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>qtest</filename></term>
      <listitem>
       <para>
        This directory contains any qtest test suites.  It must exist
        in order for the <varname>test</varname> target to attempt to
        run any qtest-based test suites.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>abuild-java/src/java</filename></term>
      <listitem>
       <para>
        This directory contains any automatically generated java code.
        It is created automatically by &abuild;'s ant rules and may be
        populated by a <varname>generate</varname> hook from a local
        build file or build item hook file.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>abuild-java/src/resources</filename></term>
      <listitem>
       <para>
        This directory is created automatically by &abuild;'s ant rules.
        It should be populated with any automatically generated files
        that are to be added to the JAR.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>abuild-java/classpath</filename></term>
      <listitem>
       <para>
        This directory is created automatically if an EAR or WAR file
        is being generated.  If an EAR file is generated, it is
        populated automatically with all files in the
        <varname>abuild.classpath</varname> property.  If a WAR file is
        being generated, it is populated with the jar-file versions of
        all the files in the <varname>abuild.classpath</varname>
        property.  No action is required with this directory, but if
        necessary, a build item may create a
        <command>pre-package</command> hook to modify or rearrange the
        contents of that directory.  This can be useful for certain EAR
        and WAR file construction cases.  This mechanism may change in
        the future.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>abuild-java/classes</filename></term>
      <listitem>
       <para>
        This directory contains class files that result from compiling
        files in both <filename>src/java</filename> and
        <filename>abuild-java/src/java</filename>.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>abuild-java/dist</filename></term>
      <listitem>
       <para>
        This directory is where &abuild; targets place files that are
        intended to be used outside of this build item.  Among other
        things, generated archive files are placed into this
        directory.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>abuild-java/junit</filename></term>
      <listitem>
       <para>
        This directory contains the output of junit tests.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><filename>abuild-java/junit/html</filename></term>
      <listitem>
       <para>
        This directory contains the HTML summary of junit test output.
        Loading <filename>index.html</filename> from this directory
        into a browser will allow you to view the test results.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <!-- keep this directory last -->
      <term><filename>abuild-java/empty</filename></term>
      <listitem>
       <para>
        This is an empty directory used to substitute in &abuild;'s
        <application>ant</application> code for optional directories
        that don't exist.  You should never put any files here.  If
        you do, they will show up in generated archives in mysterious
        places.
        <footnote>
         <para>
          If you really want to know why we do it this way, read the
          comments in <filename>ant/abuild.xml</filename> in your
          &abuild; distribution.
         </para>
        </footnote>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>
     Most of these directory names are all made available to ant target
     authors through properties.  For details, please see <xref
     linkend="ref.guidelines-for-ant-target-authors"/>.
    </para>
   </sect1>
   <sect1 id="ref.abuild-ant.xml">
    <title>The <filename>Abuild-ant.xml</filename> File</title>
    <indexterm>
     <primary>Abuild-ant.xml</primary>
    </indexterm>
    <para>
     The ant portion of the Java support in &abuild; is somewhat
     experimental.  To handle those cases in which &abuild;'s current
     ant support is inadequate and to facilitate experimentation with
     alternative approaches, &abuild; will also detect the build file
     <filename>Abuild-ant.xml</filename>.  This file is mutually
     exclusive with <filename>Abuild-ant.properties</filename>.  If it
     exists, &abuild; will bypass its internal ant structure and
     invoke ant on this file directly.  Keep in mind, however, that it
     will invoke ant from the <filename>abuild-java</filename>
     directory as if the file were copied to a
     <filename>build.xml</filename> in that directory.  (&Abuild; runs
     the equivalent of <command>ant -f ../abuild-ant.xml
     -Dbasedir=.</command> from <filename>abuild-java</filename> when
     it sees <filename>Abuild-ant.xml</filename>.)  This means that
     relative paths in <filename>Abuild-ant.xml</filename> are
     resolved from the &abuild; output directory.  This is one of the
     reasons that this file is not called
     <filename>build.xml</filename> as that would imply that you could
     just run ant, which, in general, will not work.  In order to work
     properly with &abuild;, this file should define a target called
     <command>all</command> that builds everything needed in order to
     build items that depend on it.  Ideally, it should also define
     other targets that &abuild; expects to be defined so that build
     that run those targets over a build set that includes this item
     will not fail.  Even though there aren't actually any
     restrictions on what version of ant you could use for this
     alternative Java support, &abuild; still requires it to be 1.7 or
     newer.  This way, you won't run into the situation of having an
     old version of ant and suddenly needing to upgrade because of the
     addition of a build item that uses &abuild;'s included ant
     framework.
    </para>
    <para>
     Note that &abuild; still creates the
     <filename>.ab-dynamic-ant.properties</filename> file in the
     <filename>abuild-java</filename> directory, so the hand-coded ant
     build file still has access to all the information from the
     &abuild; interfaces of its dependencies as well as the properties
     that contain the paths to those items.  If you are writing an
     <filename>Abuild-ant.xml</filename> file, you are
     <emphasis>strongly encouraged</emphasis> to use this file to
     minimize your direct dependence on ant, the environment, and the
     file system layout.  For an example of a build item build in this
     way that interoperates with &abuild;'s default ant support, see
     <xref linkend="ref.example.build-driven-java"/>.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.shared-libraries">
   <title>Shared Libraries</title>
   <para>
    In most cases, development efforts consisting of large amounts of
    dynamic and evolving code will be best served by sticking with
    static libraries.  Sometimes, however, it may be desirable or
    necessary to create shared library object files.  &Abuild;
    provides limited support for working with shared libraries on
    UNIX-based systems and DLLs on Windows systems.  Note that there
    are many ancillary concerns one must keep in mind when using
    shared libraries such as binary interface compatibility.  We touch
    lightly on these topics here, but a full discussion is out of
    scope for this document.
   </para>
   <sect1 id="ref.building-shared-libraries">
    <title>Building Shared Libraries</title>
    <para>
     Building shared libraries with &abuild; is essentially identical
     to building static libraries.  You still set up your shared
     library targets using <varname>TARGETS_lib</varname> in
     <filename>Abuild.mk</filename> just as you would for static
     libraries.  In order to tell &abuild; that a library should be
     created as a shared library, you must set the additional variable
     <varname>SHLIB_<replaceable>libname</replaceable></varname> where
     <replaceable>libname</replaceable> is the name of the library
     target.  The value of this variable consists of up to three
     numbers: <varname>major version</varname>, <varname>minor
     version</varname>, and <varname>revision</varname>.  These values
     tell potential users of your library when the library has
     changed.  In general, you should only modify these values when
     you are releasing versions of your library.  During development,
     it's best to just leave them alone or else your version numbers
     will get very large and you will lose all the advantages of using
     shared libraries because of the need to relink everything all the
     time.  Before a release, the major version number should be
     incremented if the shared library has had interfaces removed or
     modified since the last release as those operations would make
     old binaries that linked with the shared library fail to work
     with the new version.  The minor version should be incremented if
     no interfaces were changed or removed but new interfaces were
     added.  This indicates that old binaries would work with new
     libraries but new binaries may not work with old libraries.  The
     revision number should be incremented if any changes were made to
     the shared library code that did not affect the interfaces.  This
     just tells the user that the library has changed relative to
     another version that may be installed.  On UNIX platforms,
     &abuild; will build executables that link against shared
     libraries in such a way that they will fail to locate shared
     libraries whose major version numbers do not match what they
     linked against.  The unversioned <filename>.so</filename> file
     and the <filename>.so</filename> file with only the major version
     will be symbolic links to the fully versioned file name.  (For
     example, if the actual shared library file were
     <filename>libmoo.so.1.2.3</filename>, both
     <filename>libmoo.so</filename> and
     <filename>libmoo.so.1</filename> would be symbolic links to it.)
     On Windows systems, the version number parameters are ignored.
    </para>
    <para>
     Note that all the version number parameters are optional.
     Although they should always be used when creating actual shared
     libraries that you intend to link programs against, they may be
     omitted in some other cases.  For example, if you are building a
     shared library object file that will be loaded at runtime or used
     as a plugin (such as with Java native code), then it may be
     appropriate to omit the version numbers altogether.  Even if the
     <varname>SHLIB_<replaceable>libname</replaceable></varname>
     variable is set to an empty string, &abuild; will still make a
     shared library instead of a static library.  There is no way to
     create both a shared and a static version of the same library at
     the same time, but it is possible to create a shared library that
     links against a static library, which achieves the same effect.
    </para>
    <para>
     By default, when a shared library depends on a static library,
     &abuild; will not link the static library into the shared
     library.  On some systems, you <emphasis>must</emphasis> link
     static libraries into shared libraries in order for the build to
     succeed, and on other systems, it is optional.  When mixing
     shared libraries and static libraries, you should make sure that
     you don't include two copies of the same symbols in more than one
     place (two shared libraries or a shared library and an
     executable).  Some systems handle this case acceptably, and
     others don't.  Even in the best case, doing this is wasteful and
     potentially confusing.  In order to tell &abuild; to link a
     static library into a shared library, set the variable
     <varname>LINK_SHLIBS</varname> to a non-empty value (usually
     <literal>1</literal>) in your <filename>Abuild.mk</filename>.
     This applies to all shared libraries built in a build item.
    </para>
    <para>
     &Abuild; allows you to mix executables, shared libraries, and
     static libraries in the same build item.  If you do this, all
     executable targets will link with all shared and all static
     library targets.  If <varname>LINK_SHLIBS</varname> is set, then
     all shared libraries will also link with all static libraries.
    </para>
    <para>
     In order to allow static libraries to be linked into shared
     libraries, &abuild; compiles all library object files as
     position-independent code.  In some extremely rare cases, you may
     wish to avoid doing this as there is a very minor performance
     cost to do it.  If you wish to prevent a specific source file
     from being compiled as position-independent code, set the
     variable
     <varname>NOPIC_<replaceable>filename</replaceable></varname> to
     some non-empty value where <replaceable>filename</replaceable> is
     the name of the source file.  For example, the code
     <literal>NOPIC_File.cc := 1</literal> in your
     <filename>Abuild.mk</filename> file would prevent
     <filename>File.cc</filename> from being compiled as
     position-independent code.  Note that &abuild; does not check to
     make sure that code compiled in this way is not eventually linked
     into a shared library.  If you try to link
     non-position-independent code into a shared library, it may not
     link at all, or it may cause undefined and hard-to-trace
     behavior.  Use of this feature is not recommended unless
     absolutely needed to fix some specific problem.
    </para>
    <para>
     In order to run a program that is linked with shared libraries,
     the operating system will have to know where to find the shared
     library.  &Abuild; does not include library run path information
     in the executables as doing so is inherently dangerous and
     non-portable.  Even if &abuild; were to ignore this danger and
     include run path information, doing so would potentially preclude
     the ability to swap out shared libraries at runtime, which is
     often the main reason for wanting to use them in the first place.
     Instead, you will need to make sure that, one way or another, the
     shared libraries you need are located in a directory that is in
     your shared library path.  On most UNIX systems, you can set the
     <envar>LD_LIBRARY_PATH</envar> environment variable or install
     the shared libraries into certain system-defined locations.  On
     some systems (like Linux), you can also add directories to
     <filename>/etc/ld.so.conf</filename>.  On Windows, you can
     colocate the DLL files with the executables, or you can add the
     directories containing the DLL files to your path.
    </para>
   </sect1>
   <sect1 id="ref.example.shared-library">
    <title>Shared Library Example</title>
    <para>
     In <filename>doc/example/shared-library</filename>, you will find
     an example of using shared libraries.  This example contains an
     executable program and two implementations of the same interface,
     both provided in shared libraries.  In the
     <filename>shared-library/prog</filename> directory, you will find
     a simple program.  Here is its <filename>Abuild.conf</filename>
     file:
     <?example shared-library/prog/Abuild.conf?>
     All it does is depend on the build item
     <classname>shared</classname>.  This program doesn't have to do
     anything special in order to link against the shared library.
     Here is the <classname>shared</classname> build item's
     <filename>Abuild.conf</filename>:
     <?example shared-library/shared/Abuild.conf?>
     This is a pass-through build item that depends upon
     <classname>shared.impl1</classname>.  Here is that build item's
     <filename>Abuild.conf</filename>:
     <?example shared-library/shared/impl1/Abuild.conf?>
     This build item depends on an item called
     <classname>shared.include</classname>.  Although, in general,
     putting your header files in a separate build item is risky (see
     <xref linkend="ref.best-practices"/> for a discussion), in this
     case, we want to do this so that we can have two separate
     implementations of this interface that reside in two different
     shared libraries.  By making this build item private to the
     <classname>shared</classname> build item name scope (see <xref
     linkend="ref.build-item-name-scoping"/>), we effectively
     prevent outside build items from depending on it directly.
    </para>
    <para>
     Here is the first implementation's <filename>Abuild.mk</filename>
     file:
     <?example shared-library/shared/impl1/Abuild.mk?>
     What we have here is a normal library
     <filename>Abuild.mk</filename> file except that we have set the
     variable <varname>SHLIB_shared</varname> to the value <literal>1
     2 3</literal>.  This tells &abuild; to build the
     <filename>shared</filename> library target as a shared library
     instead of a static library using the version information
     provided.  On Windows, &abuild; will create
     <filename>shared.dll</filename> along with
     <filename>shared.lib</filename> and
     <filename>shared.exp</filename>.  On UNIX, it will create
     <filename>libshared.so.1.2.3</filename> and will make
     <filename>libshared.so</filename> and
     <filename>libshared.so.1</filename> symbolic links to it.
     Executables that link with <filename>-lshared</filename> will
     need to find <filename>libshared.so.1</filename> in their library
     paths at runtime.
    </para>
    <para>
     This shared library consists of a single file called
     <filename>Shared.cc</filename>.  Here is the header file
     <filename>Shared.hh</filename>:
     <?example shared-library/shared/include/Shared.hh?>
     This is the implementation of the interface:
     <?example shared-library/shared/impl1/Shared.cc?>
     Notice the <literal>__declspec(dllexport)</literal> line that is
     there for Windows only.  This is necessary to make Windows export
     the function to a DLL.  No such mechanism is required in a UNIX
     environment.  Our <filename>Abuild.interface</filename> file
     looks like a normal <filename>Abuild.interface</filename> file
     for libraries except that it omits an <varname>INCLUDES</varname>
     variable and declares a special <firstterm>mutex</firstterm>
     variable:
     <?example shared-library/shared/impl1/Abuild.interface?>
     The <varname>INCLUDES</varname> variable is set in the
     <classname>shared.include</classname> build item's
     <filename>Abuild.interface</filename> instead:
     <?example shared-library/shared/include/Abuild.interface?>
     The mutex variable is a normal interface variable.  We declare
     the same variable in the <filename>Abuild.interface</filename>
     file for <classname>shared.impl2</classname>.  Since &abuild;
     won't allow any interface variable to declared in more than one
     place, this effectively prevents any one build item from
     simultaneously depending on both
     <classname>shared.impl1</classname> and
     <classname>shared.impl2</classname>.  Please note that we have
     included the name of the public item,
     &ldquo;<classname>shared</classname>&rdquo; in the name of the
     mutex variable &ldquo;<varname>shared_MUTEX</varname>&ldquo; to
     avoid namespace collisions with other unrelated build items.
    </para>
    <para>
     Our second implementation is not in the dependency chain of our
     program.  It resides in the <filename>impl2</filename> directory.
     Here are its <filename>Abuild.conf</filename> and
     <filename>Abuild.mk</filename>:
     <?example shared-library/shared/impl2/Abuild.conf?>
     <?example shared-library/shared/impl2/Abuild.mk?>
     You will notice in this case that this build item depends on a
     static library that its private to its own build item name scope.
     This static library provides additional functions that are used
     <emphasis>within</emphasis> the shared library.  In order to tell
     &abuild; to link that static library into the shared library, we
     set the variable <varname>LINK_SHLIBS</varname>.  Also, we want
     to avoid having the static library appear on the link statement
     for executables that link with this shared library.  To do that,
     we have to do some extra work in our
     <filename>Abuild.interface</filename> file.  Here are that file
     and the <function>after-build</function> file that it loads:
     <?example shared-library/shared/impl2/Abuild.interface?>
     <?example shared-library/shared/impl2/after.interface?>
     Notice that we reset the <varname>LIBS</varname> variable and add
     our own library to it after the build has completed.  This
     effectively replaces everything that was previously in the
     <varname>LIBS</varname> variable with our library for items that
     depend on us.  In this case, the
     <classname>shared.impl2.static</classname> build item had added
     <filename>static</filename> to <varname>LIBS</varname> in its
     <filename>Abuild.interface</filename> file:
     <?example shared-library/shared/impl2/static/Abuild.interface?>
     The effect of our reset that the <filename>static</filename>
     library added to <varname>LIBS</varname> there is available to
     <classname>shared.impl2</classname> during its linking but not
     available to those who depend on
     <classname>shared.impl2</classname>.
     <footnote>
      <para>
       What is going on here is a bit subtle.  At first, resetting
       <varname>LIBS</varname> may seem quite drastic, but it really
       isn't.  The reset statement only resets the state of
       <varname>LIBS</varname> as it was at the time that this
       <filename>Abuild.interface</filename> file was processed.  Any
       build item that depends on this item will still have all the
       other items that were added to <filename>LIBS</filename> by
       other build items.  To really understand how this works, please
       see <xref linkend="ref.interface-implementation"/>.
      </para>
     </footnote>
    </para>
    <para>
     Finally, we can run our program.  Remember that in order to run
     the program, you must explicitly add the directory containing the
     shared library whose implementation you want to use to your
     <envar>LD_LIBRARY_PATH</envar> on UNIX or your
     <envar>PATH</envar> on Windows.  If you set this variable to
     include the output directory for
     <classname>shared.impl1</classname>, you will see this output:
     <?qtest example.shared-library-prog-impl1.out?>
     If you set it to the <classname>shared.impl2</classname> build
     item's directory, you will see this instead:
     <?qtest example.shared-library-prog-impl2.out?>
     Note that we could have made <classname>shared</classname> depend
     on <classname>shared.impl2</classname> instead of
     <classname>shared.impl1</classname> and gotten the same results.
     Hiding the actual shared library implementation behind a
     pass-through build item provides a useful device for allowing you
     to reconfigure the system later on, including replacing
     place-holder shared library-based stub implementations with
     static library implementations later in the development process.
     With careful planning, this type of technique could be used to
     provide a shared-library based stub system that could be swapped
     out later with very little effect on the overall build system.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.code-generators">
   <title>Automatically Generated Code for GNU Make-based Builds</title>
   <para>
    In this chapter, we show how to use &abuild; with automatically
    generated code.  The examples in this chapter use the
    <application>GNU Make</application> backend, but the principles
    are the same if you are using <application>ant</application>.
    Examples of using code generators with Java appear later in the
    document (<xref linkend="ref.example.java-code-generator"/>).
   </para>
   <sect1 id="ref.build-item-rules">
    <title>Build Item Rules</title>
    <indexterm>
     <primary>Rules.mk</primary>
    </indexterm>
    <para>
     The most important thing to realize about code generators in
     &abuild; is that code generation can be viewed as a just another
     service that a build item can offer, just like libraries or
     header files.  In many build systems, code generators are
     problematic because you need to take special steps to make sure
     generated code appears before compilation or dependency
     generation begin.  With &abuild;, code generators get run at the
     correct stage by virtue of appearing in the correct place in the
     dependency tree.
    </para>
    <para>
     In order for a <application>make</application>-based build item
     to provide code generation, it must have a
     <filename>Rules.mk</filename> file.  The
     <filename>Rules.mk</filename> file is a GNU Make fragment that is
     included by &abuild; only when explicitly requested.  In order to
     use the rules implemented in one build item's
     <filename>Rules.mk</filename> file, you must depend on that build
     item and also list its name in the
     <varname>BUILD_ITEM_RULES</varname> variable in your
     <filename>Abuild.mk</filename> file.  Any rules defined in
     <filename>Rules.mk</filename> are run from the &abuild; output
     directory of the build item that is using the rules.  That means
     that if the rules need to refer to files inside the build item
     that <emphasis>provides</emphasis> the rules, they must do so by
     either accessing interface variables defined in that build item's
     <filename>Abuild.interface</filename>, or prefixing the files
     with a variable that &abuild; provides.  Specifically, for a
     build item named
     <classname><replaceable>build-item</replaceable></classname>,
     &abuild; provides variable called
     <varname>abDIR_<replaceable>build-item</replaceable></varname>
     that can be accessed from a <filename>Rules.mk</filename> file.
     Note that &abuild; only provides these variables for build items
     in your dependency chain.  Also, use of these variables from
     <filename>Abuild.mk</filename> files is strongly discouraged as
     it can cause your build tree to contain path-based dependencies
     instead of name-based dependencies which would defeat one of the
     most compelling advantages of &abuild;.  The best practice is to
     refer to files in your own build item from your own files by
     using the abuild-provided variable name to find your own path,
     and to define interface variables for files that you intend for
     other build items to access.  Either way, there are certain
     things that it are important to keep in mind when writing
     <application>GNU Make</application> rules for use inside of
     &abuild;.  For a discussion of this topic, please see <xref
     linkend="ref.guidelines-for-make-rule-authors"/>.
    </para>
   </sect1>
   <sect1 id="ref.example.code-generator">
    <title>Code Generator Example</title>
    <para>
     The <classname>derived-code-generator</classname> build item in
     <filename>doc/example/general/user/derived/code-generator</filename>
     contains a trivial code generator.  All it does is generate a
     source and header file that define a function that returns a
     constant, which is read from a file.  We have modified
     <classname>derived-main</classname> to use the code generator.
     The code generator itself is implemented in the
     <classname>derived-codegen</classname> build item and is made
     available through that build item's <filename>Rules.mk</filename>
     file.
    </para>
    <para>
     First, we'll look at the code generator itself.  Notice that the
     only &abuild; files contained in the
     <classname>derived-code-generator</classname> build item
     directory at <filename>user/derived/code-generator</filename> are
     <filename>Abuild.conf</filename> and
     <filename>Rules.mk</filename>.  There is no
     <filename>Abuild.interface</filename> or
     <filename>Abuild.mk</filename>, though these files could exist if
     they were needed.
    </para>
    <para>
     The important part of this is <filename>Rules.mk</filename>, so
     we'll study it carefully.  Here is the
     <filename>Rules.mk</filename> file:
     <?example general/user/derived/code-generator/Rules.mk?>
     The first thing we do here is to define a
     <command>rules-help</command> target that prints some help
     information about using the rules.  By placing the name of this
     build item (<classname>derived-code-generator</classname>) in
     your <varname>BUILD_ITEM_RULES</varname> variable, you will see
     this output when you run <command>abuild rules-help</command>.
     When writing rules help, please remember that the strings you are
     echoing are subject to <application>make</application>'s ordinary
     variable substitution rules.  It's best to actually test by
     running <command>abuild rules-help</command> to make sure that it
     echoes properly.  Alternatively, you can have your
     <command>rules-help</command> target display the contents of a
     file in your build item.
    </para>
    <para>
     The next thing that happens is that we have some code that checks
     for undefined variables.  This isn't strictly necessary, but it
     can save your users a lot of trouble if you detect when variables
     they are supposed to provide are not there.  We use the function
     <function>undefined_vars</function> to do this check.  This
     function is provided by &abuild; and appears in the file
     <filename>make/global.mk</filename> relative to the top of the
     &abuild; installation.  If you expect to write a lot of make
     rules, it will be in your best interest to familiarize yourself
     with the functions offered by this file.  Even if we hadn't done
     this, &abuild; invokes GNU Make in a manner that causes it to
     warn about any undefined variables.  This is useful because
     undefined variables are a common cause of makefile errors.
    </para>
    <para>
     Then we add our source file to the <command>all::</command>
     target to make sure it gets built.  Note that we use
     <command>all::</command>, not <command>all:</command>, since
     there are multiple <command>all::</command> targets throughout
     various rules files.  Adding our source files to the
     <command>all::</command> target is not strictly necessary in this
     case since, by listing the source file as a source file for one
     of our targets (in the build item that uses this code generator),
     it will be built in the proper sequence.  It's still good
     practice to do this though, but remember that in a parallel
     build, dependencies of the <command>all::</command> target may
     not necessarily be built in the order in which they are listed.
    </para>
    <para>
     Next, we have the actual <application>make</application> rules
     that create the automatically generated files.  In this case, we
     make the output files depend on both the input file and the
     code generator.  Although &abuild; is running the rules from the
     depending build item's output directory, we don't need to put any
     prefix in front of the name of the input file: &abuild; sets
     <application>make</application>'s <varname>VPATH</varname>
     variable so that the file can be found.  By creating a dependency
     on the code generator as well, we can be sure that if the code
     generator itself is modified, any code that it generates will
     also be updated.
    </para>
    <para>
     In the commands for generating our files, notice that we don't
     need an <literal>@</literal> sign before the generation command
     to prevent it from echoing since &abuild; doesn't echo its output
     by default.  Not putting an <literal>@</literal> sign there means
     that the user will see the command if he/she runs &abuild; with
     the <option>--verbose</option> option.  So that the user knows
     something is happening, we generate a useful output message using
     <varname>@$(PRINT)</varname>.  The use of
     <varname>@$(PRINT)</varname> ensures that we don't see the actual
     echo command even when running with <option>--verbose</option>,
     and that we don't see the output at all when we're running with
     <option>--silent</option>.  All informational messages should be
     generated this way.  (For the <command>rules-help</command>
     target, we use <command>@echo</command> directly since it doesn't
     make sense to suppress that output even when running with
     <option>--silent</option>.)  Note also that we invoke the code
     generator with <command>perl</command> rather than assuming that
     it is executable (since some version control systems or file
     systems make it hard to preserve execute permissions) and that we
     specify the path to the code generator in terms of
     <varname>$(abDIR_derived-code-generator)</varname>.  Also notice
     that we have to prefix the name of the input file with
     <varname>$(SRCDIR)</varname> when we pass it to the code
     generator since we are running from the &abuild; output
     directory.  (The <varname>VPATH</varname> variable tells
     <application>make</application> where to look, but it doesn't
     tell our code generator anything!)  Finally, we add a
     <command>clean</command> rule that removes our automatically
     generated files.  Note that the <command>clean</command> rule is
     only run when the user invokes &abuild; from the output
     directory.  For this reason, adding a <command>clean</command>
     target is optional.  For more detail on this, please see <xref
     linkend="ref.running-in-output-directory"/>.
    </para>
    <para>
     To use this code generator from
     <classname>derived-main.src</classname>, all we have to do is
     define the required variables in <filename>Abuild.mk</filename>,
     and add <classname>derived-code-generator</classname> as a
     dependency in <filename>Abuild.conf</filename> and to the
     <varname>BUILD_ITEM_RULES</varname> variable in
     <filename>Abuild.mk</filename>.  Note that we have modified
     <filename>main.cpp</filename> to include
     <filename>auto.h</filename> and to call
     <varname>getNumber()</varname>, thus testing the use of the code
     generator.  Since this application effectively contains the only
     test suite for the code generator, we declare it as a tester of
     the code generator in <filename>Abuild.conf</filename> using
     traits.  Here are the relevant files from
     <classname>derived-main.src</classname>:
     <?example general/user/derived/main/src/Abuild.conf?>
     <?example general/user/derived/main/src/Abuild.mk?>
     Here is the modified <filename>main.cpp</filename> file:
     <?example general/user/derived/main/src/main.cpp?>
    </para>
   </sect1>
   <sect1 id="ref.example.auto-from-variable">
    <title>Dependency on a Make Variable</title>
    <para>
     In the previous example, we showed how to create a code generator
     that generates code from a file.  This works nicely because
     <application>make</application>'s dependency system is based on
     file modification times.  Sometimes, you may want to generate
     code based on the value of a <application>make</application>
     variable whose origin may be either
     <filename>Abuild.mk</filename> or, more likely,
     <filename>Abuild.interface</filename>.  Doing this is more
     difficult because it requires some obscure make coding, but it is
     common enough to warrant an example.
    </para>
    <para>
     The &ldquo;obvious&rdquo; way to pass information from a
     <application>make</application> variable into your code would be
     to use a preprocessor symbol based on the variable and to pass
     this symbol to the code with <varname>XCPPFLAGS</varname> or
     <varname>XCPPFLAGS_<replaceable>Filename</replaceable></varname>.
     The problem with this is that there is no dependency tracking on
     variable values, so if you change the variable value, there is
     nothing that will trigger recompilation of the files that use the
     preprocessor symbol.  To get around this problem, we use local
     rules to generate a file with the value of the variable.  This
     example can be found in
     <filename>doc/example/auto-from-variable</filename>.
    </para>
    <para>
     First, look at the <classname>file-provider</classname> build
     item in <filename>library</filename>.  This build item
     automatically generates a header file based on the value of a
     make variable.  The variable itself is defined in the
     <filename>Abuild.interface</filename> file:
     <?example auto-from-variable/library/Abuild.interface?>
     We define the variable <varname>file-provider-filename</varname>
     to point to a local file.  By making this a <type>filename</type>
     variable, we tell &abuild; to translate its location to the path
     to this file as resolved relative to the
     <filename>Abuild.interface</filename> file's directory.  Note
     that we use the build item name in the variable name to reduce
     the likelihood of clashing with other interface variables.  In
     the <filename>Abuild.mk</filename> file we use the
     <varname>LOCAL_RULES</varname> variable to declare the local
     rules file <filename>generate.mk</filename>.  This is where we
     will actually generate the header file.  Otherwise, this is an
     ordinary <filename>Abuild.mk</filename>:
     <?example auto-from-variable/library/Abuild.mk?>
    </para>
    <para>
     Here is <filename>generate.mk</filename>:
     <?example auto-from-variable/library/generate.mk?>
     There is a lot going on here, so we'll go through line by line.
     <application>GNU Make</application> is essentially a functional
     programming environment.  Makefiles are not executed
     sequentially; they are evaluated based on dependencies instead.
     Sometimes you need to force <application>make</application> to
     run steps sequentially.  You can trick
     <application>make</application> into doing this by making the
     operations side effects of a variable assignment using the
     <literal>:=</literal> operator since these are evaluated when
     they are read.  Our goal here is to translate a variable value,
     which can't be tracked by the dependency system, into a file
     modification time, which can.  To do this, we create a file whose
     value and modification time get updated whenever the variable
     value changes.  We do this in two steps: first, we write the
     value of the variable to a temporary file (the first
     <varname>DUMMY</varname> assignment), and then we overwrite
     another file with the temporary file if the other file either
     doesn't exist or has a different value (the second assignment).
     In this way, whenever the variable changes, the file called
     <filename>variable-value</filename> gets updated.  Although the
     <filename>variable-value.tmp</filename> file gets updated every
     time when run &abuild;, we don't care since that file is not used
     as a dependency.  Next, we provide the rules to actually generate
     the header file.  The header file depends on the file
     <filename>variable-value</filename> so it will get regenerated
     whenever the variable changes.  Here we just use
     <command>echo</command> to write the header file.  Note that we
     have to call <application>make</application>'s
     <function>abspath</function> function to translate the value of
     <varname>file-provider-filename</varname> to an absolute path.
     This is because &abuild; writes <type>filename</type> variables
     as relative paths when it passes them to
     <application>make</application>.  Note also that didn't actually
     have to use the value of the <filename>variable-value</filename>
     file.  We know that its contents are identical to the value of
     the variable, so we can just use the variable's value directly.
     Finally, we want to make sure that
     <filename>FileProvider_file.hh</filename> exists before we start
     compiling any of the files that reference it.  We have a little
     bit of a bootstrapping problem here: although &abuild; ordinarily
     generates dependency information of object files on header files
     automatically, this generation step is performed during the
     compilation itself.  In order to force the header file to be
     generated before the compile starts, we have to create an
     explicit dependency.  We do this by creating an explicit
     dependency from the object file to the header file.  Notice that
     we use the make variable <varname>LOBJ</varname> to get the
     object file suffix rather than hard-coding it.  All compiler
     support files are required to set the variable
     <varname>LOBJ</varname> to the suffix of object files that are
     going into libraries and <varname>OBJ</varname> for object files
     that are not going into libraries.  Although they are often the
     same, they don't have to be.
     <footnote>
      <para>
       It would be nice to be able to avoid this issue entirely.  One
       way to avoid it would be generate a source file instead of a
       header file.  In that case, <application>make</application>
       would definitely try to generate the source file before
       building, so no explicit dependency would be required.  This
       approach would certainly work for this example.  One option
       that would definitely <emphasis>not</emphasis> work would be to
       create a <command>generate</command> target analogous to the
       <command>generate</command> hook in &abuild;'s
       <application>ant</application> support and making it a
       prerequisite for the <command>all</command> target.  Although
       this would work for strictly serial builds, it wouldn't
       necessarily work for parallel builds as
       <application>make</application> is free to build all the
       prerequisites for a given target in any order as long as they
       don't have dependencies on each other.  In fact, the reason
       this trick works in <application>ant</application> is that
       <application>ant</application> only runs tasks in parallel when
       you explicitly tell it that it can.  So the bottom line is that
       whatever we are automatically generating must appear as a
       dependency somewhere.  Source files automatically appear as
       dependencies of their object files, but header files don't
       appear as dependencies anywhere until the compile has already
       been run at least one time.  Therefore, a solution that works
       for parallel builds and generates header files has to create an
       explicit dependency such as in this example.
      </para>
     </footnote>
    </para>
    <para>
     We have two files that use the header file.  The first one is the
     library implementation itself:
     <?example auto-from-variable/library/FileProvider.cc?>
     The other is the main program from the other build item:
     <?example auto-from-variable/program/main.cc?>
    </para>
    <para>
     There are a few additional points to be made about this example.
     We have taken an approach here that can be tailored for a wide
     variety of situations.  In this example, the interface variable
     is accessible to other build items.  If we didn't want this to be
     the case, we could have used an <filename>Abuild.mk</filename>
     variable instead or we could have made this variable visible
     conditionally upon an interface flag.  We have also made the
     header file available to other build items by adding the output
     directory to <varname>INCLUDES</varname> in
     <filename>Abuild.interface</filename>.  If you didn't want these
     to have such high visibility, you could protect them just as you
     would protect any private interfaces.  In other words, this
     example is a little bit of an overkill for the exact case that it
     implements, but it shows a pattern that can be used when this
     type of functionality is required.  The main thing to take away
     here is the use of a <application>make</application> trick to
     translate a variable value into a file modification time, thus
     making it trackable with <application>make</application>'s
     ordinarily dependency tracking mechanism.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.java-hooks-and-generators">
   <title>Java Hooks and Code Generators</title>
   <para>
    In this chapter, we explore the use of hooks and code generators
    for property-driven Java builds.  We also demonstrate how to have
    a build.xml-driven Java build item interoperate with
    property-driven build items.
   </para>
   <sect1 id="ref.ant-hooks">
    <title>Ant Hooks</title>
    <!--  This information is duplicated in ant/hooks-help.txt.    -->
    <!--  Please ensure that the material there is consistent      -->
    <!--  with the material here.                                  -->
    <indexterm>
     <primary>ant-hooks.xml</primary>
    </indexterm>
    <para>
     In order to make it possible for users to add additional steps to
     the build process, &abuild;'s <application>ant</application> code
     makes extensive use of hooks.
    </para>
    <para>
     Since hooks are called in separate projects from the main build,
     it is not useful to set properties from hook targets and expect
     them to be available to later targets not invoked directly by the
     hook.
    </para>
    <para>
     We define several hooks whose names start with
     <command>-pre-</command> or <command>-post-</command>.  These
     hooks are run before and after the corresponding target, and they
     are run even when the target itself is not being run.  For
     example, the <command>-post-package</command> hook may be run
     even if the package target is not run.  This makes it possible to
     implement packaging or compilation strategies, for example, that
     would be beyond &abuild;'s ant code's ordinary purview.  An
     example may be the implementation of a wrapper post-package hook
     that can create a wrapper around things in an item's classpath
     even if that item itself doesn't generate any new packages.
    </para>
    <para>
     The following hooks are defined:
     <itemizedlist>
      <listitem>
       <para>
        <command>init</command>: called from the
        <command>init</command> target after any internal
        initialization has been completed.  Use this to perform any
        additional initialization.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>generate</command>: called from the
        <command>generate</command> target, which is a dependency of
        the <command>compile</command> target.  Use this hook to
        automatically generate code to be compiled as part of the
        calling build item.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>pre-compile</command>: called right before
        compilation.  Use this hook to perform any compilation tasks
        that should precede invocation of the Java compiler but follow
        automatic generation of any source files.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>post-compile</command>: called right after
        compilation.  Use this hook to perform any operations that
        should follow invocation of the Java compiler and should be
        performed whether or not packaging is being done.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>pre-package</command>: called right before packaging.
        Use this hook to perform any operations that should be
        performed before packaging is performed but after all
        compilation steps have been completed.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>post-package</command>: called right after packaging.
        Use this hook to perform any operations that must follow
        packaging.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>pre-test</command>: called before any test suites are
        executed.  Use this to perform any unconditional setup
        required for automated testing.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>test</command>: called after any internally supported
        test suites are run but after pre-test and before post-test.
        Use this hook to provide support for additional automated test
        frameworks beyond those supported directly by abuild.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>post-test</command>: called after any internally
        supported or externally provided test suites have been run.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>deploy</command>: called from the
        <command>deploy</command> target.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>doc</command>: called from the <command>doc</command>
        target.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>other</command>: called from the
        <command>other</command> target.  This hook is provided as a
        mechanism for allowing build-item-specific or local targets to
        be defined that don't fit into the build in any other way.
        The expected mode of operation is that your
        <command>-other</command> target would depend upon various
        other targets that would be invoked conditionally upon the
        value of some user-provided property.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>properties-help</command>: called from the
        <command>properties-help</command> target.  Use this hook to
        provide help to your users about any properties that may need
        to set to make use of the services provided by your hooks.
       </para>
      </listitem>
      <listitem>
       <para>
        <command>interface-help</command>: called from the
        <command>interface-help</command> target.  Use this hook to
        provide help to your users about any variables that may need
        to set to set in their Abuild.interface files.
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Any file that provides hooks must create an
     <filename>ant-hooks.xml</filename> file.  For each hook that it
     wants to provide, it should create a target called
     <replaceable>-hook</replaceable> where
     <replaceable>hook</replaceable> is replaced by the hook name
     above.  For example, a hook file that provides a
     <command>generate</command> hook would define a target called
     <command>-generate</command>.
     <footnote>
      <para>
       We use target names that start with a hyphen
       (&ldquo;<literal>-</literal>&rdquo;) because
       <application>ant</application> considers these to be private
       targets.  This prevents users from invoking them explicitly
       from the command line but still allows them to be invoked as
       dependencies of other targets.
      </para>
     </footnote>
    </para>
   </sect1>
   <sect1 id="ref.example.java-code-generator">
    <title>Java Code Generator Example</title>
    <para>
     In this example, we create a simple Java &ldquo;executable&rdquo;
     (JAR file with a <function>main</function> method) that depends
     on a simple &ldquo;library&rdquo;.  The library contains some
     automatically generated code which is generated by a code
     generator that we also supply.  Our code generator defines a
     simple ant task to do the generation.  To tie this all together,
     we have several build items, which we will examine from the top
     down in dependency order.  This example can be found in the
     <filename>doc/example/java</filename> directory.  When building
     Java code with <application>ant</application>, &abuild; makes use
     of a custom logger.  This logger suppresses the output of empty
     <application>ant</application> targets, but does so in a manner
     that works well with nested targets.  If you wish to use the
     standard <application>ant</application> logger, you can invoke
     &abuild; with the <option>--no-abuild-logger</option>
     command-line option.
    </para>
    <para>
     We'll start off with the <classname>executable</classname> build
     item in the <filename>executable</filename> directory.  If you
     look at its <filename>Abuild.conf</filename> file, you will see
     that it depends on <classname>library</classname>:
     <?example java/executable/Abuild.conf?>
     From <classname>executable</classname>'s
     <filename>Abuild-ant.properties</filename> file, you can see that
     this build item is generating the file
     <filename>example-executable.jar</filename>, and that it is
     generating a wrapper script:
     <?example java/executable/Abuild-ant.properties?>
    </para>
    <para>
     The <filename>src</filename> directory under
     <filename>executable</filename> contains a
     <filename>java</filename> directory and a
     <filename>resources</filename> directory.  The
     <filename>src/java</filename> directory contains the java code,
     which in this case consists of the single source file
     <filename>Executable.java</filename> located in directory
     structure based on its package, as always.  The
     <filename>resources</filename> directory contains the file
     <filename>file.text</filename> which is to be included in the JAR
     file.  Our example executable reads the contents of this file
     from the JAR file as an example of how to make use of the
     <filename>resources</filename> directory.
    </para>
    <para>
     Next, we'll turn our attention to the <classname>library</classname>
     build item.  Our <classname>library</classname> build item creates a
     JAR file called <filename>example-library.jar</filename> as you
     can see from looking at the value of
     <varname>abuild.jar-name</varname> in its
     <filename>Abuild-ant.properties</filename> file:
     <?example java/library/Abuild-ant.properties?>
     In addition, this build item makes use of hooks in the
     <classname>code-generator</classname> build item.  Specifically,
     we tell that build item to generate a class called
     <classname>Negator</classname> in the
     <classname>com.example.library.generated</classname> package.
     Our <classname>library</classname> build item contains a single
     source file in <filename>src/java</filename>.  This source file
     uses the generated <classname>Negator</classname> class.
    </para>
    <para>
     For most users, this is all you really need to know: you will
     create your own code and resources and build them by setting
     properties.  Sometimes the properties will be standard &abuild;
     properties, and sometimes there will be additional properties as
     required by build items that provide build-related services to
     your build item.  As we continue, we will explore the
     <classname>code-generator</classname> build item to see what's
     going on behind the scenes.
    </para>
    <para>
     The <classname>code-generator</classname> build item is in the
     <filename>code-generator</filename> directory.  This build item
     creates a JAR file called
     <filename>CodeGenerator.jar</filename>.  It also sets the
     &abuild; property <varname>abuild.include-ant-runtime</varname>
     so that the <application>ant</application> runtime library will
     be included in the compile-time classpath:
     <?example java/code-generator/Abuild-ant.properties?>
    </para>
    <para>
     This build item also has a file called
     <filename>ant-hooks.xml</filename>.  This file contains the build
     hooks that are provided by this build item.  The
     <filename>ant-hooks.xml</filename> file references the property
     <varname>code-generator.classpath</varname>, which is declared in
     the <filename>Abuild.interface</filename> file.  Here are those
     files:
     <?example java/code-generator/Abuild.interface?>
     <?example java/code-generator/ant-hooks.xml?>
     This particular build item provides two hooks: a
     <command>generate</command> hook, and a
     <command>properties-help</command> hook.  These are implemented
     by defining targets called <command>-generate</command> and
     <command>-properties-help</command>.  It is proper for all build
     items that provide hooks to provide a
     <command>properties-help</command> hook if the hooks expect any
     additional properties to be set.  In this case, we are generating
     code, so we need to know the name of the class we are to
     generate.  Our <command>-properties-help</command> target echoes
     this information to <application>ant</application>'s output
     stream.  The <command>generate</command> hook is run by &abuild;
     before it compiles any code, so the <command>javac</command> step
     will be able to access the generated source files along with the
     hand-coded ones.  Our <command>-generate</command> target is an
     empty target that depends on the <command>codegen</command>
     target which does the actual work.
    </para>
    <para>
     Notice that there is nothing else required in an
     <filename>ant-hooks.xml</filename> file other than creation of
     appropriately named targets.  &Abuild;'s ant call will automatically
     load and invoke these targets at the right time as required.
    </para>
    <para>
     The <classname>code-generator</classname> build item's
     <filename>Abuild.interface</filename> does something that most
     build items don't have to do: it declares a custom variable that
     holds the name of the JAR file that it generates, and it does not
     add this JAR file to the classpath:
     <?example java/code-generator/Abuild.interface?>
     The reason for this is that
     <classname>code-generator</classname>'s users don't need to call
     anything from its JAR file in their code, but its
     <filename>ant-hooks.xml</filename> file, which will be invoked
     with <varname>basedir</varname> set to the calling build item's
     output directory, needs to know the location of the JAR file.
    </para>
    <para>
     The <classname>code-generator</classname>'s
     <filename>src/java</filename> directory contains the source code
     to the ant task, but the ant task's operation is clear just by
     looking at the <filename>ant-hooks.xml</filename> file.  Notice
     that it writes its generated code in to the
     <varname>${abuild.private.dir.generated-jsrc}</varname>
     directory, which is what all code generators should do.  (For
     additional information about writing targets, see <xref
     linkend="ref.guidelines-for-ant-target-authors"/>.)  Our
     <command>generate</command> hook does not have to be concerned
     about any other details.  &Abuild; will call it automatically at
     the correct point in the build process.
    </para>
    <para>
     Next, look at the <classname>other-executable</classname> build
     item.  This build item actually contains no source code.  All it
     does is define the properties required to generate a wrapper
     script, but this time, it uses a different main class in the
     executable JAR file.  This build item serves primarily as an
     example of using the wrapper target, which is a post-package
     hook, from a build item that doesn't actually package anything.
     Here are its <filename>Abuild.conf</filename> and
     <filename>Abuild-ant.properties</filename> files:
     <?example java/other-executable/Abuild.conf?>
     <?example java/other-executable/Abuild-ant.properties?>
    </para>
   </sect1>
   <sect1 id="ref.example.build-driven-java">
    <title>Build.xml-driven Java Example</title>
    <para>
     In the directory <filename>java/alternative</filename>, you will
     find a build item that has a hand-coded ant build file,
     <filename>Abuild-ant.xml</filename>.  When &abuild; encounters
     this file, it invokes ant directly (<xref
     linkend="ref.abuild-ant.xml"/>).  If you examine the
     <filename>Abuild-ant.xml</filename> in this directory, you will
     notice that it defines a target <command>all</command> that
     builds everything that would ordinarily be required by its
     reverse dependencies.  It also defines the standard targets
     <command>test</command>, <command>check</command>, and
     <command>doc</command> that are expected to be present for all
     build items.  In addition, it defines its own special target
     <command>run</command> that runs the application.  Notice that
     the source path in the <command>java</command> element in this
     file is <filename>../src/java</filename>.  Since &abuild; invokes
     ant on this build file from inside the
     <filename>abuild-java</filename> output directory, all references
     to source paths must be prefixed by
     &ldquo;<filename>../</filename>&rdquo;:
     <?example java/alternative/Abuild-ant.xml?>
     Also observe that this build file loads the
     <filename>.ab-dynamic-ant.properties</filename> so that it can
     still benefit from classpath information as determined by the
     interfaces of its dependencies.  All
     <filename>Abuild-ant.xml</filename> files should do this.  This
     build item uses the property <varname>abuild.classpath</varname>,
     which comes from that file.  For a list of properties that will
     be defined in <filename>.ab-dynamic-ant.properties</filename>,
     see <xref linkend="ref.predefined-abuild.interface-variables"/>.
    </para>
    <para>
     At this time, it is uncertain what &abuild;'s final Java support
     will look like, but the use of
     <filename>Abuild-ant.xml</filename> is not recommended unless
     there is no other option.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.cross-platform-support">
   <title>Cross-Platform Support</title>
   <sect1 id="ref.platform-selection">
    <title>Platform Selection</title>
    <indexterm>
     <primary>platform selectors</primary>
    </indexterm>
    <para>
     When &abuild; starts up, it determines a list of object-code
     platform types and, within each platform type, a list of
     platforms.  Platforms are given initial priorities based on the
     order in which they are declared with later declarations having
     higher priority than earlier ones.  (In this way, platforms added
     by plugins are preferred over internally defined ones.)  By
     default, &abuild; builds each object-code build item on the
     highest priority platform in each of its platform types.
     &Abuild; may also choose to build an item on additional platforms
     to satisfy dependencies.
    </para>
    <para>
     The list of platforms on which &abuild; will attempt to build an
     item may be overridden using platform selectors.  Platform
     selectors may be specified in the
     <varname>ABUILD_PLATFORM_SELECTORS</varname> environment variable
     or on the command line using the
     <option>--platform-selector</option> or <option>-p</option>
     command-line flag.  Each platform selector may refer to a
     specific platform type or may be a general selector for all
     platform types.  There may be at most one selector for each
     platform type and at most one general selector.  If multiple
     selectors for the sample platform type or multiple general
     selectors are specified, &abuild; chooses the last one.
     Selectors given on the command line always take precedence over
     those in the environment variable.  This makes it possible for
     later options to override earlier ones or for the command line to
     override the environment.  To specify multiple selectors in the
     environment, set the variable to contain multiple space-separated
     words.  To specify multiple selectors on the command line,
     provide the command-line option more than once.  For example:

     <programlisting>--platform-selector <replaceable>selector</replaceable> [ --platform-selector <replaceable>selector</replaceable> ... ]
</programlisting>
     or

     <programlisting>ABUILD_PLATFORM_SELECTORS="<replaceable>selector</replaceable>[ <replaceable>selector</replaceable> ... ]"
</programlisting>
    </para>
    <para>
     Each selector is of the form

     <programlisting>[<replaceable>platform-type</replaceable>:]<replaceable>criteria</replaceable>
</programlisting>
    </para>
    <para>
     If no <replaceable>platform-type</replaceable> is specified, then
     the selector applies to all platform types.  When applying
     selectors, &abuild; will always first try a selector for the
     specific platform type first.  Only if there isn't one will
     &abuild; attempt to use the general selector.
    </para>
    <para>
     The <replaceable>criteria</replaceable> field above may have one
     of the following forms:
     <itemizedlist>
      <listitem>
       <para>
        <type>option=<replaceable>option</replaceable></type>
       </para>
      </listitem>
      <listitem>
       <para>
        <type>compiler=<replaceable>compiler</replaceable>[.<replaceable>option</replaceable>]</type>
       </para>
      </listitem>
      <listitem>
       <para>
        <type>platform=<replaceable>os</replaceable>.<replaceable>cpu</replaceable>.<replaceable>toolset</replaceable>.<replaceable>compiler</replaceable>[.<replaceable>option</replaceable>]</type>
       </para>
      </listitem>
      <listitem>
       <para>
        <type>all</type>
       </para>
      </listitem>
      <listitem>
       <para>
        <type>skip</type>
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     The special <type>skip</type> selector removes all platforms from
     the type and is not valid without a platform-type qualifier.
     When it is used, all platforms are removed from that platform
     type, so no builds will be done in that platform type for any
     reason.  This could be useful if you only wanted to do embedded
     builds, for example.
    </para>
    <para>
     The other selectors are translated into an (<type>os</type>,
     <type>cpu</type>, <type>toolset</type>, <type>compiler</type>,
     <type>option</type>) tuple.  Each field may be
     <literal>*</literal> or a platform field.  The empty string may
     not be explicitly specified, but omitted fields are mapped to the
     empty string.  For example, <type>compiler=x</type> is equivalent
     to (<type>""</type>, <type>""</type>, <type>""</type>,
     <type>"x"</type>, <type>""</type>).  Any empty string field
     except for <type>option</type> matches the corresponding field of
     the highest priority platform (the last one declared) in the list
     of platforms for the given type.  This is the always the first
     platform listed for the platform type by <command>abuild
     --list-platforms</command>.  An empty <type>option</type> field
     means that the <type>option</type> field of the platform must be
     empty.
    </para>
    <para>
     When picking platforms on which to build by default, &abuild;
     will always pick the first platform that matches the criteria.
     If there are no matches, it will pick the first platform of the
     platform type.  If any of the fields of the selector are equal to
     <literal>*</literal>, then &abuild; will select
     <emphasis>all</emphasis> platforms that match the criteria, again
     falling back to only the first platform in the type if there are
     no matches.
    </para>
    <para>
     Here are several examples.  For purposes of discussion, assume
     that we have the following platforms, shown here by type:
     <variablelist>
      <varlistentry>
       <term><type>vxworks</type></term>
       <listitem>
        <simplelist>
         <member><type>vxworks.ppc.6_3.vxgcc</type></member>
         <member><type>vxworks.x86.6_3.vxgcc</type></member>
         <member><type>vxworks.x86.6_3.vxgcc.debug</type></member>
        </simplelist>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>native</type></term>
       <listitem>
        <simplelist>
         <member><type>linux.x86.rhel4.xlc</type></member>
         <member><type>linux.x86.rhel4.xlc.debug</type></member>
         <member><type>linux.x86.rhel4.xlc.release</type></member>
         <member><type>linux.x86.rhel4.gcc</type></member>
         <member><type>linux.x86.rhel4.gcc.debug</type></member>
         <member><type>linux.x86.rhel4.gcc.release</type></member>
        </simplelist>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
    <para>
     If no platform selectors were provided, we would build native
     build items with <type>linux.x86.rhel4.xlc</type> and
     <type>vxworks</type> build items with
     <type>vxworks.ppc.6_3.vxgcc</type>.  Here are several platform
     selectors along with a description of what they mean:
     <variablelist>
      <varlistentry>
       <term><type>type=native:option=debug</type></term>
       <listitem>
        <para>
         on the native platform type, build with the first platform
         that has the <type>debug</type> option.  If none, build with
         the first platform regardless of its options.  (This is
         always the behavior when there are no platforms that fit the
         criteria, so this will not repeated for each example.)  In
         this case, we would build <type>native</type> items on
         <type>linux.x86.rhel4.xlc.debug</type>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>type=native:compiler=gcc.release</type></term>
       <listitem>
        <para>
         On the native platform type, build with compiler
         <type>gcc</type> with the <type>release</type> option.  In
         this case, that would be
         <type>linux.x86.rhel4.gcc.release</type>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>type=native:compiler=gcc</type></term>
       <listitem>
        <para>
         On the native platform type, build with <type>gcc</type> with
         no options, <type>linux.x86.rhel4.gcc</type>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>type=native:compiler=gcc.*</type></term>
       <listitem>
        <para>
         On the native platform type, build all <type>gcc</type>
         platforms with all options, including the <type>gcc</type>
         platform without any options.  That would include
         <type>linux.x86.rhel4.gcc</type>,
         <type>linux.x86.rhel4.gcc.debug</type>, and
         <type>linux.x86.rhel4.gcc.release</type>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>type=native:compiler=*.debug</type></term>
       <listitem>
        <para>
         On the native platform type, build all platforms that have
         the <type>debug</type> option:
         <type>linux.x86.rhel4.xlc.debug</type> and
         <type>linux.x86.rhel4.gcc.debug</type>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>type=native:compiler=*.*</type></term>
       <listitem>
        <para>
         On the native platform type, build all platforms:
         <type>linux.x86.rhel4.xlc</type>,
         <type>linux.x86.rhel4.xlc.debug</type>,
         <type>linux.x86.rhel4.xlc.release</type>,
         <type>linux.x86.rhel4.gcc</type>,
         <type>linux.x86.rhel4.gcc.debug</type>, and
         <type>linux.x86.rhel4.gcc.release</type>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>type=vxworks:platform=*.*.*.*.debug</type></term>
       <listitem>
        <para>
         On vxworks, build for all platforms that have the
         <type>debug</type> option:
         <type>vxworks.x86.6_3.vxgcc.debug</type>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>type=vxworks:platform=*.x86.*.*.*</type></term>
       <listitem>
        <para>
         On vxworks, build all platforms that have <type>x86</type> as
         the <type>cpu</type> field:
         <type>vxworks.x86.6_3.vxgcc</type> and
         <type>vxworks.x86.6_3.vxgcc.debug</type>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>type=vxworks:skip</type></term>
       <listitem>
        <para>
         Skip the vxworks platform type; no vxworks builds will be
         done under any circumstances.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>platform=*.*.*.*</type></term>
       <listitem>
        <para>
         For all otherwise unspecified platform types, build for all
         platforms that have an empty <type>option</type> field:
         <type>vxworks.ppc.6_3.vxgcc</type>,
         <type>vxworks.x86.6_3.vxgcc</type>,
         <type>linux.x86.rhel4.xlc</type>, and
         <type>linux.x86.rhel4.gcc</type>.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><type>platform=*.*.*.*.*</type></term>
       <listitem>
        <para>
         For all otherwise unspecified platform types, build for all
         platforms.  This is the same specifying the platform selector
         <type>all</type>.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </sect1>
   <sect1 id="ref.cross-platform-dependencies">
    <title>Cross-Platform Dependencies</title>
    <indexterm>
     <primary>dependency</primary>
     <secondary>cross-platform</secondary>
    </indexterm>
    <para>
     Ordinarily, when <classname>A</classname> depends on
     <classname>B</classname>, &abuild; requires that
     <classname>B</classname> be buildable on every platform that
     <classname>A</classname> is being built on.  In this case, the
     instance of <classname>A</classname> being built on platform
     <type>p</type> depends specifically on the instance of
     <classname>B</classname> being built on platform <type>p</type>.
     Under these rules, it would be impossible for
     <classname>A</classname> to depend on <classname>B</classname> if
     <classname>B</classname> couldn't be built on all of
     <classname>A</classname>'s platforms.  This would make it
     impossible for a platform-independent item to depend on any
     object-code or Java build items or for object-code and Java build
     items to depend on each other.  (There is a special case that any
     item can depend on a platform-independent build item.)  To make
     these other cases possible, &abuild; allows a dependency to
     declare a specific platform using the <option>-platform</option>
     flag.  Rather than declaring a platform by name, the argument to
     the <option>-platform</option> argument is either a platform type
     or a platform-type-qualified platform selector.  In this case,
     the instance of <classname>A</classname> on each of its platforms
     depends on the specifically selected instance of
     <classname>B</classname>.
    </para>
    <para>
     To choose which of <classname>B</classname>'s platforms will be
     used, &abuild; picks the first platform in the given type that
     matches the platform selector.  Matches are performed using the
     same technique as when platform selectors are specified on the
     command line with two exceptions: the <type>criteria</type> field
     may be omitted, and the selector only ever matches a single
     platform even if <literal>*</literal> appears as one of the
     fields.  Also, &abuild; ignores any platform specifiers given on
     the command line or in the environment when resolving
     cross-platform dependencies.  The rationale for this is that
     platform selectors specified on the command line or the
     environment should only ever affect what is actually built.  It
     should never affect the shape of the internal dependency graph.
     (For details on the internal, platform-aware dependency graph,
     see <xref linkend="ref.construction-of-build-graph"/>.)
    </para>
    <para>
     The other situation in which a build item may depend on another
     item with different platforms occurs with pass-through build
     items.  In this case, if <classname>A1</classname> and
     <classname>A2</classname> depend on pass-through item
     <classname>P</classname> which in turn depends on
     <classname>B1</classname> and <classname>B2</classname>, &abuild;
     will create effective dependencies between the
     <classname>A</classname>s and the <classname>B</classname>s based
     on platform type (see <xref linkend="fig.pass-through"/>).
     <figure id="fig.pass-through">
      <title>Multiplatform Pass-through Build Item</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="pass-through.png"/>
       </imageobject>
       <caption>
        <para>
         Pass-through item <classname>P</classname> effectively
         connects <classname>A1</classname> to
         <classname>B1</classname> and <classname>A2</classname> to
         <classname>B2</classname> based on their platform types.
        </para>
       </caption>
      </mediaobject>
     </figure>
     The documentation doesn't provide a specific example that
     illustrates that case because this type of usage would be fairly
     unusual.
     <footnote>
      <para>
       Okay, we don't provide an example because it's tricky to make
       one that would be more illustrative than confusing without an
       actual embedded platform to work with.  If we did create an
       example, we'd have to make up some kind of simulated embedded
       platform with a plugin, and that would probably create more
       confusion than it would be worth.
      </para>
     </footnote>
     Instead, we will provide a description of how it would work.
     Suppose you had a plugin to support VxWorks, an embedded
     operating system, that added a platform type
     <type>vxworks</type>, and you wanted to provide a custom
     threading library that worked for your native platform and for
     VxWorks.  Suppose also that your native library implementation
     used boost threads but that you wanted to create a VxWorks
     implementation that used VxWorks native threads.  You could
     create a pass-through build item called
     <classname>threads</classname> that depends on
     <classname>threads.native</classname> and
     <classname>threads.vxworks</classname>, and you could set up
     <classname>threads.native</classname> to have
     <property>platform-types</property> <type>native</type> and
     <classname>threads.vxworks</classname> to have
     <property>platform-types</property> <type>vxworks</type>.  The
     <classname>threads</classname> build item would not declare any
     platform types.  It would just depend on
     <classname>threads.vxworks</classname> and
     <classname>threads.native</classname>.  If you now had a program
     that supported both <type>native</type> and <type>vxworks</type>
     that depended on <classname>threads</classname>, your application
     would use the <classname>threads.native</classname>
     implementation when it built on the <type>native</type> platforms
     and the <classname>threads.vxworks</classname> implementation
     when it built on <type>vxworks</type> platforms.  This would
     happen transparently because of the pass-through build item.  To
     fully understand why this works, please see <xref
     linkend="ref.construction-of-build-graph"/>.  Note that you could
     also put conditionals in your
     <filename>Abuild.interface</filename> and/or
     <filename>Abuild.mk</filename> to avoid having to split this into
     multiple build items, so this is not the only solution.  The same
     trick would work if you wanted to create a facade for a library
     that was implemented in multiple languages, though it's unlikely
     that there would be any reason to do that: although you can have
     one build item that builds for multiple platform types, you can't
     have a single build item that builds for multiple languages.
    </para>
   </sect1>
   <sect1 id="ref.example.cross-platform-dependency">
    <title>Cross-Platform Dependency Example</title>
    <para>
     In the <filename>doc/example/cross-platform</filename> directory,
     there is a build tree that illustrates &abuild;'s ability to
     enhance dependency declaration with platform type or platform
     information.  In this example, we show a platform-independent
     code generator that calls a C++ program to do some of its work.
     We also show a program that uses this code generator.  We'll
     examine these build items from the bottom up in the dependency
     chain.  Our first several items are quite straightforward and are
     no different in how they work from what we've seen before.
    </para>
    <para>
     First, look at <filename>lib</filename>:
     <?example cross-platform/lib/Abuild.conf?>
     <?example cross-platform/lib/Abuild.mk?>
     <?example cross-platform/lib/Abuild.interface?>
     This build item defines a function <varname>f</varname> that
     returns the square of its integer argument.  Here is
     <filename>lib.cc</filename>:
     <?example cross-platform/lib/lib.cc?>
    </para>
    <para>
     Next, look at <filename>calculate</filename>:
     <?example cross-platform/calculate/Abuild.conf?>
     <?example cross-platform/calculate/Abuild.mk?>
     <?example cross-platform/calculate/calculate.cc?>
     This is a simple program that takes a number of arguments on the
     command line and prints tab-delimited output with the number in
     column 1 and the square of the number in column 2.  It uses the
     <function>f</function> function in <classname>lib</classname> to
     do the square calculation, and therefore depends on the
     <classname>lib</classname> build item.
    </para>
    <para>
     So far, we haven't seen anything particularly unusual in this
     example, but this is where it starts to get interesting.  The
     material here is tricky.  To follow this, you need to remember
     that variables set in <filename>Abuild.interface</filename> files
     of build items you depend on are available to you as
     <application>make</application> variables.  We can use
     <application>make</application>'s <function>export</function>
     command to make those variables available in the environment.
    </para>
    <para>
     The <classname>calculate</classname> build item exports the name
     of its program in an interface variable in its
     <filename>Abuild.interface</filename> file by creating a variable
     called <varname>CALCULATE</varname>:
     <?example cross-platform/calculate/Abuild.interface?>
     As with all interface variables, this will be available as a make
     variable within <filename>Abuild.mk</filename>.  It also includes
     the <function>after-build</function> file
     <filename>after.interface</filename>:
     <?example cross-platform/calculate/after.interface?>
     This file protects the <varname>CALCULATE</varname> variable from
     being reset, and then calls <function>reset-all</function>.  In
     this way, items that depend on <classname>calculate</classname>
     will not automatically inherit the interface from
     <classname>lib</classname> or any of its dependencies.  This
     represents the intention that a dependency on the
     <classname>calculate</classname> build item would be set up if
     you wanted to <emphasis>run</emphasis> the
     <filename>calculate</filename> program rather than to link with
     or include header files from the libraries used to build
     <classname>calculate</classname>.  In other words, we treat
     <classname>calculate</classname> as a black box and don't care
     how it was built.  This works because the
     <varname>CALCULATE</varname> variable, which contains the name of
     the <filename>calculate</filename> program, was protected from
     reset, but the <varname>LIBS</varname>,
     <varname>LIBDIRS</varname>, and <varname>INCLUDES</varname>
     variables have been cleared.  In that way, a user of the
     <classname>calculate</classname> build item won't link against
     the <filename>lib</filename> library or be able to include the
     <filename>lib.hh</filename> header file unless they had also
     declared a dependency on <classname>lib</classname>.  If we
     hadn't cleared these variables, any code that depended on the
     <classname>calculate</classname> build item may well still have
     worked, but it would have had some excess libraries, include
     files, and library directories added to its compilation commands.
     In some cases, this could create unanticipated code dependencies,
     expose you to namespace collisions, or cause unwanted static
     initializers to be run.
    </para>
    <para>
     Next, look at the <classname>codegen</classname> build item.
     This build item runs a code generator,
     <filename>gen_code.pl</filename>, which in turn runs the
     <filename>calculate</filename> program.  We provide the name of
     our code generator in the <filename>Abuild.interface</filename>
     file:
     <?example cross-platform/codegen/Abuild.interface?>
     This build item provides a <filename>Rules.mk</filename> for
     creating a file called <filename>generate.cc</filename>.  It
     calls the <filename>gen_code.pl</filename> program, which it
     finds using the <varname>CODEGEN</varname> interface variable, to
     do its job.  The <filename>gen_code.pl</filename> program uses
     the <envar>CALCULATE</envar> environment variable to find the
     actual calculate program.  Although we have the
     <varname>CALCULATE</varname> variable as a make variable
     (initialized from <classname>calculate</classname>'s
     <filename>Abuild.interface</filename> file), we need to export it
     so that it will become available in the environment.  We also
     pass the file named in the <varname>NUMBERS</varname>
     variable to the code generator.  Here are the
     <filename>Rules.mk</filename> file and the code generator:
     <?example cross-platform/codegen/Rules.mk?>
     <?example cross-platform/codegen/gen_code.pl?>
     In order for this to work, the <classname>codegen</classname>
     build item must depend on the <classname>calculate</classname>
     build item.  Ordinarily, &abuild; will not allow this since the
     <classname>calculate</classname> build item would not be able to
     be built on the <type>indep</type> platform, which is the only
     platform on which <classname>codegen</classname> is built.  To
     get around this, <classname>codegen</classname>'s
     <filename>Abuild.conf</filename> specifies a
     <option>-platform</option> argument to its declaration of its
     dependency on <classname>calculate</classname>:
     <?example cross-platform/codegen/Abuild.conf?>
     The argument <option>-platform=native:option=release</option>
     tells &abuild; to make <classname>codegen</classname> depend on
     the instance of <classname>calculate</classname> built on the
     first <type>native</type> platform that has the
     <type>release</type> option, if any; otherwise, it depends on the
     highest priority <type>native</type> platform.  Note that this
     will cause the <type>release</type> option of the appropriate
     platform to be built for <classname>calculate</classname> and its
     dependencies even if they would not have otherwise been built.
     This is an example of &abuild;'s ability to build on additional
     platforms on an as-needed basis.  For details on exactly how
     &abuild; resolves such dependencies, see <xref
     linkend="ref.construction-of-build-graph"/>.
    </para>
    <para>
     Notice that this code generator uses an interface variable, in
     this case <varname>$(CALCULATE)</varname>, to refer to a file in
     the <classname>calculate</classname> build item.  Not only is
     this a best practice since it avoids having us have to know the
     location of a file in another build item, but it is actually the
     only way we can find the <filename>calculate</filename> program:
     &abuild; doesn't provide any way for us to know the name of the
     output directory from the <classname>calculate</classname> build
     item we are using except through the interface system.  (The
     value of the <varname>ABUILD_OUTPUT_DIR</varname> variable would
     be the output directory for the item currently being built, not
     the output directory that we want from the
     <classname>calculate</classname> build item.)  We also use an
     interface variable to refer to the code generator within our own
     build item, though in this case, it would not be harmful to use
     <varname>$(abDIR_codegen)/gen_code.pl</varname> instead.
     <footnote>
      <para>
       Actually, there is something a bit more subtle going on here.
       If we didn't have an <filename>Abuild.interface</filename> file
       or an <filename>Abuild.mk</filename> file, &abuild; would not
       allow this build item to declare a platform type, and it would
       automatically inherit its platform type from its dependency or
       become a special build item of platform type <type>all</type>,
       as discussed in <xref
       linkend="ref.construction-of-build-graph"/>.  In that case,
       &abuild; would not allow us to declare a platform-specific
       dependency, and although the code generator would still work
       just fine, this wouldn't be much of an example!  The construct
       illustrated here is still useful though as this is exactly how
       it would have to work if there were other values to be exported
       through <filename>Abuild.interface</filename> or any products
       that needed to be built by this build item itself.  For
       example, if the code generator example had been written in Java
       instead of perl, this pattern would have been the only way to
       achieve the goal.
      </para>
     </footnote>
    </para>
    <para>
     Finally, look at the <classname>prog</classname> build item.
     This build item depends on the <classname>codegen</classname>
     build item.  Its <filename>Abuild.mk</filename> defines the
     <varname>NUMBERS</varname> variable as required by
     <classname>codegen</classname>, which it lists in its
     <varname>BUILD_ITEM_RULES</varname> variable.  This build item
     doesn't know or care about the interface of the
     <classname>lib</classname> build item, which has been hidden from
     it by the <function>reset-all</function> in
     <classname>calculate</classname>'s
     <filename>after.interface</filename>.  (If it wanted to, it could
     certainly also depend on <classname>lib</classname>, in which
     case it would get <classname>lib</classname>'s interface.)  In
     fact, running <command>abuild ccxx_debug</command> will show that
     <classname>prog</classname>'s <varname>INCLUDES</varname>,
     <varname>LIBS</varname>, and <varname>LIBDIRS</varname> variables
     are all empty:
     <?qtest example.cross-platform-ccxx_debug.out?>
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.build-item-visibility">
   <title>Build Item Visibility</title>
   <para>
    By default, build items are allowed to refer to other build items
    directly in their <filename>Abuild.conf</filename> files subject
    to certain scoping rules as described in <xref
    linkend="ref.build-item-name-scoping"/>.  In some rare instances,
    in order to resolve a conflict between what a given build item is
    supposed to be able to see and which items a given item is
    supposed to be seen by, it is necessary to increase the visibility
    of a build item.  In this chapter, we describe a mechanism for
    doing this and present a real-world example in which it would be
    required.
   </para>
   <sect1 id="ref.overriding-visibility">
    <title>Increasing a Build Item's Visibility</title>
    <para>
     The <filename>Abuild.conf</filename> file supports an optional
     <property>visible-to</property> key has a value consisting of a
     single scope identifier.  It may have one of the following two
     forms:
     <itemizedlist>
      <listitem>
       <para>
        <classname>ancestor-scope.*</classname>: the current build
        item is visible to all build items under the named
        ancestor-scope.  The ancestor-scope must be at or above the
        &ldquo;grandparent&rdquo; of the current build item since
        build items belong by default to the scope named by the parent
        build item.
       </para>
      </listitem>
      <listitem>
       <para>
        <classname>*</classname>: this build item may be seen by any build
        item.
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     For example, if the item <classname>A.B.C</classname> declared
     itself as visible to <classname>A.*</classname>, then the items
     <classname>A.P</classname>, <classname>A.Q.R</classname>, or
     anything else under <classname>A</classname> would be allowed to
     access it directly.  Even though it is hidden beneath
     <classname>A.B</classname>, access to it would be checked as if
     it were directly under <classname>A</classname>.  The
     <classname>A.B.C</classname> build item would increase its
     visibility by adding this line to its
     <filename>Abuild.conf</filename>:

     <programlisting>visible-to: A.*
</programlisting>
    </para>
    <indexterm>
     <primary>dependency</primary>
     <secondary>one-way gates</secondary>
    </indexterm>
    <para>
     Here we describe a more concrete example.  The next section
     demonstrates an actual implementation of the pattern described
     here.  Suppose you needed to implement a project that contained
     build items at different levels of classification, which we'll
     call <emphasis>public</emphasis> and
     <emphasis>sensitive</emphasis>.  We want the sensitive build
     items to be able to see the public ones, but the public ones
     should never be allowed to see the sensitive ones.  To achieve
     this, we create an public build tree and a sensitive build tree,
     and then we have the sensitive build tree list the public build
     tree as an external area.  The explanation that follows refers to
     <xref linkend="fig.build-item-visibility"/>.
     <figure id="fig.build-item-visibility">
      <title>Build Item Visibility</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="build-item-visibility.png"/>
       </imageobject>
       <caption>
        <para>
         <classname>B.sensitive</classname> can see
         <classname>B.W</classname> and <classname>B.X</classname>
         because of its scope.  <classname>B.sensitive</classname> can
         be seen by <classname>A.sensitive</classname> because of its
         visibility.
        </para>
       </caption>
      </mediaobject>
     </figure>
     Suppose you have software components <classname>A</classname> and
     <classname>B</classname> and that <classname>A</classname>
     depends on <classname>B</classname>.  Let's say that
     <classname>B</classname> has two public subcomponents called
     <classname>B.Q</classname> and <classname>B.R</classname> and
     that <classname>B</classname>'s <filename>Abuild.conf</filename>
     declares those as dependencies, making it a facade build item for
     its subcomponents.  When <classname>A</classname> depends on
     <classname>B</classname>, it will automatically get
     <classname>B.Q</classname>'s and <classname>B.R</classname>'s
     interfaces through <classname>B</classname>'s dependency on them.
     Now suppose that both <classname>A</classname> and
     <classname>B</classname> have some additional subcomponents that
     are sensitive.  In order to avoid having the public items even
     know that the sensitive items exist and to prevent them from ever
     accidentally depending on them even when they are being modified
     in a sensitive environment, we add sensitive subcomponents to
     <classname>A</classname> and <classname>B</classname> in a
     completely separate build tree.  Suppose <classname>B</classname>
     has sensitive subcomponents <classname>B.W</classname> and
     <classname>B.X</classname>.  Those need to be under the scope
     <classname>B</classname> so that they can see
     <classname>B.Q</classname> and <classname>B.R</classname>.  Now
     we can create a facade build item called
     <classname>B.sensitive</classname> that depends on
     <classname>B</classname> and also on <classname>B.W</classname>
     and <classname>B.X</classname>.  Then anyone who depends on
     <classname>B.sensitive</classname> can see all four subcomponents
     of <classname>B</classname>.  Suppose we have a sensitive version
     of <classname>A</classname> called
     <classname>A.sensitive</classname>.  Unfortunately, by our normal
     scoping rules, <classname>A.sensitive</classname> would not be
     allowed to depend on <classname>B.sensitive</classname> because
     <classname>B.sensitive</classname> would be hidden beneath
     <classname>B</classname>.  We can't move
     <classname>B.sensitive</classname> out of
     <classname>B</classname> (by calling it something like
     <classname>B_sensitive</classname>, for example) since then it
     would not be able to depend on <classname>B.W</classname> and
     <classname>B.X</classname>.  Instead, we have to have
     <classname>B.sensitive</classname> make itself globally visible
     by adding <literal>visible-to: *</literal> to its
     <filename>Abuild.conf</filename>.  Now any build item that can
     resolve its name, which by design means only build items in the
     sensitive build tree, can declare a dependency directly on
     <classname>B.sensitive</classname>.  That way, the public
     <classname>A</classname> build item depends on the public
     <classname>B</classname> build item, and the sensitive
     <classname>A.sensitive</classname> build item depends on the
     sensitive <classname>B.sensitive</classname> build item, and all
     constraints are satisfied.  This pattern can be useful whenever
     an external area is used to add new private subcomponents to
     something defined in a different build tree.  In this case, the
     use of an external tree creates what is effectively a
     <firstterm>one-way dependency gate</firstterm>: items in the
     sensitive tree can see items in the public tree, but items in the
     public tree can't see items in the sensitive tree.  The next
     section demonstrates an actual implementation of this pattern.
    </para>
   </sect1>
   <sect1 id="ref.example.mixed-classification">
    <title>Mixed Classification Example</title>
    <para>
     This example shows a sample implementation of how one might solve
     certain development problems in a mixed classification
     development environment.  To avoid any potential confusion, we'll
     call our two classification levels &ldquo;public&rdquo; and
     &ldquo;sensitive.&rdquo;.  These could correspond to different
     levels of protection of information and could apply to any
     environment in which people have to be granted special access in
     order to use parts of a system.
    </para>
    <para>
     In this example, we'll demonstrate a very simple message
     processing system.  When a message is received, it is processed
     by a <firstterm>message processor</firstterm> and then dispatched
     to a series of <firstterm>message consumers</firstterm>.  Our
     system allows message consumers to be registered with a special
     message consumer table.  Each message consumer is passed a
     reference to a message processor.  Then, for each message, each
     consumer processes the message with the message processor and
     then does whatever it needs to do with the results.
    </para>
    <para>
     In the public version of the system, we have some message
     consumers and a message processor.  In the sensitive version of
     the system, we want access to the public consumers, but we also
     want to register some additional consumers that are only allowed
     to work in the sensitive environment.  In addition, we want to be
     able to replace the message processor with a different
     implementation such that even the public consumers can operate on
     the messages after processing them with the sensitive processor.
     Furthermore, we wish to be able to achieve these goals with as
     little code duplication as possible and without losing the
     ability to run the public version of the system even when
     operating in the sensitive environment as this may be important
     for testing the system.  We also wish to protect ourselves
     against ever accidentally creating a dependency from a public
     implementation to a sensitive implementation of any part of the
     system.
    </para>
    <para>
     In our sample implementation, each message is an integer, and the
     message processor receives the integer as input and returns a
     string.  Rather than having &ldquo;messages&rdquo; actually be
     &ldquo;received&rdquo;, we just accept integers on the command
     line and pass them through the process/consume loop in the
     system.
    </para>
    <para>
     This example may be found in
     <filename>doc/example/mixed-classification</filename>.  The
     public code is in the <filename>public</filename> subdirectory,
     and the sensitive code is in the <filename>sensitive</filename>
     subdirectory.  The example is implemented in Java, but there is
     nothing about it that wouldn't work the same way in C or C++.  We
     will study the <filename>public</filename> area first.
    </para>
    <para>
     In this example, we have a library of consumers and an executable
     program that calls each registered consumer the numbers passed in
     on the command line.  The consumers each call the processor
     function through an interface, an instance of which is passed to
     the consumer with each message.  The public version of consumer
     library includes two consumers.  In order for us to allow the
     sensitive version to add two more consumers and provide a new
     processor that completely replaces the one defined in the public
     version, the processor function's interface and implementation
     are separated as we will describe below.
    </para>
    <para>
     There are several things to note about the dependencies and
     directory layout.  First, observe that the Java
     <classname>Processor</classname> class defined in the
     <classname>processor</classname> build item implements a
     Java interface (not to be confused with an &abuild; interface)
     that is actually defined in the
     <classname>consumers.interface</classname> build item in
     the <filename>consumers/interface</filename> directory.
     Here is the interface from the
     <classname>consumers.interface</classname> build itme:
     <?example mixed-classification/public/consumers/interface/src/java/com/example/consumers/ProcessorInterface.java?>
     Here is its implementation from the
     <classname>processor</classname> build item:
     <?example mixed-classification/public/processor/src/java/com/example/processor/Processor.java?>
     This means that the <classname>processor</classname>
     build item depends on <classname>consumers</classname>
     and the <classname>consumers</classname> build items do
     not depend on <classname>processor</classname>.  This
     helps enforce that the implementation of the processor function
     can never be a dependency of the consumers (as that would create
     a circular dependency), thus allowing it to remain completely
     separate from the consumer implementations.
     <?example mixed-classification/public/processor/Abuild.conf?>
     <?example mixed-classification/public/consumers/Abuild.conf?>
     The consumers
     themselves accept a <classname>ProcessorInterface</classname>
     instance as a parameter, as you can see from the consumer
     interface:
     <?example mixed-classification/public/consumers/interface/src/java/com/example/consumers/Consumer.java?>
    </para>
    <para>
     Next we will study the executable.  If you look at the
     <classname>executable</classname> build item, you will observe that
     it depends on <classname>processor</classname> and
     <classname>executable.entry</classname>:
     <?example mixed-classification/public/executable/Abuild.conf?>
     Its <filename>Main.java</filename> is very minimal: it just
     invokes <varname>Entry.runExecutable</varname> passing to it an
     instantiated <classname>Processor</classname> object and
     whatever arguments were passed to <varname>main</varname>:
     <?example mixed-classification/public/executable/src/java/com/example/executable/Main.java?>
     It is important to keep this main routine minimal because we will
     have to have a separate main in the sensitive area as that is the
     only way we can have the sensitive version of the code register
     sensitive consumers prior to calling <function>main</function>.
     <footnote>
      <para>
       Well, it's not really the only way.  You could also do
       something like having a
       <classname>RegisterConsumers</classname> object that both
       versions of the code would implement and provide in separate
       jar files much as we do with the
       <classname>Processor</classname> object.  One reason for doing
       it this way, though, is that it makes the example easier to map
       to languages with static linkage.  In other words, we're trying
       to avoid doing anything that would only work in Java to make
       the example as illustrative as possible.  This is, after all,
       not a Java tutorial.
      </para>
     </footnote>
     If this were C++, the inclusion of the sensitive consumers would
     be achieved through linking with additional libraries.  In Java,
     it is achieved by adding additional JAR files to the classpath.
     In either case, with &abuild;, it is achieved by simply adding
     additional dependencies to the build item.  We will see this in
     more depth when we look at the sensitive version of the code.
    </para>
    <para>
     Turning our attention to the public
     <classname>executable.entry</classname> build item, we can see
     that our <filename>Entry.java</filename> file has a static
     initializer that registers our two consumers,
     <varname>C1</varname> and <varname>C2</varname>:
     <footnote>
      <para>
       If this were a C++ program and portability to Windows were not
       required, we could omit this static initializer block entirely
       and put the static initializers in <varname>C1</varname> and
       <varname>C2</varname> themselves as long as we used the whole
       archive flag (see <xref linkend="ref.example.whole-library"/>)
       with those libraries.  As with C++, however, there is no clean
       and portable way to force static initializers to run in a class
       before the class is loaded.
      </para>
     </footnote>
     <?example mixed-classification/public/executable/entry/src/java/com/example/executable/entry/Entry.java?>
     Even though no place else in the code has to know about
     <varname>C1</varname> and <varname>C2</varname> specifically, we
     do have to register them explicitly with the table of consumers
     so that the rest of the application can use them.  The main
     <varname>runExecutable</varname> function parses the command-line
     arguments and then passes each one along with the
     <classname>Processor</classname> object to each consumer in turn.
     Adding additional consumers would entail just making sure that
     they are registered.  Observe in the source to one of the
     consumers how we register the consumer in the consumer table:
     <?example mixed-classification/public/consumers/c1/src/java/com/example/consumers/c1/C1.java?>
     The consumer table is a simple vector of consumers:
     <?example mixed-classification/public/consumers/interface/src/java/com/example/consumers/ConsumerTable.java?>
    </para>
    <para>
     Now we will look at the sensitive version of the code.  We have
     the same three subdirectories in <filename>sensitive</filename>
     as in <filename>public</filename>.  In our
     <filename>consumers</filename> directory, we define new consumers
     <varname>C3</varname> and <varname>C4</varname>.  They are
     essentially identical to the public consumers
     <varname>C1</varname> and <varname>C2</varname>.  The
     <filename>processor</filename> directory defines the sensitive
     version of the <classname>Processor</classname> class:
     <?example mixed-classification/sensitive/processor/src/java/com/example/processor/Processor.java?>
     Note that the class name is the same as in the public version,
     which means that the public and sensitive versions cannot be used
     simultaneously in the same executable.  Also observe that the
     name of the build item is actually
     <classname>processor.sensitive</classname>, to make it different
     from <classname>processor</classname>, and that the build item
     sets its visibility to <varname>*</varname> so that it can be a
     dependency of the sensitive version of the executable:
     <?example mixed-classification/sensitive/processor/Abuild.conf?>
     In this particular example, there's no reason that we couldn't
     have given the build item a public name as there are no
     subcomponents of the public
     <classname>processor</classname> build item that the
     sensitive one needs.  In a real situation, perhaps this would be
     the real <classname>processor</classname> build item and
     the public one would be called something like
     <classname>processor-stub</classname>.  In any case, all
     &abuild; cares about is that the build items have different
     names.
    </para>
    <para>
     Looking at the sensitive version of the executable, we can
     observe that there is no separate sensitive version of the
     <varname>Entry</varname> class.  This effectively means that we
     are using the public main routine even though we have sensitive
     consumers.  This provides an example of how to implement the case
     that people might be inclined to implement by having conditional
     inclusion of sensitive JAR files or conditional linking of
     sensitive libraries.  Since &abuild; doesn't support doing
     anything conditionally upon the existence of a build item or even
     testing for the existence of a build item, this provides an
     alternative approach.  This approach is actually better because
     it enables the public version of the system to run intact even in
     the sensitive environment.  After all, if the system
     <emphasis>automatically</emphasis> used the sensitive handlers
     whenever they were potentially available, we couldn't run the
     public version of the test suite in the sensitive environment.
     This would make it too easy, while working in the sensitive
     environment, to make modifications to the system that break the
     system in a way that would only be visible in the public version.
     By pushing what would have been <function>main</function> into a
     library, we can avoid duplicating the code.  If you look at the
     actual build item and code in the <filename>executable</filename>
     directory, you will see that the build item is called
     <classname>executable.sensitive</classname> and that it depends
     on <classname>consumers.sensitive</classname> and
     <classname>processor.sensitive</classname>, both of which have
     made themselves visible to <varname>*</varname> in their
     respective <filename>Abuild.conf</filename> files.  We saw
     <classname>processor.sensitive</classname>'s
     <filename>Abuild.conf</filename> file above.  Here is
     <classname>consumers.sensitive</classname>'s
     <filename>Abuild.conf</filename>:
     <?example mixed-classification/sensitive/consumers/Abuild.conf?>
     Also observe that <classname>executable.sensitive</classname>
     depends on <classname>executable.entry</classname> just like the
     public version of the executable did:
     <?example mixed-classification/sensitive/executable/Abuild.conf?>
     Looking at the sensitive executable's
     <filename>Main.java</filename>, we can see that it is essentially
     identical to the public version except that it registers some
     additional consumers that were not available in the public
     version:
     <?example mixed-classification/sensitive/executable/src/java/com/example/executable/Main.java?>
    </para>
    <para>
     Here are some key points to take away from this:
     <itemizedlist>
      <listitem>
       <para>
        This example illustrates that it is possible to extend
        functionality in an area that uses the original area as an
        external build tree with very little duplication of code.  This
        is partially achieved by thinking about our system in a
        different way: rather than having a public program behave
        differently in a sensitive environment, we move the main entry
        point into a library.  This completely eliminates the whole
        problem of conditional linking or making any other decisions
        conditionally upon the existence of particular build items or
        upon compile-time flags that differ across different
        environments.
       </para>
      </listitem>
      <listitem>
       <para>
        This example shows an approach to separating interfaces from
        implementations that makes it possible, without conflict, to
        completely replace an implementation at runtime.  This is
        achieved by having the implementation be a dependency of the
        final executable and having the rest of the system depend on
        only the interfaces.
       </para>
      </listitem>
      <listitem>
       <para>
        Although, in this example, the sensitive versions of the
        consumers don't actually access any private build items from
        the public version of the code, the use of the build item name
        <classname>consumers.sensitive</classname> and the
        <varname>visible-to</varname> key would make it possible for
        them to do so.
       </para>
      </listitem>
      <listitem>
       <para>
        Creating run-time connections between objects without creating
        any compile-time connections requires some additional
        infrastructure to be laid.  In some languages and compilation
        environments, this can be done through use of static
        initializers combined with techniques to ensure that they get
        run even if there are no explicit references to the classes in
        question.  To keep things both simple and portable, it is
        still possible to use this pattern by performing some explicit
        registration step prior to the invocation of the main routine.
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.java-archive-types">
   <title>JARs and Other Archives</title>
   <para>
    In this example, we demonstrate how to create different types of
    archive types in Java.  The actual contents of these archives are
    not necessarily valid for production, and these patterns do not
    necessarily reflect realistic dependencies among different archive
    types, but they do serve to illustrate how &abuild; handles
    different archive types in a fairly general way.
    <note>
     <para>
      Creation of Java archives is a weak point of &abuild; at this
      time.  Suggestions about how to improve this are actively
      encouraged.
     </para>
    </note>
   </para>
   <sect1 id="ref.example.jar-like-archives">
    <title>JAR-like Archives</title>
    <para>
     In the <filename>doc/example/archive-types</filename> directory,
     you will find subdirectories for each of several archive types.
     &Abuild; knows how to create JAR files, WAR files, and EAR files.
     The names of the archives that &abuild; creates do not have to
     end with the suffix corresponding to the type.  In particular,
     &abuild; is able to create JAR files that are not called
     <filename>*.jar</filename> as is necessary in some instances.
     When it does, it will also create a copy of that file whose name
     does end in <filename>.jar</filename> for compilation purposes as
     some versions of <command>javac</command> ignore classpath
     elements that are not either directories or files whose names end
     with <filename>.zip</filename> or <filename>.jar</filename>, a
     behavior that is consistent with the documentation.
    </para>
    <para>
     Start by looking at the HAR example.  If you study its
     <filename>Abuild-ant.properties</filename> file and its
     <filename>Abuild.interface</filename> file, you will observe that
     we are creating a HAR file here exactly the way we would create a
     JAR file except that we are using the <filename>.har</filename>
     suffix:
     <?example archive-types/har/Abuild-ant.properties?>
     <?example archive-types/har/Abuild.interface?>
     Note that the HAR file created here probably wouldn't work as a
     HAR (hibernate archive) file.  We're just naming it this way for
     purposes of illustration.  If you needed to add other things to
     the HAR file, you would do so in the same way as you would for
     any other JAR file (adding to <filename>src/conf</filename>,
     <filename>src/resources</filename>, or their automatically
     generated counterparts as appropriate).  Here are the contents of
     the HAR file:
     <?qtest example.har-contents.out?>
     Note that the <filename>META-INF</filename> directory and the
     <filename>MANIFEST.MF</filename> file are created automatically
     during the JAR creation process.  Next, look at the JAR example.
     It is essentially identical to the HAR example except that this
     build item depends on <classname>har-example</classname>:
     <?example archive-types/jar/Abuild-ant.properties?>
     <?example archive-types/jar/Abuild.interface?>
     The <filename>JarExample.java</filename> class imports a class
     defined in the HAR file to illustrate that it works in &abuild;
     to add a HAR file to the <varname>abuild.classpath</varname>
     variable even if it wouldn't work in straight ant.  This is
     because &abuild; is creating a file whose ends with
     <filename>.har.jar</filename> and is adding that to the real
     classpath instead.  Here are the contents of the JAR file:
     <?qtest example.jar-contents.out?>
    </para>
   </sect1>
   <sect1 id="ref.example.war-files">
    <title>WAR Files</title>
    <para>
     Next, look at the WAR (web archive) example.  The structure of
     WAR files is slightly different from the structure of ordinary
     JAR files.  In particular, when constructing a WAR file, the
     <filename>src/resources</filename> directory is ignored and the
     <filename>src/web</filename> directory is used instead.  Anything
     in <filename>src/web</filename> is added to the WAR file at its
     root, just as with <filename>src/resources</filename> for a JAR
     file.  Other than the name, there is no difference between how
     these directories are used.  Additionally, the
     <filename>src/conf</filename> directory is used to populate the
     <filename>WEB-INF</filename> directory in the WAR rather than the
     <filename>META-INF</filename>.  At present, there is no way to
     add files to <filename>META-INF</filename> other than manually
     creating a <filename>META-INF</filename> directory under
     <filename>src/web</filename>.  (The
     <filename>MANIFEST.MF</filename> file is created automatically by
     the <command>jar</command> task.)  Another difference is that
     compiled classes go in <filename>WEB-INF/classes</filename>
     instead of at the root as with a normal JAR file.
    </para>
    <para>
     If the <varname>abuild.war-type</varname> property in
     <filename>Abuild-ant.properties</filename> has the value
     <varname>server</varname>, we copy all JAR files in the
     <varname>abuild.classpath</varname> variable into the
     <filename>WEB-INF/lib</filename> directory.  If
     <varname>abuild.war-type</varname> has the value
     <varname>client</varname>, they are copied into the root of the
     WAR file.  Before copying the JAR files from the classpath into
     the WAR file, &abuild; places them in the
     <filename>abuild-java/classpath</filename> directory.  If you
     need to create a WAR file that includes files from
     <varname>abuild.classpath</varname> both at the root and in the
     <filename>WEB-INF/lib</filename> directory, create a
     <varname>client</varname> WAR file and use a
     <command>pre-package</command> hook to move some of the files
     from <filename>classpath</filename> into
     <filename>src/conf/lib</filename> (remember that both of these
     paths are relative to the output directory, which is directory
     from which <application>ant</application> is run) so that they
     will end up in <filename>WEB-INF/lib</filename>.  The EAR example
     includes a demonstration of using a
     <command>pre-package</command> hook for manipulating the contents
     of the <filename>classpath</filename> directory:
     <?example archive-types/war/Abuild-ant.properties?>
     <?example archive-types/war/Abuild.interface?>
     Here are the contents of this server WAR file:
     <?qtest example.war-contents.out?>
     The <classname>client-war</classname> example is identical except
     it creates a client WAR instead:
     <?example archive-types/client-war/Abuild-ant.properties?>
     <?example archive-types/client-war/Abuild.interface?>
     Here are its contents:
     <?qtest example.client-war-contents.out?>
     In this example, the <classname>war-example</classname> build
     item depends on the <classname>jar-example</classname> build item
     which in turn depends on <classname>har-example</classname>.
     Notice that &abuild; has added
     <filename>har-example.har.jar</filename> to the WAR file instead
     of adding <filename>har-example.har</filename>.  This, again, is
     to work around the fact that <command>javac</command> ignores
     classpath elements that are files whose names don't end with
     <filename>.jar</filename> or <filename>.zip</filename>.  This
     behavior may change if it turns out to be incorrect.  Another
     thing to observe about the WAR example is that it adds its WAR
     file to the <varname>abuild.classpath</varname> variable.  This
     is another thing that may change in the future.  It's not really
     accurate to say that the WAR file is in the classpath, but for
     the time being at least, this is the mechanism used for
     population of EAR files.  &Abuild; will attempt to add
     <filename>war-example.war.jar</filename> to the classpath of
     build items that depend on <filename>example-war</filename>, but
     since this file won't exist during EAR creation (as the appending
     of <filename>.jar</filename> happens only during compilation), it
     turns out to be harmless.  It's possible that an error might
     result if a WAR file depends on another WAR file, but there's no
     reason for this to ever happen.  Additionally, observe that the
     <varname>abuild.web-xml</varname> property has to be set in the
     <filename>Abuild-ant.properties</filename> file in addition to
     the <filename>abuild.war-name</filename> property when creating
     WAR files.
    </para>
   </sect1>
   <sect1 id="ref.example.ear-files">
    <title>EAR Files</title>
    <para>
     Next, look at the EAR example.  The
     <classname>ear-example</classname> build item directly or
     indirectly depends on many of the other build items we've seen so
     far.  It also depends on a private build item,
     <filename>ear-example.local-jar</filename> that builds a JAR file
     for inclusion in the EAR file.  There's nothing special about
     this, but making it a private build item inside of
     <classname>ear-example</classname> makes it clear that it is
     private to the EAR file:
     <?example archive-types/ear/Abuild.conf?>
     <?example archive-types/ear/Abuild-ant.properties?>
     Unlike with WAR files, EAR files actually contain the direct
     products produced by other build items, not their JAR
     counterparts: notice that the HAR and WAR files are directly
     contained in the EAR file:
     <?qtest example.ear-contents.out?>
     Note also that the EAR file contains the WAR file and it also
     directly contains some of its contents, notably the JAR and HAR
     files.  (The HAR file is included in the WAR by a different name;
     the JAR file is included with the same name.)  This behavior may
     change in the future.  Also, observe that the
     <varname>abuild.application-xml</varname> property has to be set
     in <filename>Abuild-ant.properties</filename> in addition to the
     <varname>abuild.ear-name</varname> property in order for an EAR
     to be created.
    </para>
    <para>
     Suppose you wanted to avoid inclusion of just the
     <filename>jar-example.jar</filename> file from the EAR file.  You
     can do this by creating a local <command>pre-package</command>
     hook that removes it from the <filename>classpath</filename>
     directory.  To illustrate this, we have a second EAR example in
     the <filename>other-ear</filename> directory.  It defines a local
     build file and enables local hooks.  Here is its
     <filename>Abuild-ant.properties</filename> file:
     <?example archive-types/other-ear/Abuild-ant.properties?>
     This file refers to the local build file
     <filename>local.xml</filename>:
     <?example archive-types/other-ear/local.xml?>
     This same mechanism can be used to create hybrid client/server
     WAR files.  The main problem with this approach is that it
     requires you to know the name of the archives you want to move or
     remove, though this is not as bad as knowing their locations.  A
     comparable alternative would be to define custom interface
     variables in your dependencies to name the actual archives.
     These interface variables would be available as
     <application>ant</application> properties from your local build
     file.
    </para>
    <para>
     As with a JAR file, anything in the <filename>src/conf</filename>
     directory will appear under <filename>src/META-INF</filename>,
     and anything in <filename>src/resources</filename> will appear in
     the EAR file relative to its location in
     <filename>src/resources</filename>.
    </para>
    <para>
     The above examples illustrate how other archive types are
     constructed in &abuild; at the present time.  There are several
     potential problems that may be addressed in a future release of
     &abuild;.  For details, please see <xref
     linkend="ref.known-limitations"/>.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.whole-library">
   <title>Linking With Whole Libraries</title>
   <para>
    In C and C++, most environments create library archives that
    consist of a collection of object files.  Most linkers only link
    object files from libraries into executables if there is at least
    one function in the object file that is in the calling chain of
    the executable.  In other words, if an object file in a library
    appears not to contain any code that is ever accessed, that object
    file is not included in the final executable.  &Abuild; provides a
    way to force inclusion of all object files in a given library for
    underlying systems in which this is supported.
   </para>
   <sect1 id="ref.example.whole-library">
    <title>Whole Library Example</title>
    <indexterm>
     <primary>whole archive</primary>
    </indexterm>
    <indexterm>
     <primary>whole library</primary>
    </indexterm>
    <para>
     There are some instances in which it may be desirable to tell the
     linker to include all the object files from a library.  Common
     examples include times when static libraries are converted into
     shared libraries or when an object file is self-contained but
     contains a static initializer whose side effects are important.
     The <filename>doc/example/whole-library</filename> directory
     contains an example of doing this.  The <filename>lib1</filename>
     and <filename>lib2</filename> directories both contain
     self-contained classes and have static variables that call those
     classes' constructors:
     <?example whole-library/lib1/thing1.hh?>
     <?example whole-library/lib1/thing1.cc?>
     <?example whole-library/lib2/thing2.hh?>
     <?example whole-library/lib2/thing2.cc?>
     Neither library is referenced by <filename>main.cc</filename> (in
     <filename>bin</filename>):
     <?example whole-library/bin/Abuild.conf?>
     <?example whole-library/bin/main.cc?>
     Therefore, the linker would not ordinarily link them in even with
     the dependency on both library build items.
    </para>
    <para>
     In this example, we force <filename>lib1</filename> to be linked
     in but not <filename>lib2</filename>.  This is done by adding the
     variable <varname>WHOLE_lib_thing1</varname> (since
     <filename>thing1</filename> is the name of the library) to
     <filename>lib1</filename>'s
     <filename>Abuild.interface</filename>:
     <?example whole-library/lib1/Abuild.interface?>
     On systems that support this, defining this variable causes the
     corresponding library to be linked in its entirety into any
     executables that use the library.  This facility may not be
     supported by all compilers.  In particular, it is not supported
     for Microsoft Visual C++ in versions at least through .NET 2005,
     in which case setting this variable has cause an error.
    </para>
    <para>
     For cases in which some users of a library may want to link in
     the whole library and others may not, it is also possible to set
     the
     <varname>WHOLE_lib_<replaceable>libname</replaceable></varname>
     variable in an <filename>Abuild.mk</filename>.  For example, if
     you were converting a static library to a shared library, you
     might want to do this in the shared library build item's
     <filename>Abuild.mk</filename> rather than the static library's
     <filename>Abuild.interface</filename> file.  That would prevent
     other users of the static library from needlessly linking with
     the whole library.
    </para>
    <para>
     We do not set this variable for <filename>lib2</filename>:
     <?example whole-library/lib2/Abuild.interface?>
     This means that its static initializer will not be linked in on
     any system.  On a system that supports whole-library linking, the
     main program generates this output:
     <?qtest example.whole-library.out?>
     This output includes the static initializer from
     <classname>Thing1</classname> but not from
     <classname>Thing2</classname>.
    </para>
    <para>
     Note that, in order to be truly portable, an application would
     have to contain explicit code that accessed the static
     initializers.  We illustrate this in some Java code in <xref
     linkend="ref.example.mixed-classification"/>.  The same technique
     used for that example would work in C or C++ code.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.opaque-wrapper">
   <title>Opaque Wrappers</title>
   <para>
    One of the most important features of &abuild; is that a given
    build item automatically inherits the interfaces of not only all
    of its direct dependencies but of its indirect dependencies as
    well.  There may be instances, however, in which this is
    undesirable.  We present such a case here.
   </para>
   <sect1 id="ref.example.opaque-wrapper">
    <title>Opaque Wrapper Example</title>
    <para>
     This example shows how we can create a C/C++ build item that
     implements an &ldquo;opaque wrapper&rdquo; around some other
     interface.  In the
     <filename>doc/example/opaque-wrapper</filename> directory, there
     are three directories: <filename>hidden</filename>,
     <filename>public</filename>, and <filename>client</filename>.
     The <filename>hidden</filename> item implements some interface.
     The <filename>public</filename> item implements a wrapper around
     <filename>hidden</filename>'s interface, but uses
     <filename>hidden</filename> privately: only its source files, not
     its header files, access files from <filename>hidden</filename>:
     <?example opaque-wrapper/public/Public.hh?>
     <?example opaque-wrapper/public/Public.cc?>
     The intention is that users of <filename>public</filename> should
     not be able to access any parts of <filename>hidden</filename> at
     all.  The <filename>client</filename> directory contains an
     example of a build item that uses <filename>public</filename>.
     It doesn't include any files from <filename>hidden</filename>,
     and if it were to try, it would get an error since the
     <filename>hidden</filename> directory is not in its include path.
     However, it still must link against the
     <filename>hidden</filename> library.  The
     <filename>public</filename> build item achieves this by resetting
     the <varname>INCLUDES</varname> interface variable in an
     after-build file:
     <?example opaque-wrapper/public/Abuild.interface?>
     <?example opaque-wrapper/public/hide-hidden.interface?>
     This way, items that depend on <filename>public</filename> will
     see only this item's includes and not those of the items it
     depends on.  Here is the output of <command>abuild
     ccxx_debug</command> when run from the
     <filename>client</filename> directory:
     <?qtest example.opaque-wrapper-ccxx_debug.out?>
     As you can see, there is no reference to the
     <filename>hidden/include</filename> directory even though its
     library and library directory are present in
     <classname>opaque-client</classname>'s compilation environment.
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.plugins">
   <title>Enhancing &Abuild; with Plugins</title>
   <indexterm>
    <primary>plugin</primary>
   </indexterm>
   <para>
    This chapter is geared toward people who may extend or enhance
    &abuild; by adding additional rules, platforms, or compilers.
    Anyone interested in extending &abuild; in this way should also be
    familiar with the material covered in <xref
    linkend="ref.best-practices"/>.  If you think you may need to
    modify the main code of &abuild; itself, please see also <xref
    linkend="ref.abuild-internals"/>.  This section covers the most
    common uses for plugins.  Examples of each topic presented may be
    found in <xref linkend="ref.example.plugin"/>.
   </para>
   <sect1 id="ref.plugin-functionality">
    <title>Plugin Functionality</title>
    <indexterm>
     <primary>plugin.interface</primary>
    </indexterm>
    <indexterm>
     <primary>plugin.mk</primary>
    </indexterm>
    <indexterm>
     <primary>plugin-ant.xml</primary>
    </indexterm>
    <para>
     Plugins are build items that are named in the build tree root's
     <filename>Abuild.conf</filename> in the
     <property>plugins</property> key.  The list of which items are
     plugins is not inherited through either backing areas or
     externals.  In other words, having your external declare
     something as a plugin does not automatically make you get it as a
     plugin.  The same applies to backing areas, but in practice, the
     list of plugins is generally effectively inherited because your
     local build tree's <filename>Abuild.conf</filename> is typically
     a copy of its backing area's <filename>Abuild.conf</filename>,
     assuming your partially populated build tree was checked out of
     the same version control system.  The non-inheritance of plugin
     status through externals is appropriate: since plugins can change
     &abuild;'s behavior significantly, it should be possible for a
     given build tree to retain tight control over which plugins are
     active and which are not.  For example, a build tree may include
     a plugin that enforces certain coding practices by default, and
     use of this build tree as an external should not necessarily
     cause that same set of restrictions to be applied to the tree
     that is using it.  Plugins themselves are ordinary build items
     and can be resolved in externals and backing areas just like any
     other build item.  This makes it possible for an external to
     provide a plugin without using it itself or for a build tree to
     not use all plugins used by its externals.
    </para>
    <para>
     Plugins are loaded by &abuild; and its backends in the order in
     which they are listed in a root build item's
     <filename>Abuild.conf</filename>.  Usually this doesn't matter,
     but if multiple plugins add native compilers the order in which
     plugins are listed can have an effect on which platforms are
     built by default.
    </para>
    <para>
     Plugins are subject to the following constraints beyond those
     imposed upon all build items:
     <itemizedlist>
      <listitem>
       <para>
        Plugins may not have any forward or reverse dependencies.  It
        is good practice to put plugin build items in a private
        namespace (such as prefixing their names with
        <literal>plugin.</literal>) to prevent people from
        accidentally declaring dependencies on them.
       </para>
      </listitem>
      <listitem>
       <para>
        Plugins may not belong to a platform type, have a build file,
        or have an <filename>Abuild.interface</filename> file.
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Plugins may contain the following items that are not supported
     for ordinary build items:
     <itemizedlist>
      <listitem>
       <para>
        &Abuild; interface code loaded from
        <filename>plugin.interface</filename>
       </para>
      </listitem>
      <listitem>
       <para>
        A <filename>platform-types</filename> file to add new object-code
        platform types
       </para>
      </listitem>
      <listitem>
       <para>
        A <command>list_platforms</command> perl script to add new
        object-code platforms
       </para>
      </listitem>
      <listitem>
       <para>
        <filename>rules</filename> directories containing additional
        <application>make</application> rules
        files
       </para>
      </listitem>
      <listitem>
       <para>
        <filename>toolchains</filename> directories containing
        additional compiler support files
       </para>
      </listitem>
      <listitem>
       <para>
        Additional make code in <filename>plugin.mk</filename> that is
        loaded by all make-based build items
       </para>
      </listitem>
      <listitem>
       <para>
        Ant hook code in <filename>plugin-ant.xml</filename> that is used
        as a hook file by all ant-based build items.
       </para>
      </listitem>
     </itemizedlist>
    </para>
    <para>
     Although plugins themselves can never be dependencies of other
     build items or have dependencies of their own, they are still
     subject to &abuild;'s integrity guarantee.  In the case of
     plugins, this means that it is impossible to have an item in your
     dependency tree whose build tree declares a plugin that you are
     shadowing in your local tree.  One way to avoid having this
     become a significant limitation is to keep your plugins in a
     separate build tree that others declare as an external.
    </para>
   </sect1>
   <sect1 id="ref.adding-platform-types-and-platforms">
    <title>Adding Platform Types and Platforms</title>
    <para>
     When &abuild; starts up, it reads its internal information about
     supported platforms and platform types.  It then reads additional
     information from plugins, which it combines with its built-in
     information.  This section contains information about the
     specific formats of the directives used to add platform types and
     platforms to &abuild;.
    </para>
    <para>
     Platform type information is read from a plain text file that
     contains platform type declarations.  Information about platforms
     is obtained by running a program, usually written in Perl.  The
     reason for putting platform type information in a file and
     platform information in a program is that the list of platform
     types should be static for a given build tree, while the list of
     available platforms is a function of what the build host can
     provide.  &Abuild; automatically skips build items that belong to
     a valid platform type that happens to have no platforms in it,
     but if it encounters a build item with invalid platform types, it
     considers that an error.
    </para>
    <sect2 id="ref.adding-platform-types">
     <title>Adding Platform Types</title>
     <para>
      Of the target types that &abuild; supports, the only one for
      which additional platform types and platforms may be specified
      is the <varname>object-code</varname> target type.  Platform
      types are declared in a file called
      <filename>platform-types</filename>.  &Abuild; looks for this
      file first in its own <filename>private</filename> directory and
      then at the root of each declared plugin.  The
      <filename>platform-types</filename> file contains a single
      platform type declaration on each line.  Comment lines starting
      with the <varname>#</varname> character and blank lines are
      ignored.  Each line may have the following syntax:

      <programlisting>platform-type <replaceable>new-platform-type</replaceable>
</programlisting>
     </para>
    </sect2>
    <sect2 id="ref.adding-platforms">
     <title>Adding Platforms</title>
     <para>
      Since platforms are, by their nature, dynamic, &abuild; runs a
      program that outputs platform declarations rather than reading
      them from a file.  This makes it possible for the existence of a
      platform to be conditional upon the existence of a specific
      tool, the value of an environment variable, or other factors.
      To get the list of platforms, &abuild; runs a program called
      <command>list_platforms</command>.  It first runs the one in its
      own <filename>private</filename> directory, and then it runs any
      <command>list_platforms</command> programs it finds at the root
      directories of any plugins.  On a Windows system, &abuild;
      explicitly invokes the <command>list_platforms</command> program
      as <command>perl list_platforms --windows</command>.  For this
      reason, to support portability to a Windows system,
      <command>list_platforms</command> programs should be written in
      perl.  If necessary, a future version of &abuild; may provide a
      mechanism to make writing <command>list_platforms</command>
      programs in other languages more portable.  Note that &abuild;
      passes the <command>--windows</command> flag to
      <command>list_platforms</command> when running on Windows.  This
      not only saves the <command>list_platforms</command> program
      from detecting Windows on its own but is actually necessary
      since <command>list_platforms</command> couldn't tell on its own
      whether it is being run to support a native Windows build of
      &abuild; or whether it is being run to support a Cygwin build of
      &abuild;.
      <footnote>
       <para>
        Note that Cygwin is not Windows.  Cygwin is really more like a
        UNIX environment.  Although &abuild; uses Cygwin to provide
        <application>make</application> and other UNIX-like tools, the
        Windows &abuild; executable is a native Windows application.
        If you were to compile a Cygwin version of &abuild;, it would
        not consider itself to be running in Windows and would not
        invoke <command>list_platforms</command> with the
        <option>--windows</option> option.  That said, there are a few
        pieces of code in the periphery of &abuild; that assume that,
        if we're in a Cygwin environment, it is to support Windows.
        These are all commented as such.  Those parts of the code
        would need to change if someone were to attempt to package
        <command>abuild</command> for Cygwin.
       </para>
      </footnote>
     </para>
     <para>
      Each line of output of <command>list_platforms</command>
      declares either a new platform or a new native compiler, which
      implies a new platform.  A given platform may be declared
      exactly one time across &abuild;'s internally defined platforms
      and plugins.  When a platform type contains multiple platforms,
      unless overridden, &abuild; always chooses to build on the last
      platform declared that belongs to a given platform type.  Since
      plugins are evaluated in the order in which they are declared,
      that means that platforms declared in later plugins can override
      earlier ones as well as &abuild;'s internal platform list with
      respect to determining which platforms will be built by default.
      <footnote>
       <para>
        Note, however, that the <option>--list-platforms</option>
        option shows highest priority platforms first, which
        effectively means that it shows the user platforms in the
        opposite of their declaration order.
       </para>
      </footnote>
      When specifying a new platform or local compiler, the
      <command>list_platforms</command> program may include the option
      <option>-lowpri</option> to indicate that this is a low priority
      platform or native compiler.  This will cause the new platform
      to be added with lower priority than previously declared
      compilers including the built-in ones.  Such compilers will only
      be chosen if explicitly selected.  The user can further refine
      the choice of which platforms are built, including selecting low
      priority compilers and platforms, by using platform selectors
      (see <xref linkend="ref.platform-selection"/>).
     </para>
     <para>
      Each line of output of <command>list_platforms</command> must
      take one of the following forms:

      <programlisting>platform [-lowpri] <replaceable>new-platform</replaceable> -type <replaceable>platform-type</replaceable>
native-compiler [-lowpri] <replaceable>compiler[.option]</replaceable>
</programlisting>
     </para>
     <para>
      By convention, each native compiler should support a platform
      with no options, a platform with the <type>debug</type> option,
      and a platform with the <type>release</type> option.  The
      default should be to select the platform with no options, which
      means the <command>list_platforms</command> program should
      output platforms with no options last.  The platform with no
      options should provide both debugging and optimization flags.
      The <type>debug</type> platform should omit all optimization
      flags, and the <type>release</type> platform should omit all
      debugging flags.  For normal, everyday development, it generally
      makes sense to have both debugging and optimization turned on.
      The reason to have debugging turned on is that it makes it
      possible to do light debugging in a debugger even with optimized
      code.  The reason to have optimization turned on is so that any
      problems introduced by the optimizer and additional static
      analysis that the compiler may do when optimizing will be
      enabled during normal development.  Since optimized code is
      harder to debug in a symbolic debugger, the <type>debug</type>
      version of a platform omits all optimization.  Since it is often
      desirable to ship code without debugging information in it, the
      <type>release</type> version of a platform omits all debug
      information.
     </para>
     <para>
      These options only define the default behavior.  It is still
      possible to override debugging and optimization information on a
      per-file basis or globally for a build item in
      <filename>Abuild.mk</filename> (see <xref linkend="ref.ccxx"/>).
      Note that on some platforms (such as Windows with Visual C++),
      mixing debugging and non-debugging code may not be reliable.  On
      most UNIX platforms, it works fine to mix debugging and
      non-debugging code.
     </para>
     <para>
      When declaring a platform, all platform types that contain the
      platform must have already been declared.
     </para>
     <para>
      Note that object code platform names take the form
      <type>os</type>.<type>cpu</type>.<type>toolset</type>.<type>compiler</type>[.<type>option</type>].
      When declaring a platform with the <type>native-compiler</type>
      directive, &abuild; automatically constructs a platform name by
      using the native values for <type>os</type>, <type>cpu</type>,
      and <type>toolset</type>.  This saves every
      <command>list_platforms</command> program from having to
      determine this information.
     </para>
    </sect2>
   </sect1>
   <sect1 id="ref.adding-toolchains">
    <title>Adding Toolchains</title>
    <para>
     For a compiler to be used by &abuild;, it must be named in an
     &abuild; platform.  The platform can be added using either the
     <varname>platform</varname> or <varname>native-compiler</varname>
     directive as appropriate in the output of a
     <command>list_platforms</command> command.
    </para>
    <para>
     To add a new compiler toolchain to &abuild;, in addition to
     declaring the native compiler or platform to make &abuild; try to
     use it, you must create a file file called
     <filename><replaceable>compiler</replaceable>.mk</filename> where
     <replaceable>compiler</replaceable> is the name of the compiler
     that is being added, and place this file in the
     <filename>toolchains</filename> directory of a plugin.
     &Abuild;'s internal toolchains are under
     <filename>make/toolchains</filename>.  The best way to learn how
     to write a toolchain is to read existing ones.  Most compiler
     toolchains will be designed to support C and C++ compilation and
     are therefore used by the <filename>ccxx</filename> rules.
     Details on the requirements for such toolchains can be found in
     <filename>make/rules/object-code/ccxx.mk</filename> in the
     &abuild; distribution (<xref linkend="ref.ccxx.mk"/>).
    </para>
    <para>
     Once you have written a support file for a new compiler, you will
     need to verify to make sure that it is working properly.  A
     verification program is included with &abuild;: the program
     <filename>misc/compiler-verification/verify-compiler</filename>
     can be run to verify your compiler.  This program creates a build
     tree that contains a mixture of static libraries, shared
     libraries, and executables and puts those items in the platform
     type of your choice.  It then builds them with the specified
     compiler.  You provide the path to the build tree containing the
     plugin, the name of the plugin, the platform type, and the
     compiler.  The program can be used with either native compilers
     or non-native compilers.  It also makes it very clear whether
     everything is working or not.  Please run
     <command>verify-compiler --help</command> and see
     <filename>misc/compiler-verification/README.txt</filename> for
     additional details.
    </para>
   </sect1>
   <sect1 id="ref.example.plugin">
    <title>Plugin Examples</title>
    <para>
     In this section, we present examples of using &abuild;'s plugin
     facility.  The examples here illustrate all of the capabilities
     of &abuild;'s plugin system, albeit with simplistic cases.
     Plugins are a very powerful feature that can be used to do things
     that you could not otherwise do with &abuild;.  If you are not
     careful, they can also create situations that violate some of
     &abuild;'s design principles, so plugins should be used with
     particular care.  You should also be careful not to
     <emphasis>overuse</emphasis> plugins.  Many things you may
     consider implementing as a plugin would be better implemented as
     an ordinary build item with rules or hooks.  Plugins should be
     used only for adding capabilities that can't be added without
     plugins or that should apply broadly and transparently across
     many items in the build tree.
    </para>
    <para>
     &Abuild; enforces that no plugin may have dependencies or be
     declared as a dependency of another build item.  Still, it's good
     practice to name plugins by placing them in a private namespace.
     This prevents build trees that may have access to these items
     (but may not presently declare them as plugins) from declaring
     them as dependencies.  In these examples, we always place our
     plugins in the <classname>plugin</classname> namespace by
     starting their names with <classname>plugin.</classname> even
     though we have no actual <classname>plugin</classname> build
     item.  In order to use the plugins in this tree, we have to
     declare them as plugins in the root build item's
     <filename>Abuild.conf</filename>:
     <?example plugin/Abuild.conf?>
    </para>
    <sect2 id="ref.example.plugins-with-rules-and-interfaces">
     <title>Plugins with Rules and Interfaces</title>
     <para>
      Here we examine the <classname>plugin.counter</classname>
      plugin, which can be found in
      <filename>doc/example/plugin/plugins/counter</filename>.  This
      is a trivial plugin that illustrates use of an interface file
      and also creates a custom rule that can be referenced in the
      <varname>RULES</varname> variable of a build item's
      <filename>Abuild.mk</filename> file.  There's nothing special
      about the plugin's <filename>Abuild.conf</filename> file:
      <?example plugin/plugins/counter/Abuild.conf?>
      The <filename>plugin.interface</filename> file declares a new
      interface variable called <varname>TO_COUNT</varname> which
      contains a list of file names:
      <?example plugin/plugins/counter/plugin.interface?>
      This file gets loaded automatically before any regular build
      items' <filename>Abuild.interface</filename> files.  The file
      <filename>count.mk</filename> in the
      <filename>rules/platform-independent</filename> directory is the
      file that a build item may include by placing <literal>RULES :=
      count</literal> in its <filename>Abuild.mk</filename> file:
      <?example plugin/plugins/counter/rules/platform-independent/count.mk?>
      If a build item includes <filename>count</filename> in the value
      of its <varname>RULES</varname> variable, then any files listed
      in <varname>TO_COUNT</varname> will have their lines counted
      with <command>wc -l</command> when the user runs &abuild; with
      the <command>count</command> target.  The intention here is that
      items that the target build item depends on would add files to
      <varname>TO_COUNT</varname> in their
      <filename>Abuild.interface</filename> files.  Then the build
      item that actually uses the <filename>count</filename> rule
      would display the line counts of all of the files named by its
      dependencies.
     </para>
     <para>
      This is admittedly a contrived example, but it illustrates an
      important point.  Here we are adding some functionality that
      enables a build item to make use of certain information provided
      by its dependencies through their
      <filename>Abuild.interface</filename> files.  Although we could
      certainly add the <command>count</command> target using a normal
      build item that users would depend on and access through
      <varname>BUILD_ITEM_RULES</varname>, doing it that way would be
      somewhat more difficult because each item that wanted to add to
      <varname>TO_COUNT</varname> would also have to depend on
      something that declares the <varname>TO_COUNT</varname>
      interface variable.  By using a plugin, we cause the plugin's
      <filename>plugin.interface</filename> to be automatically loaded
      by all build items in the build tree.  That way, any build item
      can add to <varname>TO_COUNT</varname> without having to take
      any other special actions.  This type of facility could be
      particularly useful for adding support to &abuild; for other
      programming languages that require other information to be known
      from its dependencies.
     </para>
     <para>
      Note that, although we have added only a rule under
      <filename>rules/platform-independent</filename>, we could have
      also added rules under <filename>rules/object-code</filename>,
      including even adding a rule with the same name that does
      something different when used by an object-code build item.
      This is another capability that would not be convenient from a
      build item's <filename>Rules.mk</filename> file.
     </para>
     <para>
      For an example of a build item that uses this plugin's
      capabilities, see the build items under
      <filename>doc/example/plugin/other/indep</filename>.  Here we
      have the build item <classname>indep-a</classname> in the
      <filename>a</filename> directory that adds a file to
      <varname>TO_COUNT</varname> in its
      <filename>Abuild.interface</filename>:
      <?example plugin/other/indep/a/Abuild.conf?>
      <?example plugin/other/indep/a/Abuild.interface?>
      We also have the build item <classname>indep-b</classname>
      (which depends on <classname>indep-a</classname>) in the
      <filename>b</filename> directory that uses the
      <filename>count</filename> rule in its <varname>RULES</varname>
      variable in its <filename>Abuild.mk</filename> file:
      <?example plugin/other/indep/b/Abuild.conf?>
      <?example plugin/other/indep/b/Abuild.mk?>
      Here is the output of running <command>abuild count</command>
      from the <filename>plugin/other/b</filename> directory:
      <?qtest example.count-b.out?>
     </para>
    </sect2>
    <sect2 id="ref.example.plugin.backend-code">
     <title>Adding Backend Code</title>
     <para>
      Here we examine the <classname>plugin.echoer</classname> plugin
      in the <filename>plugins/echoer</filename> directory.  This
      plugin adds hook code for both ant-based and make-based build
      items, again something that could not be done by simply using
      build item rules.  This very simple plugin causes a message to
      be printed when running the <command>all</command> target for
      make-based build items and as a post-compile hook for ant-based
      build items.  All build items in any build tree that includes
      this plugin in its list of plugins will get this functionality
      automatically without having to take any explicit action.  This
      would be preferable to declaring this as a dependency for every
      item and modifying <varname>BUILD_ITEM_RULES</varname> or
      <varname>abuild.hook-build-items</varname> for every build item:
      <?example plugin/plugins/echoer/plugin.mk?>
      <?example plugin/plugins/echoer/plugin-ant.xml?>
     </para>
     <para>
      Although this example is trivial and doesn't do anything useful,
      there are other cases in which this type of facility might be
      useful.  Examples could include targets that gather statistics
      or run static analysis checks that may be required by a certain
      project.
     </para>
     <para>
      For an example of using this plugin, build any build item in the
      <varname>other</varname> or <varname>java</varname> directories
      of <filename>example/plugin</filename>.  Here is the output of
      running <command>abuild all</command> in the build item from the
      previous example.  Since the <command>count</command> target is
      declared as a dependency of <command>all</command> in
      <filename>count.mk</filename>, we see the output of the
      <command>count</command> target as well as the output from the
      <classname>plugin.echoer</classname> build item:
      <?qtest example.echo-b.out?>
     </para>
    </sect2>
    <sect2 id="ref.example.platforms-and-platform-type-plugins">
     <title>Platforms and Platform Type Plugins</title>
     <para>
      In the <classname>plugin.printer</classname> plugin defined in the
      <filename>plugins/printer</filename> directory, we create a new
      platform type and corresponding platform.  This is the mechanism
      that would be used to add support to &abuild; for an embedded
      platform, a cross compiler, or some other special environment.
      In this example, we stretch the idea of platform types a bit for
      the purpose of illustrating this capability with a simple
      example.
     </para>
     <para>
      Here we define a new platform type called <type>printer</type>.
      This is done by creating a <filename>platform-types</filename>
      file and declaring the platform type in it:
      <?example plugin/plugins/printer/platform-types?>
     </para>
     <para>
      In addition to adding the platform type, we also add a platform
      called
      <type>zzprinter.any.test-suite.abc</type>.
      <footnote>
       <para>
        This odd name has been picked to facilitate testing of all
        examples in &abuild;'s own automated test suite.  By starting
        the platform name with <literal>zz</literal>, we effectively
        ensure that it will always appear alphabetically after
        whatever the real native platform is on our build system.
       </para>
      </footnote>
      To add this platform, we print its name from the
      <command>list_platforms</command> command:
      <?example plugin/plugins/printer/list_platforms?>
      In this case, the program is trivial, but in a real
      implementation, the <command>list_platforms</command> command
      would probably be checking the environment or path for presence
      of certain tools before emitting the name of the platform.  A
      <command>list_platforms</command> program should only mention
      the name of a platform that can actually be built on the build
      host from which it is run.
     </para>
     <para>
      The fourth field of any <type>object-code</type> platform is
      always the name of the compiler, so this implies that we have an
      <type>abc</type> compiler defined somewhere.  This plugin also
      provides the rules for using the <type>abc</type> compiler in
      <filename>toolchains/abc.mk</filename>:
      <?example plugin/plugins/printer/toolchains/abc.mk?>
      To understand this file, you should read through the comments in
      <filename>make/rules/object-code/ccxx.mk</filename> in the
      &abuild; distribution (<xref linkend="ref.ccxx.mk"/>).  In this
      case, our plugin also creates the compiler itself in
      <filename>bin/abc</filename> and
      <filename>bin/abc-link</filename>.  Our &ldquo;compilers&rdquo;
      here just create text files of the source code with numbered
      lines.  Doing this particular operation with a plugin is a bit
      absurd&mdash;using some external utility would be a better
      implementation.  Still, it illustrates the mechanics of setting
      up an additional platform type, and it is not at all uncommon
      for a native compiler plugin to provide wrappers around the real
      compiler.
     </para>
     <para>
      Note that to invoke our compiler, the
      <filename>abc.mk</filename> file uses
      <varname>$(abDIR_plugin.printer)</varname> to refer to a file in
      its own directory, just as would be necessary in a
      <filename>Rules.mk</filename> file.  &Abuild; provides these
      variables and corresponding ant properties
      (<varname>abuild.dir.<replaceable>build-item</replaceable></varname>)
      for all plugin directories just as it does for dependencies.
     </para>
     <para>
      To see this plugin in action, build the build item in
      <filename>other/bin</filename> with
      <command>--with-deps</command>.  You will see not only the
      normal native executable program being built, but you will also
      see a second output directory called
      <filename>abuild-zzprinter.any.test-suite.abc</filename> which
      contains a file called <filename>print-program</filename>.  This
      happens because both the <classname>bin</classname> build item
      and the <classname>lib</classname> build item on which it
      depends include the <filename>printer</filename> platform type
      in their <property>platform-types</property> keys in their
      <filename>Abuild.conf</filename> files:
      <?example plugin/other/lib/Abuild.conf?>
      <?example plugin/other/bin/Abuild.conf?>
      Here is the build output:
      <?qtest example.plugin-other-bin.out?>
      Here is the <filename>print-program</filename> file.  This file
      contains the concatenation of all the source files used to
      create the executable as well as the &ldquo;libraries&rdquo; it
      &ldquo;links&rdquo; against:
      <?qtest example.printer-program.out?>
     </para>
    </sect2>
    <sect2 id="ref.example.plugins-and-externals">
     <title>Plugins and Externals</title>
     <para>
      In the <filename>example/plugin/outside</filename> build tree,
      we have a tree that includes our plugin tree as an external by
      listing &ldquo;<filename>..</filename>&rdquo; in the
      <property>external-dirs</property> key of its
      <filename>Abuild.conf</filename> file.  This tree contains the
      <classname>prog2</classname> build item which depends on the
      same <classname>lib</classname> as our previous example's
      <classname>bin</classname> build item.  This build tree does not
      declare any plugins, so even though its external declares
      plugins, those plugins are not used within this tree.  When we
      build the <classname>prog2</classname> build item with
      dependencies, although the <classname>lib</classname> build item
      still builds as before, <classname>prog2</classname> completely
      disregards the existence of the other platform type and the
      echoer's additional build steps.  This is very important.
      Sometimes, a build tree may declare a plugin that works for
      every item in its own tree but that would not necessarily work
      for external items.  Examples might include strict static
      analyzers or other code checkers.  It may be desirable to allow
      the products of this build tree to be usable by others that do
      not wish to follow the same restrictions.  Here is the output of
      building <classname>prog2</classname> with dependencies:
      <?qtest example.plugin-outside.out?>
     </para>
    </sect2>
    <sect2 id="ref.example.native-compiler-plugins">
     <title>Native Compiler Plugins</title>
     <para>
      In the <filename>example/native-compiler</filename> directory, we
      have a plugin that defines a native compiler.  The plugin is in
      the <filename>compiler</filename> directory and is called
      <filename>plugin.compiler</filename>.  In this plugin, we are
      adding a new platform to support our alternative compiler.  We
      don't have to add any new platform types since we are just adding
      this platform to the native platform type.  Since this is a
      relatively common operation, &abuild; provides a short syntax for
      doing it.  Here is the <command>list_platforms</command> program:
      <?example native-compiler/compiler/list_platforms?>
      It generates this output which automatically creates platforms
      with the same first three fields (<type>os</type>,
      <type>cpu</type>, and <type>toolset</type>) as other native
      platforms, with the <type>qcc</type> compiler as the fourth
      field, and with <type>release</type>, <type>debug</type>, or
      nothing as the fifth field:

      <programlisting>native-compiler qcc.release
native-compiler qcc.debug
native-compiler qcc
</programlisting>
      Since new platforms take precedence over old platforms by
      default when &abuild; chooses which platform to use for a given
      platform type, our <command>list_platforms</command> script
      offers the user a way of suppressing this platform and also of
      making these low priority compilers.  In this case, our
      <command>list_platforms</command> program doesn't generate any
      output if the <envar>NO_QCC</envar> environment variable is set,
      and if the QCC_LOWPRI environment variable is set, it declares
      these as low priority compilers which makes them available but
      prevents them from being selected by default over built-in
      compilers or compilers declared by earlier plugins.  Setting
      that environment variable would make that platform completely
      unavailable, regardless of any compiler preferences expressed by
      the user.  (We could also prevent the platform using this
      compiler from being built by default without making it disappear
      entirely by using platform selectors as discussed in <xref
      linkend="ref.platform-selection"/>).  Note that we generate
      output for the <type>qcc</type> compiler with the
      <type>release</type> and <type>debug</type> flags as per our
      usual convention.  By placing the compiler with no options last,
      we make &abuild; select it by default over the other two.  It
      will also be selected over any built-in platforms or platforms
      provided by earlier plugins.
     </para>
     <para>
      In addition to listing the compiler in
      <command>list_platforms</command>, we have to provide a support
      file for it in <filename>toolchains/qcc.mk</filename>:
      <?example native-compiler/compiler/toolchains/qcc.mk?>
      This file illustrates a degenerate compiler implementation,
      providing minimal implementations of all the variables and
      functions that <filename>ccxx.mk</filename> requires.  For
      details, please read the comments in
      <filename>make/toolchains/ccxx.mk</filename> in the &abuild;
      distribution (<xref linkend="ref.ccxx.mk"/>).
     </para>
     <para>
      In the <filename>native-compiler/outside</filename> directory,
      there is another build tree that lists
      &ldquo;<filename>..</filename>&rdquo; in its
      <property>external-dirs</property> key:
      <?example native-compiler/outside/Abuild.conf?>
      This tree doesn't know about the <filename>qcc</filename>
      compiler, so when we build the <classname>outside</classname>
      build item, it would build only with the default native
      compiler.  In a default invocation of &abuild;
      (<emphasis>i.e.</emphasis>, one without any platform selectors),
      the <classname>lib</classname> build item on which this depends
      would only be built with <filename>qcc</filename> because of the
      plugin in its build tree (which is an external relative to this
      tree).  However, the <classname>lib</classname> build item
      <emphasis>could</emphasis> also be built with the default native
      compiler.  &Abuild; recognizes this fact and will therefore
      compile <classname>lib</classname> with both
      <filename>qcc</filename> and the default native compiler.  This
      is an example of &abuild;'s ability to add additional build
      platforms as needed based on the dependency graph:
      <?qtest example.as-needed-platforms.out?>
     </para>
    </sect2>
    <sect2 id="ref.example.plugin.rule-checker">
     <title>Checking Project-Specific Rules</title>
     <para>
      There are still other uses for plugins.  For instance, one can
      use a plugin to enforce additional build tree-specific rules
      that fall outside of &abuild;'s normal dependency checking
      capabilities.  As an example, suppose you had a build item that
      you wanted all build items to depend on and that you couldn't
      make it a plugin because it had to build something.
      <footnote>
       <para>
        Recall that plugins are not allowed to build anything
        themselves.  This may prove to be too great of a restriction
        and may be relaxed somewhat in a future version of &abuild;.
       </para>
      </footnote>
      You could have that build item set a variable to some specific
      value in its <filename>Abuild.interface</filename> file.  Then
      you could create a plugin that would check that the variable had
      that value, which would effectively make sure everyone depended
      on the item that set the variable.  This plugin would have a
      <filename>plugin.mk</filename> file that would check to make
      sure that the variable was set and report an error if not.
      Since all build items would see the plugin code, it would make
      this plugin an effective checker for enforcing some rule that
      can't otherwise by expressed.
     </para>
     <para>
      We illustrate this pattern in our
      <filename>rule-checker</filename> example which can be found in
      <filename>doc/example/rule-checker</filename>.  This directory
      includes four build items:
      <classname>plugin.auto-checker</classname>,
      <classname>auto-provider</classname>,
      <classname>item1</classname>, and <classname>item2</classname>.
      The goal is that every build item whose target type is
      <type>object-code</type> should depend on
      <classname>auto-provider</classname>.  This rule is enforced
      with the <classname>plugin.auto-checker</classname> plugin which
      is declared as a plugin in the tree's root
      <filename>Abuild.conf</filename>:
      <?example rule-checker/Abuild.conf?>
      The <classname>plugin.auto-checker</classname> build item
      contains two files aside from its
      <filename>Abuild.conf</filename>.  It has a
      <filename>plugin.interface</filename> file that declares a
      variable that indicates whether the
      <classname>auto-provider</classname> build item has been seen:
      <?example rule-checker/auto-checker/plugin.interface?>
      This plugin interface file is automatically loaded by all build
      items before their own interface files or any of the interface
      files of their dependencies.  We include a fallback assignment
      of a false value to this variable.  The
      <classname>auto-provider</classname> build item sets this
      variable to true in its <filename>Abuild.interface</filename>
      file:
      <?example rule-checker/auto-provider/Abuild.interface?>
      For completeness, here are the rest of the files from
      <classname>auto-provider</classname>:
      <?example rule-checker/auto-provider/Abuild.mk?>
      <?example rule-checker/auto-provider/provide-auto.mk?>
     </para>
     <para>
      Since <classname>auto-provider</classname> sets the
      <varname>SAW_AUTO_PROVIDER</varname> variable, it possible for
      the <classname>plugin.auto-checker</classname> build item to
      detect that <classname>auto-provider</classname> is in the
      dependency list by checking the value of that variable.  It does
      this in its <filename>plugin.mk</filename> file, which is
      included by &abuild;'s <application>make</application> code for
      every <application>make</application>-based build item:
      <?example rule-checker/auto-checker/plugin.mk?>
     </para>
     <para>
      To see what happens when a build item forgets to depend on
      <classname>auto-provider</classname>, we will look at
      <classname>item1</classname>.  Here is its
      <filename>Abuild.conf</filename>:
      <?example rule-checker/item1/Abuild.conf?>
      As you can see, there is no dependency on
      <classname>auto-provider</classname>.  When we try to build this
      item, we get the following error:
      <?qtest example.rule-checker-item1-error.out?>
      This is the error that was issued from
      <classname>plugin.auto-checker</classname>'s
      <filename>plugin.mk</filename> above.  The build item
      <classname>item2</classname> does declare the appropriate
      dependency:
      <?example rule-checker/item2/Abuild.conf?>
      Its build proceeds normally:
      <?qtest example.rule-checker-item2-build.out?>
     </para>
     <para>
      This examples shows how little code is required to implement
      your own rule checking.  The possibilities for use of this
      technique are endless.  Such techniques could be used to enforce
      all sorts of project-specific architectural constraints, build
      item naming conventions, or any number of other possibilities.
     </para>
    </sect2>
   </sect1>
  </chapter>
  <chapter id="ref.best-practices">
   <title>Best Practices</title>
   <para>
    This chapter describes some &ldquo;best practices&rdquo; that
    should be kept in mind while using &abuild;.  It is based on
    experience using &abuild; and lessons learned from that
    experience.
   </para>
   <sect1 id="ref.guidelines-for-make-rule-authors">
    <title>Guidelines For Make Rule Authors</title>
    <para>
     The code that goes into a <filename>Rules.mk</filename> or
     <filename>plugin.mk</filename> file is regular <application>GNU
     Make</application> code.  There are certain practices that you
     should follow when writing <application>GNU Make</application>
     code for use within &abuild;.  A good way to learn about writing
     rules for &abuild; is to study existing rules.  Here we will
     briefly list some things that rules authors must keep in mind:
     <itemizedlist>
      <listitem>
       <para>
        If you are about to write some rules, consider carefully
        whether they should be local rules for a specific build item
        (accessed with the <varname>LOCAL_RULES</varname> variable),
        exported rules provided by a build item (accessed with the
        <varname>BUILD_ITEM_RULES</varname> variable), or whether they
        should be made globally accessible by being included in a
        plugin.  The latter case will be rare and should only be used
        for functionality that really should work &ldquo;out of the
        box&rdquo; in a particular build tree.  Note also that rules
        that are part of &abuild; or are declared in a plugin are
        specific to a target type.  This restriction is not present
        for local rules and rules provided by build-items.  <!-- This
        parenthetical remark should have been a footnote, but fop 0.94
        appears not to generate output for footnotes in list
        items. --> (The reason that rules accessible through the
        <varname>RULES</varname> variable are segregated by target
        type is to support loading of <emphasis>base</emphasis> rules
        that &abuild; loads before loading the actual rules.  This is
        the mechanism used to make the variable
        <varname>CCXX_TOOLCHAIN</varname> available to all object-code
        rules.) <!-- end footnote --> Plugin rules must appear in the
        <filename>rules/<replaceable>target-type</replaceable></filename>
        directory within a plugin, where
        <replaceable>target-type</replaceable> is the target type to
        which the rules belong.  Build item rules appear in
        <filename>Rules.mk</filename>.  Local rules can appear
        anywhere, and the location must be named in the
        <varname>LOCAL_RULES</varname> variable in
        <filename>Abuild.mk</filename>.  It is also possible to create
        global make code that is loaded from a plugin directory:
        &abuild; will load any <filename>plugin.mk</filename> files
        defined in plugins in the order in which the plugins are
        declared.
       </para>
      </listitem>
      <listitem>
       <para>
        &Abuild; invokes make with the
        <command>--warn-undefined-variables</command> flag.  This means
        that your users will see warnings if you assume that an
        undefined variable has the empty string as a value.  If it is
        your intention to have an undefined variable default to the
        empty string, then you should include

        <programlisting><replaceable>VARIABLE</replaceable> ?=
</programlisting>
        in your rules, where <varname>VARIABLE</varname> is the name
        of the variable you are setting.  You can always provide
        default values for variables in this fashion if the intention
        is to allow users to override those values in their own
        <filename>Abuild.mk</filename> files.
       </para>
      </listitem>
      <listitem>
       <para>
        Note that <filename>Abuild.mk</filename> files are included
        before rules files.  This is necessary because the
        <filename>Abuild.mk</filename> file contains information about
        which rules are to be included.  If your rules are providing
        values that users will use in their
        <filename>Abuild.mk</filename> files, you should recognize
        that your users will need to avoid referencing those variables
        in assignment statements that use <literal>:=</literal>
        instead of <literal>=</literal> since the
        <filename>Rules.mk</filename> variables will not yet be
        defined when <filename>Abuild.mk</filename> is read.
       </para>
      </listitem>
      <listitem>
       <para>
        You should always provide a <command>rules-help</command> target
        in your rules files.  For an example and discussion of this, see
        <xref linkend="ref.example.code-generator"/>.  If your rules use
        values that should be provided in
        <filename>Abuild.interface</filename> files, then you should
        also provide a <command>interface-help</command> target.
       </para>
      </listitem>
      <listitem>
       <para>
        If your rules require certain variables to be set, check for
        those variables and given an error if they are not defined.
        For an example of this, see <xref
        linkend="ref.example.code-generator"/>.  The
        <filename>ccxx.mk</filename> rules in the &abuild; sources
        (<xref linkend="ref.ccxx.mk"/>) provide a somewhat more
        elaborate example of doing this since they actually generate
        dynamically in terms of other values the list of variables
        that should be defined.
       </para>
      </listitem>
      <listitem>
       <para>
        All rules should provide an <command>all::</command> target.
        Note that &abuild; only invokes <command>clean</command>
        targets when run manually from inside an output directory, so
        providing a <command>clean</command> target is optional.
        Still, providing <command>clean</command> targets is good
        practice and can also aid in debugging.  Although you can add
        additional targets in your rules files, think carefully before
        doing so.  Having too many custom targets will make a source
        tree hard to build and maintain.  If you are adding
        functionality that should be done as part of every build,
        consider making it part of the <command>all::</command>
        target.
       </para>
      </listitem>
      <listitem>
       <para>
        Since your <command>clean</command> target is not run when
        &abuild; is invoked normally, please avoid having rules create
        files outside of the output directory from which they are run.
        Any such products will not be removed by &abuild; clean as run by
        ordinary users even if you have coded removal of those products
        in your own <command>clean</command> target.
       </para>
      </listitem>
      <listitem>
       <para>
        Sometimes it may be useful to provide debugging targets for your
        users that provide some information about the state as your
        rules see it.  The <filename>ccxx.mk</filename> rules provide a
        <command>ccxx_debug</command> target for this purpose.
       </para>
      </listitem>
      <listitem>
       <para>
        Always remember that any targets you define in your rules files
        are run from the output subdirectory.  The variable
        <varname>$(SRCDIR)</varname> points to the directory that
        contains the actual <filename>Abuild.mk</filename> file and
        therefore presumably the source files.  &Abuild; sets the
        <varname>VPATH</varname> variable to this as well, but you may
        have to explicitly run your actions with arguments that point
        back to the source directory (e.g., <varname>-I
        $(SRCDIR)</varname>).
       </para>
      </listitem>
      <listitem>
       <para>
        In order to have your rules behave properly with the
        <command>--verbose</command> and <command>--silent</command>
        flags, you should <emphasis>avoid</emphasis> putting
        <literal>@</literal> in front of commands that the user should
        see in verbose mode, and you should have all your rules print
        short, simple descriptive messages about what they are doing.
        These rules should be printed using
        <varname>@$(PRINT)</varname>.  The <varname>PRINT</varname>
        variable is usually set to <command>echo</command>, but it is
        set to <literal>@:</literal> when &abuild; is running in
        silent mode.  Note that we put an <literal>@</literal> sign at
        the beginning of the <varname>@$(PRINT)</varname> command so
        that the user will not see the echo command itself being
        echoed when they are running in verbose mode.
       </para>
      </listitem>
      <listitem>
       <para>
        There are some convenience functions provided by &abuild;'s
        GNU Make code.  The best way to learn is to read existing
        rules.  If you are going to be writing a lot of
        <application>make</application> code for &abuild;, it will be
        in your interest to familiarize yourself with the code in
        <filename>make/global.mk</filename> in the &abuild;
        distribution.
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect1>
   <sect1 id="ref.guidelines-for-ant-target-authors">
    <title>Guidelines For Ant Target Authors</title>
    <para>
     The primary mechanism for extending the functionality of
     Java-based builds with &abuild; is by writing hook targets (see
     <xref linkend="ref.ant-hooks"/>).  There are also examples of
     creating hooks in this document (<xref
     linkend="ref.example.java-code-generator"/>).  A build item hook
     file must be called <filename>ant-hooks.xml</filename>.  It is
     also possible to declare ant hooks files in plugins.  The plugin
     ant hooks file must be called
     <filename>plugin-ant.xml</filename>.
    </para>
    <para>
     Here are some things to keep in mind when writing hook targets:
     <itemizedlist>
      <listitem>
       <para>
        &Abuild; provides property names for most of the directories
        that it uses.  The names of these properties generally start
        with <varname>abuild.private</varname>.  This doesn't mean you
        shouldn't reference those properties; it just means that end
        users should not set them or access them in their
        <filename>Abuild-ant.properties</filename> files or attempt to
        override them from the command-line.  They are intended to be
        private to <application>ant</application> code that is either
        user-supplied or included in &abuild;'s
        <application>ant</application> framework.
       </para>
      </listitem>
      <listitem>
       <para>
        &Abuild; runs with <varname>basedir</varname> set to the
        &abuild; output directory of the build item currently being
        built.  Relative paths are therefore resolved relative to that
        directory.  You can use any ant-supplied methods for accessing
        local files, and you can use the
        <varname>abuild.dir.<replaceable>build-item-name</replaceable></varname>
        property for the location your own build item as provided by
        &abuild;.
       </para>
      </listitem>
      <listitem>
       <para>
        When adding your own hooks, please be sure to create a
        <command>properties-help</command> hook (by creating a
        <command>-properties-help</command> target) that describes any
        additional properties your users should set in their
        <filename>Abuild-ant.properties</filename> files.  For an
        example, see <xref
        linkend="ref.example.java-code-generator"/>.
       </para>
      </listitem>
      <listitem>
       <para>
        Don't be afraid to read the ant code and comments in
        <filename>ant/abuild.xml</filename> under &abuild;'s
        installation directory.
       </para>
      </listitem>
     </itemizedlist>
    </para>
   </sect1>
   <sect1 id="ref.hidden-dependencies">
    <title>Hidden Dependencies</title>
    <para>
     Suppose you have build items <classname>A</classname>,
     <classname>B</classname>, and <classname>C</classname>, and suppose
     that <classname>B</classname> doesn't actually require
     <classname>C</classname> to build, but anyone who needs
     <classname>B</classname> also needs <classname>C</classname>.  In
     this case, <classname>B</classname> should declare a dependency
     on <classname>C</classname>, or <classname>B</classname> and
     <classname>C</classname> should be combined.  In other words, a
     build item should depend on all build items that will be needed
     if you use it.
    </para>
    <para>
     Consider a concrete example.  Suppose our three build items are
     <classname>main</classname>, <classname>lib-headers</classname>, and
     <classname>lib-src</classname>.  Suppose
     <classname>lib-headers</classname> doesn't have an
     <filename>Abuild.mk</filename> and doesn't actually build
     anything.  Instead, it just has an
     <filename>Abuild.interface</filename> that adds its directory to
     your <varname>INCLUDES</varname> variable.  Suppose
     <classname>lib-src</classname> builds a library and has an
     <filename>Abuild.interface</filename> that adds the library
     directory to <varname>LIBDIRS</varname> and the library to
     <varname>LIBS</varname>.  If <classname>main</classname> uses the
     library built by <classname>lib-src</classname> but declares a
     dependency on <classname>lib-headers</classname>, then it will be
     able to compile but not link.  In order to link, it requires a
     dependency on <classname>lib-src</classname>.  This means that
     anyone that depends on <classname>lib-headers</classname> must
     also depend on <classname>lib-src</classname>.  Rather than
     having this situation, make <classname>lib-src</classname>'s
     <filename>Abuild.interface</filename> append to
     <varname>INCLUDES</varname> and just eliminate the
     <classname>lib-headers</classname> build item entirely.  It is
     still okay to have the headers in a separate directory; just
     don't place an <filename>Abuild.conf</filename> in that
     directory.
    </para>
   </sect1>
   <sect1 id="ref.interfaces-and-implementations">
    <title>Interfaces and Implementations</title>
    <para>
     Separation of implementations from interfaces can be a good idea
     and can reduce the complexity of the dependency graph of a build
     tree since users of a capability need to depend only on the
     interfaces and not the implementations.  If done incorrectly,
     however, separating implementations from interfaces has several
     pitfalls.  One may be tempted to implement separation of
     interfaces from implementations by using a scheme such as the one
     described in the previous section, <xref
     linkend="ref.hidden-dependencies"/>.  In addition to creating a
     potential hidden dependency issue, it is possible to create even
     worse situations, such as hidden circular dependencies.
    </para>
    <para>
     The case in the previous situation showed how we can create a
     link error that could be resolved by adding an extra dependency
     in <classname>main</classname>.  It is relatively easy to create
     situations that will cause unresolvable link errors as well by
     creating separate header-only build items.  For example, suppose
     you have libraries <classname>A</classname> and
     <classname>B</classname> and separate build items
     <classname>A-headers</classname> and
     <classname>B-headers</classname> to export their static header
     files.  Suppose now that <classname>A</classname> depends on
     <classname>A-headers</classname> and
     <classname>B-headers</classname> and that
     <classname>B</classname> also depends on
     <classname>A-headers</classname> and
     <classname>B-headers</classname>.  (See <xref
     linkend="fig.hidden-circular-dependency"/>) In this case,
     <classname>A</classname> and <classname>B</classname> are
     actually interdependent but there are no circular dependencies
     declared.  If there are any situations between
     <classname>A</classname> and <classname>B</classname> in which
     the first reference to something in <classname>B</classname>
     appears in <classname>A</classname> and the first reference to
     something else in <classname>A</classname> appears in
     <classname>B</classname>, then anything that depends on
     <classname>A</classname> and <classname>B</classname> will have a
     link error.
     <footnote>
      <para> Use of shared libraries or repeating libraries in the
      link statement could actually work around this specific case,
      but there are good reasons to avoid circular dependencies beyond
      just making &abuild; happy.  The point is that this technique
      allows them to hide in the dependency graph, which is a bad
      thing.
      </para>
     </footnote>
     This is a hidden circular dependency.  The best way to avoid this
     situation is to not split <classname>A-headers</classname> from
     <classname>A</classname>.
     <figure id="fig.hidden-circular-dependency">
      <title>Hidden Circular Dependency</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="hidden-circular-dependency.png"/>
       </imageobject>
       <caption>
        <para>
         <classname>A</classname> and <classname>B</classname> are
         interdependent even though no explicit circular dependencies
         exist.
        </para>
       </caption>
      </mediaobject>
     </figure>
    </para>
    <para>
     There are other less insidious problems that are still annoying.
     For example, <classname>A-headers</classname> might really depend
     on <classname>B-headers</classname> but forget to declare this.
     As long as <classname>A-src</classname> declares a dependency on
     <classname>B-headers</classname>, we'll never notice that
     <classname>A-headers</classname> forgot to declare its dependency
     because <classname>A-headers</classname> isn't actually built.
     We might later try to build something else that declares a
     dependency on <classname>A-headers</classname>.  This other build
     may fail because of <classname>B-headers</classname> not being
     known.  We've then created a hidden dependency situation: anyone
     who depends on <classname>A-headers</classname> must also depend
     on <classname>B-headers</classname>.  The best way to this
     situation is also to not split <classname>A-headers</classname>
     from <classname>A</classname>.
    </para>
    <para>
     One cost of not separating these is that if one library depends
     only on another library's header files, the two libraries could
     be built in parallel.  By making one library depend on the other
     in its entirety, &abuild; will force the dependent library to be
     built before the depending library.  This is unfortunate, but
     it's not a good idea to work around this by introducing holes in
     &abuild;'s dependency management.  A better technique would be to
     use some external analyzer that could detect at a finer level
     what things can actually be built in parallel.  There are
     commercial tools that are designed to do this.  Perhaps, over
     time, &abuild; will acquire this capability, or users of &abuild;
     can implement some solution on top of &abuild; that uses an
     external tool.
    </para>
    <para>
     Proper separation of interfaces from implementations, such as
     using a bridge pattern (as described in the <citetitle>Design
     Patterns</citetitle> book by Gamma, et al), which allows the
     implementation and interface to vary separately by implementing
     proxy methods that call real methods through a runtime-supplied
     implementation pointer, can solve the parallel build problem
     without introducing any of these other pitfalls.  Ultimately, as
     long as you don't create a situation where depending on one
     thing automatically requires you to depend on some other
     specific thing to avoid link errors, you should be in pretty good
     shape.  You can also see an example of true separation of
     interfaces from implementations in <xref
     linkend="ref.example.mixed-classification"/>.
    </para>
    <para>
     Note that another way to create this hidden dependency problem is
     to create a directory that contains header files for multiple
     build items.  Suppose, for example, that you have the directory
     structure shown in <xref linkend="fig.shared-include"/>:
     <figure id="fig.shared-include">
      <title>Shared Include Directory</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="shared-include.png"/>
       </imageobject>
       <caption>
        <para>
         Oops!  Both build items use the same include directory!
        </para>
       </caption>
      </mediaobject>
     </figure>
     and that <classname>A</classname> and <classname>B</classname>
     both have their header files in the <filename>include</filename>
     directory.  If both <classname>A</classname> and
     <classname>B</classname> add <filename>../include</filename> to
     <varname>INCLUDES</varname> in their
     <filename>Abuild.interface</filename> files, any build item that
     depends on <classname>A</classname> could accidentally include
     <classname>B</classname>'s header files and therefore
     accidentally require <classname>B</classname> as well.  A simple
     way to avoid this without having to distribute the public header
     files throughout <filename>module</filename>'s directory
     structure would be to create separate directories under include,
     such as shown in <xref linkend="fig.separate-include"/>.
     <figure id="fig.separate-include">
      <title>Separate Include Directories</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="separate-include.png"/>
       </imageobject>
       <caption>
        <para>
         Headers are still easy to find and are separated by build
         item.
        </para>
       </caption>
      </mediaobject>
     </figure>
    </para>
   </sect1>
  </chapter>
  <chapter id="ref.monitored-mode">
   <title>Monitored Mode</title>
   <para>
    When run with the <option>--monitored</option> flag, &abuild; runs
    in <emphasis>monitored mode</emphasis>.  In this mode, &abuild;
    generates output that would be useful to an external program that
    may be monitoring its progress.  This includes the output of
    <option>--dump-data</option> (see <xref
    linkend="ref.dump-data"/>).  With the data output in monitored
    mode, it is possible to present information to the user that
    reveals considerable detail about &abuild;'s progress during the
    course of a build.  Monitored mode was introduced into &abuild; to
    support <application>Xenon</application>, an
    <application>Eclipse</application> plugin for &abuild;, but it
    could be useful for other purposes as well.  For information about
    <application>Xenon</application>, please see the links on <ulink
    url="http://www.abuild.org">&abuild;'s web site</ulink>.
   </para>
   <para>
    All additional information in monitored mode is either prefixed by
    the string <varname>abuild-monitored:</varname> followed by a
    keyword or is delimited on both ends by strings so prefixed.  The
    following information is provided in monitored mode:
   </para>
   <variablelist>
    <varlistentry>
     <term>begin-dump-data ... end-dump-data</term>
     <listitem>
      <para>
       Lines delimited by these keywords surround
       <option>--dump-data</option> output.  In monitored mode,
       <option>--dump-data</option> output appears just before
       &abuild; begins a build or, if there were errors, just before
       it exits.  Note that <option>--dump-data</option> option is
       always included in monitored mode, so inclusion of the
       <option>--dump-data</option> option is not required and would
       in fact make &abuild; exit before it built anything.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>error</term>
     <listitem>
      <para>
       Any error message output by &abuild; is repeated in a monitor
       output message prefixed by this keyword.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>fatal-error</term>
     <listitem>
      <para>
       Any fatal error message output by &abuild; is first issued in a
       monitor output message prefixed by this keyword.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>state-change</term>
     <listitem>
      <para>
       During a build, &abuild; outputs state changes from the dependency
       evaluator using this keyword.  State change monitor output lines
       will always have this form:

       <programlisting>abuild-monitor: state-change item-name platform state
</programlisting>
       where <varname>state</varname> is one of the following:
       <variablelist>
        <varlistentry>
         <term><varname>waiting</varname></term>
         <listitem>
          <para>
           The item is scheduled to be built but still has dependencies
           that have not yet been built
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><varname>ready</varname></term>
         <listitem>
          <para>
           The item is scheduled to be built, and all its dependencies
           have been successfully built
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><varname>running</varname></term>
         <listitem>
          <para>
           The item is currently being built
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><varname>completed</varname></term>
         <listitem>
          <para>
           The item has been built successfully
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><varname>failed</varname></term>
         <listitem>
          <para>
           An attempt was made to build the item, but the build failed
          </para>
         </listitem>
        </varlistentry>
        <varlistentry>
         <term><varname>dependency-failed</varname></term>
         <listitem>
          <para>
           The item was previously scheduled to be built, but a build
           will no longer be attempted because of the failure of one of
           its dependencies
          </para>
         </listitem>
        </varlistentry>
       </variablelist>
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>targets</term>
     <listitem>
      <para>
       Before &abuild; invokes the backend to perform a build, it will
       output a line of the form

       <programlisting>abuild-monitor: targets item-name platform target [target ...]
</programlisting>
       to indicate a space-separated list of targets that will be
       passed to the backend.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
   <para>
    Additional monitor output lines may be added in the future.  To
    ensure forward compatibility, programs intending to consume &abuild;
    monitor output should ignore any &abuild; monitor output lines that
    they do not recognize.
   </para>
  </chapter>
  <chapter id="ref.abuild-internals">
   <title>&Abuild; Internals</title>
   <para>
    This chapter provides detailed information about the inner
    workings of parts of &abuild;.  Understanding this material is not
    essential even for using &abuild; in an advanced way, but reading
    it may provide insight into some of the reasons that &abuild;
    works the way it does.  Understanding this material
    <emphasis>is</emphasis> essential to anyone who would want to
    modify any of &abuild;'s core functionality.
   </para>
   <sect1 id="ref.avoiding-recursive-make">
    <title>Avoiding Recursive Make</title>
    <para>
     There has been some thought and writing about recursive make, and
     there are various approaches to the problem of make recursion.
     On one extreme, you can write makefiles that iterate through
     subdirectories and invoke make recursively for each subdirectory.
     These are hostile to parallelism and invoke make recursively
     bounded by the depth of the file system.  This use of recursive
     make is expensive in terms of time and system resources.  At the
     other end of the spectrum, you can create makefiles that include
     all the other makefiles and effectively create one monolithic
     makefile for the entire project.  These makefiles are fragile and
     very hard to maintain because you have to make sure that no
     makefile defines any targets or variables that conflict with
     those defined by other makefiles, and you have to jump through
     hoops to make sure that whatever paths are in the makefiles can
     be resolved properly regardless of the starting directory of the
     build.
    </para>
    <para>
     &Abuild; takes a middle ground.  The only files that may be
     included in multiple contexts that actually set variables and
     contain end-user knowledge are rules files.  To make this work,
     we provide variables that contain the currently resolved path of
     each build item.  This is necessary anyway in order to support
     backing areas.  &Abuild; then allows users to create
     <filename>Abuild.mk</filename> files that don't have to coexist
     with other <filename>Abuild.mk</filename> files at runtime.
     Since &abuild; knows all the dependencies between build items, it
     can build items iteratively or even in parallel without using any
     recursion at all.  Although a monolithic makefile system that is
     perfectly constructed would allow arbitrarily complex
     dependencies to be declared between specific targets in specific
     directories, maintaining this for a system of any size or for a
     system that was dynamic would be impractical.  &Abuild; replaces
     this with precise management of inter-build item dependencies.
     Even so, &abuild;'s make code actually does generate fine-grained
     dependencies at the file level, so most of the advantages of the
     monolithic non-recursive makefile approach are realized with
     &abuild;.  We believe that this achieves the right balance
     between granularity and ease of maintenance and makes &abuild;'s
     approach robust and efficient for both small and large build
     trees.
    </para>
   </sect1>
   <sect1 id="ref.running-in-output-directory">
    <title>Starting &Abuild; in an Output Directory</title>
    <para>
     When &abuild; starts up, it decides that it is running in an
     output directory if all of the following conditions hold:
     <itemizedlist>
      <listitem>
       <para>
        The current directory <emphasis>does not</emphasis> contain an
        <filename>Abuild.conf</filename> file
       </para>
      </listitem>
      <listitem>
       <para>
        The parent directory <emphasis>does</emphasis> contain an
        <filename>Abuild.conf</filename> file
       </para>
      </listitem>
      <listitem>
       <para>
        The current directory name starts with <filename>abuild-</filename>
       </para>
      </listitem>
      <listitem>
       <para>
        The current directory contains a file called
        <filename>.abuild</filename>
       </para>
      </listitem>
     </itemizedlist>
     If &abuild; is invoked in an output directory, it determines the
     current platform from the name of the output directory (which is
     always called
     <filename>abuild-<replaceable>platform</replaceable></filename>)
     and the current build item from the
     <filename>Abuild.conf</filename> in the parent directory.  Then
     it will run a build only for that specific platform on that
     specific build item.  In this mode, &abuild; explicitly prohibits
     specification of a build set or clean set.  It also, as a special
     case, passes the <command>clean</command> target to the backend.
     The main use for this feature would be in testing rules, but it
     could also be useful in helping to track down some hard-to-trace
     build problem that applies to only one of several platforms that
     are being built for a specific build item.  Most users will never
     use this functionality.
    </para>
   </sect1>
   <sect1 id="ref.traversal-details">
    <title>Traversal Details</title>
    <para>
     This section describes how &abuild; traverses build trees to
     resolve build item names to paths.  Here we describe the process
     at a level of detail that is closer to the code.  The
     <function>traverse</function> function in the &abuild; source
     code is responsible for the behavior described here.  It will
     likely be necessary to read this section more than once to fully
     understand what is happening as some parts of the description
     won't make sense without knowing about parts you won't have read
     yet.  (Fortunately, the human brain is better at resolving
     circular dependencies than a build system is.)
    </para>
    <para>
     Internally, &abuild; maintains two data structures: a
     <classname>BuildTree</classname> and a
     <classname>BuildItem</classname>.  The
     <classname>BuildTree</classname> object has a map from build item
     names to the <classname>BuildItem</classname> object for that
     name.  It also has a mapping of relative paths to either build
     item names or to the empty string in the case of unnamed build
     items.  It stores the path to the root of its backing area and a
     map from declared external paths to external build tree root
     absolute paths.
    </para>
    <para>
     The <classname>BuildItem</classname> object contains the absolute
     path of the build item, the path of the root of its local build
     tree, its <firstterm>backing depth</firstterm> (how many levels
     of backing areas you have to cross to get to the item), its
     <firstterm>external depth</firstterm> (how many levels of
     externals you have to cross to get to the item), and various
     information read from <filename>Abuild.conf</filename> or
     computed from the dependency graph.
    </para>
    <para>
     When &abuild; starts up, it finds an
     <filename>Abuild.conf</filename> in the current directory (or
     parent directory if &abuild; is started from inside an output
     directory) and follows <property>parent-dir</property> pointers
     until it finds an <filename>Abuild.conf</filename> that has no
     <property>parent-dir</property> key.  This is the root of the
     build tree.  Once &abuild; has found the root of the local build
     tree, it begins traversal.  Before traversing the local build
     tree, it first traverses the backing area tree and any externals.
     This is done by calling <varname>traverse</varname> recursively.
     Note that we traverse the backing area first since we allow
     externals to be resolved in backing areas: if no directory exists
     at the path specified for an external, we see if any backing area
     declared the same external and, if so, we consider the external
     reference to be satisfied since we'll get all its items through
     the backing area.  Once &abuild; has finished traversing the
     backing area and externals, and therefore all their backing areas
     and externals, it contains all the information it needs to finish
     traversing the local tree.
    </para>
    <para>
     The process by which &abuild; traverses a specific build tree is
     fairly straightforward: we traverse through the
     <varname>child-dirs</varname> pointers starting from the root
     build item, ensuring that the links between parents and children
     are bidirectional.  If a directory referenced in a
     <varname>child-dirs</varname> key does not exist in the local
     build tree, &abuild; computes the location of the missing
     directory relative to the top of the local build tree and then
     checks to see whether there is a valid build item at the same
     position relative to the root of one of the build trees in your
     backing area chain (but <emphasis>not</emphasis> your externals;
     they are handled differently).  If there is, then we don't
     consider the lack of that child directory to be an error.  Note
     that we do not do anything with the information about what is
     actually at that location, we just keep traversing as if that
     directory were there and had been traversed successfully.  In
     effect, this is exactly what has happened since we have completed
     traversal of the backing area in which we found the path.  This
     policy has the same effect as searching for unknown build item
     names in our backing area chain.  There is no need to determine
     that the location in the backing area is the same item or even is
     a named item at all.  In fact, doing so would make it impossible
     to rearrange build items in local trees with backing areas since
     our local tree would never be able to diverge in directory
     structure from the backing area.  One side effect of this is that
     it is not possible to <emphasis>remove</emphasis> a build item
     name from the namespace in a local tree if that name is present
     in a backing area by simply removing it from the local tree.  If
     you need to remove an item in this way, you must also list its
     name in the <property>deleted</property> key of the root build
     item's <filename>Abuild.conf</filename> as discussed in <xref
     linkend="ref.example.deleted-item"/>.
    </para>
    <para>
     Once &abuild; has finished traversing the local build tree
     (skipping any paths that could be resolved in a backing area) and
     has established a local mapping between names and paths, it then
     goes through the externals and backing area and supplements its
     name to path mapping with any names that were found there.
     &Abuild; looks in externals first.  For each build item in our
     externals, we check to make sure we don't have the same name
     locally.  If we do and that name resolves to a different absolute
     path, it's an error.  If we do and that name resolves to the same
     absolute path, we ignore it since it just means we have more than
     one path to the same build item through various externals, as
     will become more clear momentarily.  If we don't have an item of
     that name, we copy the <classname>BuildItem</classname> structure
     from the external into our own build tree, thus making the name
     known to us, and we increment the external depth in the copy.
     Now to clarify the point about multiple paths to a build item
     through various externals: if some build tree
     <filename>T1</filename> has <filename>../T2</filename> and
     <filename>../T3</filename> as externals and
     <filename>T2</filename> also has <filename>../T3</filename> as an
     external, every build item local to <filename>T3</filename> will
     also be a member of <filename>T2</filename> since it will have
     been copied during the traversal of <filename>T2</filename>.
     When we try to copy items from <filename>../T3</filename>,
     assuming we copy from <filename>../T2</filename> first, the items
     will already be there, but it will not be an error.  (See <xref
     linkend="fig.multiple-paths"/>.)
     <figure id="fig.multiple-paths">
      <title>Multiple Paths to a Build Item</title>
      <mediaobject>
       <imageobject>
        <imagedata fileref="multiple-paths.png"/>
       </imageobject>
       <caption>
        <para>
         <filename>/T1</filename> inherits <classname>C</classname>
         directly from both <filename>/T2</filename> and
         <filename>/T3</filename>, but this is not an error since they
         are the same item.
        </para>
       </caption>
      </mediaobject>
     </figure>
     This does imply that the value of the external depth parameter
     can be ambiguous, but it doesn't really matter: the only thing
     that's important about backing depth and external depth is
     whether they are zero or not.
    </para>
    <para>
     Once we have done this process for all externals, we perform a
     similar process for backing areas.  For each item that exists in
     our backing area (and therefore, its backing area and externals)
     that does not exist in our own tree or its externals, we copy it
     just like we did for externals, and increment the backing depth
     of our local copy.  If we see a build item with a name that
     conflicts with an item we already have, we ignore it.  This is
     the normal case of local build items shadowing those in the
     backing area.  We also take care to avoid copying any item from a
     backing area that was deleted in an external.
    </para>
    <para>
     After &abuild; has finished copying build items from backing
     areas and externals, it iterates through the list of deleted
     items, verifies that they exist in the current tree with a
     backing depth greater than zero and an external depth equal to
     zero (reporting an error if not), and then removes them from the
     current build tree.
    </para>
    <para>
     Note that backing areas may have externals and externals may have
     backing areas.  They are, after all, build trees in their own
     right.  This means that a particular build tree may be reachable
     from the local build tree by multiple paths.  &Abuild; imposes no
     requirements on the shape of the external and backing area graph
     (other than it contain no cycles) because additional restrictions
     are not necessary.  Ordinarily, if <filename>A1</filename> backs
     to <filename>A2</filename> and <filename>B1</filename> backs to
     <filename>B2</filename>, then if <filename>A1</filename> has
     <filename>B1</filename> as an external, one would expect
     <filename>A2</filename> to have <filename>B2</filename> as an
     external.  This means that <filename>B2</filename> is reachable
     from <filename>A1</filename> through two distinct paths.  There's
     no reason though that <filename>A1</filename> couldn't have
     backed to <filename>A3</filename> which backs to
     <filename>A2</filename>.  It's even okay if
     <filename>A1</filename> backs to <filename>A3</filename> and
     <filename>A3</filename> doesn't back to anything as long as
     <filename>A3</filename> doesn't depend on anything in one of the
     <filename>B</filename> areas.  This flexibility makes it possible
     to do things like add dependencies on new externals or remove
     dependencies on externals from a side branch in your version
     control system.  If &abuild; placed restrictions on the shape of
     the backing area/external tree, many of these operations would
     not be possible.  &Abuild; enforces its integrity guarantee
     directly, and that's really a strong enough check to ensure that
     backing area/external anomalies that matter will be caught.
    </para>
    <para>
     There is nothing inherent about &abuild; that would preclude an
     implementation that allows multiple parallel backing areas to be
     declared for a single build tree, but given the availability of
     externals and the fact that backing areas are transitive (a build
     tree inherits from its backing area's backing area), it should be
     sufficient to have only a single backing area, and it simplifies
     both &abuild;'s own internal logic and the ability for a user to
     figure out what is going to be found where.  Besides, in order
     for &abuild;'s guarantee to be satisfied, it would be necessary
     for every build tree to search its backing areas' backing areas
     in the same order anyway.
     <footnote>
      <para>
       If there is a strong case to be made for the need for more than
       one backing area to be searched from a given build tree that
       can't be satisfied by simply having one of the backing areas
       back to the other backing area, please present the case.  It
       may result in an improvement of your understanding of the
       current intended use, or you may succeed in causing &abuild; to
       be modified to support multiple backing areas.
      </para>
     </footnote>
    </para>
   </sect1>
   <sect1 id="ref.computing-valid-traits">
    <title>Computing Valid Traits</title>
    <para>
     The way in which &abuild; determines the list of traits that are
     valid for items in a particular build tree has some subtleties
     with respect to backing areas and externals.  In particular, it
     is possible to have a build tree actually remove traits from the
     list of valid traits declared in its backing area.
    </para>
    <para>
     To construct the list of valid traits for a build tree, &abuild;
     creates the union of the supported traits declared in a tree's
     own root <filename>Abuild.conf</filename> with those in any of
     its externals.  Backing areas are not consulted since the
     assumption is that a build tree's root
     <filename>Abuild.conf</filename> generally starts out as a copy
     of the one from its backing area and therefore initially lists
     the same traits.  There is one notable case in which the
     assumption does not apply: when an external is resolved from a
     backing area.
     <footnote>
      <para>
       Such an external shows up in &abuild;'s
       <option>--dump-data</option> output (see <xref
       linkend="ref.dump-data"/>) with the
       <literal>backed="1"</literal> attribute.
      </para>
     </footnote>
     We handle that case specially in order to include that external's
     traits.  When an external is resolved from a backing area,
     &abuild; internally creates a build tree object that has no root
     build item.  In this case alone, &abuild; copies the list of
     supported traits from that tree's backing area.  Since such a
     build tree can, by its very nature, never have any local build
     items, the effect of this is that the resolved external is
     treated identically to any actual external that actually exists
     at its specified location.  This makes externals that are
     resolved to backing areas behave properly with respect to traits.
     The corner cases of this logic are exercised in &abuild;'s test
     suite.  It also makes it possible to remove traits that were
     present in your backing area by simply removing them from your
     own build tree's root <filename>Abuild.conf</filename>.
    </para>
   </sect1>
   <sect1 id="ref.construction-of-build-sets">
    <title>Construction of the Build Set</title>
    <para>
     This section describes the process that &abuild; uses to
     construct the build set.  First, &abuild; creates a list of build
     items that directly match the criteria of the specified build
     set.  If <option>--only-with-traits</option> was specified, only
     build items that match the build set criteria and have all of the
     named traits are included.
    </para>
    <para>
     Next, if we are building (as opposed to cleaning) or if the
     <option>--apply-targets-to-deps</option> option has been
     specified (even if we are cleaning), the build set is expanded to
     include all dependencies of any items already in the build set.
     Then, if <option>--related-by-traits</option> has been specified,
     &abuild; gathers up a list of all items that have all of the
     traits listed in the <option>--related-by-traits</option> option
     and that declare at least one of those traits referent to one of
     the build items in the build set so far.  As it finds them, it
     adds them to the build set.  Once that process has completed, if
     we are building or <option>--apply-targets-to-deps</option> was
     specified, &abuild; once again expands the build set to include
     the dependencies of all items that are in the build set.
    </para>
    <para>
     Note that we do not take a second pass at expanding the build set
     based on traits specified with
     <option>--related-by-traits</option>.  Usually this won't matter,
     but there are some cases in which it does actually make a
     difference.  For example, suppose the original build set contains
     <classname>A</classname> and <classname>B</classname>, and that
     <classname>AC-test</classname> is declared as a tester of item
     <classname>A</classname>, which is in the build set, and also of
     item <classname>C</classname> which is not in the build set.  If
     we are adding items related by the <property>tester</property>
     trait, the <classname>AC-test</classname> build item will be
     added to the build set.  Assuming <classname>AC-test</classname>
     depends on <classname>C</classname>, then
     <classname>C</classname> will also be added to the build set.
     Now if there is another build item called
     <classname>C-test</classname> that tests
     <classname>C</classname>, it will <emphasis>not</emphasis> be
     added to the build set because the item that it tests was not an
     original member of the build set.  This situation is reproduced
     in &abuild;'s test suite.
    </para>
   </sect1>
   <sect1 id="ref.construction-of-build-graph">
    <title>Construction of the Build Graph</title>
    <para>
     During validation, &abuild; creates a
     <classname>DependencyGraph</classname> object to represent the
     space of build items and their dependencies.  It performs a
     topological sort on this graph to determine dependency order as
     well as to detect errors and cycles in the dependency graph.
     During the actual build, &abuild; needs to expand the dependency
     graph to include not just build items but build item/platform
     pairs.  Every &ldquo;instantiated&rdquo; build item has to exist
     on a particular platform.  We refer to this platform-aware
     dependency graph as the <firstterm>build graph</firstterm>.  The
     build graph can be inspected by running &abuild; with the
     <option>--dump-build-graph</option> command-line option.
    </para>
    <sect2 id="ref.build-graph.validation">
     <title>Validation</title>
     <para>
      There are several steps required in order to determine exactly
      which build items are to be built on which platforms and which
      build item/platform pairs depend on which other pairs.  Before
      we do anything else, we need to perform several validations and
      computations.  The first of these is the determination of what
      platform types a build item belongs to.  For most build items,
      this is simply the list of platform types declared in the build
      item's <filename>Abuild.conf</filename> file.  For build items
      that have no build or interface files, there are no platform
      types declared.  In this case, the rules are different: if the
      build item declares any dependencies and all of its directly
      declared dependencies have identical platform type sets, then
      the build item inherits its platform types from the items it
      depends on.  Otherwise, it has no platform types and has the
      special target type <type>all</type>.  Note that this analysis
      is performed on build items in reverse build order.  That way,
      every build item's platform types and target type has been
      determined before any items that depend on it are analyzed.
     </para>
     <para>
      Once we have determined the list of platform types for each
      build item, we can figure out which platforms a build item may
      be built on.  We refer to the list as the <firstterm>buildable
      platform list</firstterm>.  The buildable platform list for a
      build item is included in the <option>--dump-data</option>
      output (see <xref linkend="ref.dump-data"/>).  Note that this is
      generally a broader list than the list of platforms on which a
      given build item will actually be built; the actual build
      platform list is determined later in the build graph
      construction process.  For build items that have a specific
      target type and platform types, the list of buildable platforms
      is the union of all platforms supported on all platform types a
      build item has.  For items of target type <type>all</type>, we
      don't explicitly compute a buildable platform list.  These
      platforms are allowed to &ldquo;build&rdquo; on any platform
      since there are no actual build steps for such build items.
      (Remember that for a build item to have target type
      <type>all</type>, it must not have any declared platform types,
      and this in turn means that it must have no build or interface
      files.)
     </para>
     <para>
      All of the above steps can be completed without knowing which
      build items are actually included in the build set.  These
      computations, in fact, are determined at startup for every build
      item in every known build tree regardless of whether the items
      are in the build set.  During this validation, we also perform
      checks to ensure that each build item's dependencies have
      appropriate platform types.  Specifically, a build item of
      target type <type>all</type> may depend on any build item, and
      any build item may depend on an item of target type
      <type>all</type> or <type>platform-independent</type>.  For
      other build items, if a build item depends on another build item
      and declares the dependency with a
      <option>-platform=<replaceable>selector</replaceable></option>
      option, the dependent build item must have the platform type
      mentioned in the platform selector.  Otherwise, every platform
      type of the depending build item must be present in the
      dependent item.  For example, if <classname>A</classname> has
      platform types <type>X</type> and <type>Y</type> and depends on
      <classname>B</classname> which has types <type>X</type>,
      <type>Y</type>, and <type>Z</type>, this is okay because
      <classname>B</classname> has all of <classname>A</classname>'s
      platform types.  It would be an error if
      <classname>B</classname> depended on <classname>A</classname> in
      this case since the instances of <classname>B</classname>
      building for platform type <type>Z</type> would not be able to
      satisfy their dependences on <classname>A</classname> since it
      doesn't support that platform type.
     </para>
     <para>
      The above validations are all completed before &abuild; starts
      to build.  If any errors are found in the above checks, &abuild;
      will report them and exit before it attempts to construct the
      build graph.  This means that the build graph construction
      itself can operate under the assumption that all of the above
      constraints have been satisfied.
     </para>
    </sect2>
    <sect2 id="ref.build-graph.construction">
     <title>Construction</title>
     <para>
      The next step is the construction of the actual build graph
      itself.  This is performed only when all previous validations
      have been performed successfully, and this step is also
      performed only for build items that are actually in the build
      set.  This process is a bit tricky.  We present a prose
      description of the process here.  For a fully detailed
      description, please read the comments and code in
      <function>addItemToBuildGraph</function> in
      <filename>Abuild.cc</filename> in the &abuild; sources.  We
      construct the build graph in reverse build order;
      <emphasis>i.e.</emphasis>, we start with most dependent build
      item and end with the least dependent build item.  For each
      build item, we add to the list of <firstterm>build
      platforms</firstterm> (platforms on which the item will actually
      be built), based on our platform selection criteria, as
      described in <xref linkend="ref.platform-selection"/>.  The list
      may be initially empty, or it may have been modified by items
      that depend on this item.  For build items of target type
      <type>all</type>, we would not add any items to the list at this
      step.  Then, for each direct dependency, we determine which
      instance of it we will depend on.  If the dependency in question
      is declared with a platform selector, we pick the best platform
      from among the dependency's buildable platform list that
      satisfies the platform selector and make this the
      <firstterm>dependent platform</firstterm>.  If there are no
      matches, it is an error.  If there was no platform selector in
      the dependency and the dependent item is platform-independent,
      the dependent platform is <type>indep</type>.  Otherwise, there
      is no specific dependent platform.  Then, for each of our build
      platforms, we add a node to the build graph for the current
      build item and platform.  If we have a specific dependent
      platform, we create a dependency from our new node to the node
      consisting of the dependency item and the dependent platform.
      Otherwise, we check the dependency item to make sure that it is
      buildable on our current platform.  If not, it is an error.  If
      so, we create a dependency from our node to the node consisting
      of the dependency item and our platform, and we also add the
      platform to the dependency's build platform list.  This is the
      mechanism by which &abuild; will build an item on a platform as
      needed to satisfy a dependency.  An example of this is presented
      in <xref linkend="ref.example.cross-platform-dependency"/>.
     </para>
    </sect2>
    <sect2 id="ref.build-graph.implications">
     <title>Implications</title>
     <para>
      Even if the exact steps of constructing the build graph are
      involved, there are some implications that are relatively easy
      to understand.  In particular, the way the build graph works
      implies that, in general, a build item may only depend on
      another build item if the dependent item builds on all the
      depending item's platforms.  There are two ways around this: one
      is to use a platform selector on a dependency, and the other is
      to use a build item of target type <type>all</type>.  A build
      item of target type <type>all</type> is a pass-through build
      item, as described in <xref linkend="ref.build-item-types"/>.  A
      build item gets to be this way by not having a build or
      interface file, not declaring any platform types, and depending
      on items with different groups of platform types.
     </para>
    </sect2>
   </sect1>
   <sect1 id="ref.interface-implementation">
    <title>Implementation of the &Abuild; Interface System</title>
    <para>
     Up to this point, we have pretended that when &abuild; builds an
     item, it recursively reads the interface files of all its
     dependencies.  Although this is the effect of what the interface
     system does, it is not exactly what happens.  In this section, we
     will explain what really happens.
    </para>
    <para>
     Internally, &abuild; implements an
     <classname>Interface</classname> object and an
     <classname>InterfaceParser</classname> object.  Each
     <classname>InterfaceParser</classname> instance contains one
     <classname>Interface</classname> object.  We use one
     <classname>InterfaceParser</classname> instance to load each
     <filename>Abuild.interface</filename> file and all of its
     <filename>after-build</filename> files.  The scope of
     <function>reset</function> and <function>reset-all</function>
     statements is the <classname>InterfaceParser</classname>
     instance.
    </para>
    <para>
     Internally, an <classname>Interface</classname> object maintains
     a list of variables, each of which has a declaration and a list
     of assignments.  Each declaration and assignment is marked with
     the file location (file name, line number, and column number) at
     which it appeared.  Additionally, assignment information includes
     any flag that the assignment may be conditional upon.  &Abuild;
     does not actually maintain the value of a variable.  It only
     maintains the list of assignments.  Values of variables are
     computed on the fly as they are needed.  For list variables, all
     assignment statements are maintained.  For scalar variables, we
     store first all fallback assignments in the opposite of the order
     in which they appeared (with later fallback assignments being
     pushed onto the beginning of the history), the one normal
     assignment (as more than one normal assignment is an error), and
     then all override assignments in the order in which they appear
     (with later assignments added to the end of the history).  When
     we perform a <function>reset</function> operation on an interface
     variable, we do not store the <function>reset</function>
     operation.  Rather, we actually clear out the variable's
     assignment history.  We discuss this further momentarily.
    </para>
    <para>
     When a build item or another <classname>Interface</classname>
     object attempts to retrieve the value of a variable, &abuild;
     determines what flags, if any, are in effect and filters out any
     assignments that are connected with flags that are not set.
     Then, for list variables, the results of each remaining
     assignment are appended or prepended to the list, depending upon
     whether the list was declared as <type>append</type> or
     <type>prepend</type>.  For scalar variables, only the last item
     in the assignment history is used.  In this way, if there were
     only fallback assignments, the first fallback assignment would be
     at the end of the list.  If there were any override assignments,
     the last override assignment would be at the end of the list.  If
     there were only normal assignments, the normal assignment would
     be there.  It is important that we maintain all of this
     information because we might filter out some assignments based on
     flags.  We discuss this in more depth below.
    </para>
    <para>
     One <classname>Interface</classname> object may
     <firstterm>import</firstterm> other
     <classname>Interface</classname> objects.  When one
     <classname>Interface</classname> object imports another, the
     object merges the imported object's variable history with its
     own.  Any declarations or assignments that are exactly duplicated
     (that is, they have the same file location as a previously seen
     operation) are ignored.  This is important since we may import
     the same interface file through more than one path.
    </para>
    <para>
     There is a subtle aspect of how <function>reset</function> works
     in connection with loading interfaces as a result of the fact
     that a <function>reset</function> actually clears the assignment
     history of a variable at the time of the reset operation rather
     than storing the <function>reset</function> as part of the
     history.  For example, suppose you have interfaces
     <classname>Q</classname> and <classname>R</classname> and that
     <classname>R</classname> imports <classname>Q</classname>,
     <classname>Q</classname> assigns to variable
     <varname>A</varname>, and <classname>R</classname> resets
     variable <varname>A</varname>.  If interface
     <classname>S</classname> imports just <classname>R</classname>,
     it will not see <classname>Q</classname>'s assignment to
     <varname>A</varname> because that assignment is not part of
     <classname>R</classname>.  On the other hand, if
     <classname>S</classname> imports both <classname>Q</classname>
     and <classname>R</classname> in any order, it
     <emphasis>will</emphasis> see <classname>Q</classname>'s
     assignment to <varname>A</varname>.  If the reset operation were
     actually part of the assignment history rather than being a local
     operation, then whether or not <classname>S</classname> saw
     <classname>Q</classname>'s assignment to <varname>A</varname>
     would be dependent upon the order in which
     <classname>S</classname> loaded <classname>Q</classname> and
     <classname>R</classname>.  For items that are not in each other's
     dependency chains, the order is not deterministic.  This could
     cause very strange side effects: if one build item depended on
     other, it could sometimes not see all of that item's interface
     because of some third item that did a reset.  Note also that
     &abuild; uses a single interface parser to load a given interface
     file and any after-build files, so a reset in an after-build
     actually does effectively remove the effect of any assignments to
     that variable in the file that loads it.  Since a reset in an
     after-build file is not visible to the item itself, this is a
     useful construct for clearing interface variables that a build
     item means to set for its own use but not for its dependencies.
     For an example of this construct, see <xref
     linkend="ref.example.opaque-wrapper"/>.
    </para>
    <para>
     When a variable assignment is prefixed by a
     <function>flag</function> statement, the assignment entry that
     goes into the variable's assignment history is associated with
     the name of the build item and the flag.  When a variable value
     is retrieved, &abuild; filters out any assignments that are
     marked with a flag that is not set.  This makes it possible for
     &abuild; to store exactly one representation of each interface
     object rather than having to keep track of different instances
     for each possible combination of flags.  It also makes it
     possible for different build items to actually see different
     results for the same interface objects depending upon what flags
     they are requesting.
    </para>
    <para>
     &Abuild; only turns on interface flags when it retrieves variable
     values for export into the automatically generated file used by
     the back end (the <firstterm>dynamic output file</firstterm>,
     first introduced in <xref
     linkend="ref.abuild-interface-functionality-overview"/>).  It
     does not have any flags set when it references variables inside
     of other <filename>Abuild.interface</filename> files.  For
     example, if <classname>A</classname> does this:

     <programlisting>declare X string
declare Y string
X = v1
flag f1 override X = v2
Y = $(X)
</programlisting>
     the value of <varname>Y</varname> will
     <emphasis>always</emphasis> be <literal>v1</literal> in every
     build item's dynamic output file regardless of whether or not
     that build item sets the <varname>f1</varname> flag in its
     dependency on <classname>A</classname>.  This is because that is
     the value that <varname>X</varname> had at the time when
     <varname>Y</varname> was assigned since the flag was not in
     effect during the parsing of the interface file.  The value of
     <varname>X</varname> in the dynamic output files
     <emphasis>will</emphasis> be dependent upon whether the flag is
     in effect for the dependency on <classname>A</classname> because
     &abuild; does set flags before generating the dynamic output
     files.  This makes sense when you consider that &abuild; reads
     each <filename>Abuild.interface</filename> file once for each
     platform and that values of variables are not computed until they
     are needed.
    </para>
   </sect1>
   <sect1 id="ref.interface-loading">
    <title>Loading &Abuild; Interfaces</title>
    <para>
     When &abuild; prepares to build, it creates the
     <varname>base</varname> <classname>Interface</classname> object
     by reading <filename>private/base.interface</filename> from the
     &abuild; distribution.  Then, for every item that is a plugin in
     any known build tree (remember: an item can be a plugin in one
     build tree but not in another because plugin status is not
     inherited through backing areas or externals), &abuild; creates
     an <classname>InterfaceParser</classname> object, imports the
     base interface, and loads the plugin's
     <filename>plugin.interface</filename> file, if any.  Plugins'
     interface files are not allowed to have
     <function>after-build</function> files, so it is an error if any
     are declared.
    </para>
    <para>
     After this preparation has been done, &abuild; constructs the
     build graph (see <xref
     linkend="ref.construction-of-build-graph"/>.) and traverses the
     graph in dependency order to build each build item/platform pair.
     For each build item/platform pair, &abuild; creates an
     <classname>InterfaceParser</classname> object and retrieves the
     underlying <classname>Interface</classname> object.  Before
     loading that item's <filename>Abuild.interface</filename> file,
     if any, &abuild; first imports the base interface and the
     interfaces for any plugin that pertains to this build item.
     (These would be all items that were declared as plugins in the
     build item's home build tree.)  Then it imports the interfaces of
     all of its direct dependencies which, as nodes in the build
     graph, are actually build item/platform pairs.  Those interfaces,
     therefore, already include the interfaces of
     <emphasis>their</emphasis> direct dependencies, and so
     forth&mdash;this is how we achieve the effect of having each
     build item read the interfaces of its entire dependency chain.
    </para>
    <para>
     Once this has been done, &abuild; performs override assignments
     for all variables that are specific to the build item
     (<varname>ABUILD_THIS</varname>,
     <varname>ABUILD_OUTPUT_DIR</varname>, etc.) and then uses the
     <classname>InterfaceParser</classname> object to load the item's
     own <filename>Abuild.interface</filename> file.  At this point,
     the build item's interface is in the state required to build the
     item itself, so we perform the build.  If the build succeeds, we
     then see whether the <filename>Abuild.interface</filename> had
     any any <function>after-build</function> statements.  If so, we
     use the same <classname>InterfaceParser</classname> object to
     load those, verifying that each one has no
     <function>after-build</function> declarations of its own.  The
     resulting <classname>Interface</classname> object is then stored
     with the build item by platform so that it can be imported by
     items that depend on it.
    </para>
   </sect1>
  </chapter>
 </part>
 <part id="ref.part4" label="IV">
  <title>Appendices</title>
  <appendix id="ref.release-notes">
   <title>Release Notes</title>
   <para>
    This table includes a list of user-visible changes or changes to
    the documentation.
   </para>
   <variablelist>
    <varlistentry>
     <term>1.0: XXX</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Hitting CTRL-C in Windows while &abuild; was running
         <application>ant</application> would sometimes leave the
         console window in an unusable state as
         <application>ant</application>, a batch file, tried to ask
         the user whether to terminate the batch job.  On Windows,
         &abuild; now waits for subsidiary processes to exit before
         exiting itself.
        </para>
       </listitem>
       <listitem>
        <para>
         Trailing whitespace is now trimmed around
         <varname>abuild.hook-build-items</varname> in
         <filename>Abuild-ant.properties</filename>.
        </para>
       </listitem>
       <listitem>
        <para>
         New command line option <option>--find-conf</option>
         directs &abuild; to find the first
         <filename>Abuild.conf</filename> at or above the current
         directory and to run the build from there.
        </para>
       </listitem>
       <listitem>
        <para>
         Many additional improvements have been made to the
         documentation, thanks to input from reviewers mentioned in
         <xref linkend="ref.acknowledgments"/>.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.b3: November 13, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Support has been added for read only externals and for
         specifying a separate path for an external that is used only
         on Windows.
        </para>
       </listitem>
       <listitem>
        <para>
         If a
         <varname>WHOLE_lib_<replaceable>libname</replaceable></varname>
         variable is set during a build using the
         <filename>msvc</filename> compiler, an error message will be
         generated.  Previously, the whole library instruction would
         be silently ignored.
        </para>
       </listitem>
       <listitem>
        <para>
         Numerous improvements have been made to the documentation,
         thanks to input from reviewers mentioned in <xref
         linkend="ref.acknowledgments"/>.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
   </variablelist>
   <variablelist>
    <varlistentry>
     <term>1.0.b2: November 2, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>Removal of Deprecated Functionality</para>
        <itemizedlist>
         <listitem>
          <para>
           &Abuild; no longer automatically removes stray
           automatically generated files created by versions older
           than 1.0.a14.
          </para>
         </listitem>
         <listitem>
          <para>
           &Abuild; no longer accepts <varname>BI_RULES</varname> as a
           synonym for <varname>BUILD_ITEM_RULES</varname>.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Movement of Functionality to External Plugins</para>
        <itemizedlist>
         <listitem>
          <para>
           VxWorks and XLC support have been removed from &abuild; and
           are now available as plugins in a build tree maintained
           separately from &abuild;.
          </para>
         </listitem>
         <listitem>
          <para>
           Javadoc support is no longer provided by the default ant
           rules but is instead provided by a <command>doc</command>
           hook, which is provided separately.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>New Features</para>
        <itemizedlist>
         <listitem>
          <para>
           External trees may now be specified as absolute paths.
           This makes it easier to support external trees that contain
           things like libraries of build items that may be maintained
           separately from the projects that use them.
          </para>
         </listitem>
         <listitem>
          <para>
           The <option>-C
           <replaceable>directory</replaceable></option> option to the
           &abuild; command tells &abuild; to change directories to
           the given directory before doing anything.  Similar to
           <application>make</application>'s <option>-C</option>
           option.
          </para>
         </listitem>
         <listitem>
          <para>
           The <option>-lowpri</option> option to
           <command>platform</command> and
           <command>native-compiler</command> commands output from
           <command>list_platforms</command> scripts may now be
           specified when adding new platforms and native compilers
           from plugins.
          </para>
         </listitem>
         <listitem>
          <para>
           &Abuild; interface variable
           <varname>ABUILD_PLATFORM_TYPE</varname> is now defined.
          </para>
         </listitem>
         <listitem>
          <para>
           A program is now provided to verify proper operation of
           compiler plugins.  (See <xref
           linkend="ref.adding-toolchains"/>.)
          </para>
         </listitem>
         <listitem>
          <para>
           C/C++ rules will, in most cases, recognize orphan targets
           are deal with them properly.  (Stray object files in
           subdirectories of the output directory will not currently
           be detected.)
          </para>
         </listitem>
         <listitem>
          <para>
           The new make variable <varname>LINKWRAPPER</varname> can be
           set on the command line or in the
           <filename>Abuild.mk</filename> file to specify the name of
           a command to wrap the link step.  This is intended to be
           used to support tools such as
           <application>Purify</application> which wrap the link
           command in this fashion.
          </para>
         </listitem>
         <listitem>
          <para>
           The new variable <varname>LINK_AS_C</varname> may be set in
           an <filename>Abuild.mk</filename> file to cause all shared
           libraries and executables in that build item to be linked
           as straight C code instead of C++ code.  This avoids a
           dependency on the C++ runtime libraries for straight C
           code.
          </para>
         </listitem>
         <listitem>
          <para>
           A new example has been created to illustrate how to pass
           information safely from a <application>make</application>
           variable to your source code.  See <xref
           linkend="ref.example.auto-from-variable"/>.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Functionality Changes</para>
        <itemizedlist>
         <listitem>
          <para>
           The <option>-ansi</option> flag is no longer passed to
           <command>g++</command> by default for the
           <filename>gcc</filename> and <filename>mingw</filename>
           compilers.  If you want it, create a plugin that adds it to
           <varname>XCXXFLAGS</varname> (or
           <varname>XCFLAGS</varname>) in
           <filename>plugin.mk</filename> conditionally upon the
           compiler.  In older versions, <option>-ansi</option> was
           passed to <command>g++</command> but not
           <command>gcc</command>.
          </para>
         </listitem>
         <listitem>
          <para>
           The <command>doc</command> target for Java builds no longer
           runs <command>javadoc</command>.  Instead, this capability
           must be provided by a plugin.  The reason for this change
           is that there is too much site-specific policy in how the
           <command>javadoc</command> task would be invoked.  In light
           of this, the <command>pre-doc</command> and
           <command>post-doc</command> hooks have been replaced by a
           <command>doc</command> hook.
          </para>
         </listitem>
         <listitem>
          <para>
           A few error messages have been cleaned up so that, whenever
           possible, all &abuild; error messages are of a form that is
           parseable by the error-handling code in Emacs and Eclipse.
           (Most error messages already conformed, but a small number
           did not.)
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Bug Fixes</para>
        <itemizedlist>
         <listitem>
          <para>
           The <filename>autoconf</filename> rules have been fixed so
           that they do not generate warnings about undefined
           variables and work better by default for cross compiles.
          </para>
         </listitem>
         <listitem>
          <para>
           File-specific <varname>OFLAGS</varname>,
           <varname>DFLAGS</varname>, and <varname>WFLAGS</varname>
           variables now work properly when set to the empty string.
          </para>
         </listitem>
         <listitem>
          <para>
           On Windows, &abuild; no longer attempts to run perl if
           Cygwin perl is not the first perl in the path.  In verbose
           mode, a message to this effect is printed when perl is not
           found.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.b1: September 28, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>Warnings About Next Release</para>
        <itemizedlist>
         <listitem>
          <para>
           <emphasis role="bold">Note:</emphasis> This is intended to
           be the last release to include VxWorks and xlc support
           inside of &abuild;.  &Abuild;'s VxWorks and xlc support
           code should be moved into plugins prior to the next beta
           release of &abuild;.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Documentation Changes</para>
        <itemizedlist>
         <listitem>
          <para>
           The documentation has been substantially reorganized.  Many
           new sections have been added, and many parts have been
           rewritten.
          </para>
         </listitem>
         <listitem>
          <para>
           Examples are now spread throughout the documentation rather
           than being grouped together in one section.  (See <xref
           linkend="ref.list-of-examples"/> for a convenient list of
           examples.)  The contents of files referenced from the
           examples are now included inline in the text.  The contents
           of every file in the <filename>doc/example</filename>
           directory are no longer included in the document.
          </para>
         </listitem>
         <listitem>
          <para>
           The documentation has been converted from Texinfo to
           docbook.
          </para>
         </listitem>
         <listitem>
          <para>
           The documentation in the binary distribution is now
           installed as <filename>doc/abuild-manual.pdf</filename> and
           <filename>doc/abuild-manual.html</filename>.  There is also
           now a cascading stylesheet called
           <filename>doc/stylesheet.css</filename> that has to be in
           the same directory as the HTML version of the
           documentation.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>VxWorks Changes</para>
        <itemizedlist>
         <listitem>
          <para>
           Shared library and partial load script support has been
           added to vxworks.  When building an executable, &abuild;
           generates
           <filename><replaceable>binname</replaceable>.loaddata</filename>
           which is an executable shell script that copies all files
           that need to be loaded to a given directory in sequential
           order.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Basic Functionality Changes</para>
        <itemizedlist>
         <listitem>
          <para>
           Subtle changes have been made to how &abuild; picks which
           targets to apply to which build items: explicit targets are
           no longer applied to build items being built just to
           satisfy dependencies unless the new
           <option>--apply-targets-to-deps</option> option is
           specified.
          </para>
         </listitem>
         <listitem>
          <para>
           New name and pattern based build sets have been added.  See
           <xref linkend="ref.build-sets"/> for details.
          </para>
         </listitem>
         <listitem>
          <para>
           <option>--with-deps</option> is now exactly the same as
           <option>--build=current</option>.  Both behave the way
           <option>--with-deps</option> behaved in previous releases.
           To get the old behavior of
           <option>--build=current</option>, also specify the
           <option>--apply-targets-to-deps</option> option.
          </para>
         </listitem>
         <listitem>
          <para>
           When cleaning with a clean set, dependencies of items in
           the clean set are no longer cleaned by default.  To cause
           them to be cleaned as well, use the
           <option>--apply-targets-to-deps</option> option along with
           <option>--clean</option>.
          </para>
         </listitem>
         <listitem>
          <para>
           The <option>--verbose</option> option now prints additional
           information about what &abuild; is doing in addition to
           passing verbose flags to <application>make</application>
           and <application>ant</application>.
          </para>
         </listitem>
         <listitem>
          <para>
           The <option>--silent</option> flag now passes
           <option>-quiet</option> to <application>ant</application>
           in addition to suppressing some make output and some of
           &abuild;'s own output.
          </para>
         </listitem>
         <listitem>
          <para>
           Build item scoping rules have changed slightly: a build
           item no longer has automatic access to items in grandchild
           scopes or lower (<classname>A</classname> can still see
           <classname>A.B</classname>, but it can no longer see
           <classname>A.B.C</classname>).  Access can still be granted
           using the <property>visible-to</property> key if needed.
          </para>
         </listitem>
         <listitem>
          <para>
           Bug fix: if <option>--dump-data</option> and
           <option>--monitored</option> were both specified, the dump
           data output is now properly delimited by monitor
           statements.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Ant/Java changes</para>
        <itemizedlist>
         <listitem>
          <para>
           The <envar>ANT_HOME</envar> and <envar>JAVA_HOME</envar>
           environment variables are no longer required.  If
           <envar>ANT_HOME</envar> is set, &abuild; will still run the
           copy of <command>ant</command> in
           <filename>${ANT_HOME}/bin</filename>, but if it is not set,
           &abuild; will now attempt to run <command>ant</command>
           from the path.  This makes &abuild; completely free of
           mandatory environment variable settings.
          </para>
         </listitem>
         <listitem>
          <para>
           The ability to generate wrapper scripts to run Java
           &ldquo;executables&rdquo; has been moved into the standard
           <application>ant</application> support for &abuild;.  The
           old Java wrapper example has been changed to use this
           functionality instead of implementing it with a special
           build item.
          </para>
         </listitem>
         <listitem>
          <para>
           The new property
           <varname>abuild.include-ant-runtime</varname> has been
           added to include <application>ant</application>'s runtime
           libraries in your compilation class path.  This removes the
           need to access <envar>ANT_HOME</envar> (and therefore
           require it to be set) when compiling custom ant tasks.
          </para>
         </listitem>
         <listitem>
          <para>
           Boolean <filename>Abuild.interface</filename> variables are
           now converted to &ldquo;<literal>1</literal>&rdquo; and
           &ldquo;<literal>0</literal>&rdquo; for
           <application>ant</application>-based builds just as they
           are for <application>make</application>-based builds.
           Earlier versions of &abuild; used
           &ldquo;<literal>1</literal>&rdquo; and
           &ldquo;<literal>0</literal>&rdquo; for
           <application>make</application>-based builds and
           &ldquo;<literal>yes</literal>&rdquo; and
           &ldquo;<literal>no</literal>&rdquo; for
           <application>ant</application>-based builds.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Make/C/C++ Changes</para>
        <itemizedlist>
         <listitem>
          <para>
           &Abuild; now supports the creation of shared library files
           on UNIX platforms and DLL files on Windows platforms.  It
           also compiles all library files as position-independent
           code.  Users wishing to take advantage of this new
           functionality are recommended to rebuild from a clean
           state.
          </para>
         </listitem>
         <listitem>
          <para>
           It is now possible to generate the preprocessed version of
           any C or C++ source file by running <command>abuild
           <replaceable>SourceFile</replaceable>.i</command>.
          </para>
         </listitem>
         <listitem>
          <para>
           The old <filename>dummy</filename>
           <application>make</application> rules, never previously
           documented, have been renamed to <filename>empty</filename>
           and are now documented and officially supported.
          </para>
         </listitem>
         <listitem>
          <para>
           The <filename>texinfo</filename> rules have been removed.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a20: September 4, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>Configuration changes</para>
        <itemizedlist>
         <listitem>
          <para>
           Writable backing areas are no longer supported; all backing
           areas are read only.  The
           <filename>Abuild.backing</filename> file now contains only
           the path name of the backing area.
          </para>
         </listitem>
         <listitem>
          <para>
           Added new <varname>deleted</varname> key to
           <filename>Abuild.conf</filename>, making it possible to make
           build items in a backing area that are not present in the
           local tree inaccessible.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Invocation changes</para>
        <itemizedlist>
         <listitem>
          <para>
           Platform selection criteria are now supported via the
           <option>--platform-selector</option> or
           <option>-p</option> command-line option and the
           <varname>ABUILD_PLATFORM_SELECTORS</varname> environment
           variable.  This makes it possible to more tightly control
           which platforms will be built.  Along with this, the option
           field, formerly known as the flags field, of object code
           platforms is implemented along with a recommended method for
           generating release and debug builds.
          </para>
         </listitem>
         <listitem>
          <para>
           The <varname>all</varname> build set no longer ever builds
           items in backing areas since all backing areas are now read
           only.  The <varname>local</varname> build set no longer
           builds externals.  If you wish to build the local tree and
           its externals as well, use the <varname>all</varname> build
           set.  This makes the <varname>local</varname> build set do
           what people always thought it did anyway.
          </para>
         </listitem>
         <listitem>
          <para>
           The <option>--list-platforms</option> command-line
           argument lists all known object-code platforms grouped by
           platform type.
          </para>
         </listitem>
         <listitem>
          <para>
           The command <command>abuild --dump-data</command> will now
           attempt to generate dump data output even when there were
           errors.  This makes it possible to use the dump data output
           to help figure out what may be causing the errors.  The
           <varname>errors</varname> attribute will be present and
           have the value <literal>1</literal> when errors have been
           detected.
          </para>
         </listitem>
         <listitem>
          <para>
           Added <varname>--monitored</varname> flag to put &abuild; into
           monitored mode.  This is primarily intended to support
           front-ends to &abuild; that want to monitor progress.  For
           information, see <xref linkend="ref.monitored-mode"/>.
          </para>
         </listitem>
         <listitem>
          <para>
           &Abuild;'s choice of backend is no longer determined by the
           target type of the build item but is instead determined by
           the type of build file it has.  This change is invisible to
           users of older versions of &abuild; as it will always do the
           same thing for any existing configurations.  It does, in
           principle, make it possible to use ant for C/C++ builds and
           make for Java-based builds, provided the proper support code
           was added, and it also opens the door for supporting a wider
           array of backends.
          </para>
         </listitem>
         <listitem>
          <para>
           In many error messages, relative paths to
           <filename>Abuild.conf</filename> files have been replaced
           with absolute paths.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Make changes</para>
        <itemizedlist>
         <listitem>
          <para>
           The <varname>BI_RULES</varname> variable has been renamed to
           <varname>BUILD_ITEM_RULES</varname>.  A deprecation warning
           will be issued if <varname>BI_RULES</varname> is used.  This
           backward compatibility will be removed before 1.0.
          </para>
         </listitem>
         <listitem>
          <para>
           New documented flags have been added to
           <filename>ccxx.mk</filename>.  These changes are mostly
           user-invisible, but end user <filename>Abuild.mk</filename>
           files that set the <varname>DFLAGS</varname> make variable
           will need to be changed.
          </para>
         </listitem>
         <listitem>
          <para>
           Previously undocumented toolchain-specific make flags
           variables have been removed in favor of using conditionals
           based on <varname>$(CCXX_TOOLCHAIN)</varname>.
          </para>
         </listitem>
         <listitem>
          <para>
           <filename>ccxx.mk</filename> has been reworked somewhat to
           make it easier to write new compiler support files and to
           simplify overriding of debug, optimization, and warning
           flags.  These changes are invisible to the vast majority of
           end-user <filename>Abuild.mk</filename> files but have a
           significant impact on toolchain support files, which prior
           to this release, were all included in &abuild; anyway.  The
           <filename>ccxx.mk</filename> file itself is heavily
           commented.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Java changes</para>
        <itemizedlist>
         <listitem>
          <para>
           An alternative for Java builds has been provided.  In this
           alternative, you can write your own
           <filename>build.xml</filename> files with some minor
           limitations.
          </para>
         </listitem>
         <listitem>
          <para>
           <emphasis>Non-compatible change</emphasis>: there is now
           only one java platform, <filename>java</filename>.  The
           interface variable
           <varname>abuild.platform.bytecode</varname> is no longer
           defined.  &Abuild; no longer attempts to manage different java
           bytecode versions itself.  However, two new properties:
           <varname>abuild.source-java-version</varname> and
           <varname>abuild.target-java-version</varname> can now be set
           in <filename>Abuild-ant.properties</filename>.  This change
           is invisible to people who did not either access the
           <varname>abuild.platform.bytecode</varname> variable or the
           <filename>abuild-java5</filename> path.
          </para>
         </listitem>
         <listitem>
          <para>
           Bug fix: &abuild; will now work properly if
           <varname>$(ANT_HOME)</varname> points to a path with a space
           it in.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Platform changes</para>
        <itemizedlist>
         <listitem>
          <para>
           There is no longer support for nested platform types.  All
           the operating system-specific platform types
           (<filename>unix</filename>, <filename>windows</filename>,
           etc.) have been removed.  This is not a user-visible change
           since there were never any platforms in those platform
           types.  Note that new platforms and platform types may now
           be added in plugins.
          </para>
         </listitem>
         <listitem>
          <para>
           &Abuild;'s internal <command>list_platforms</command> command
           has moved from <filename>private/bin</filename> to
           <filename>private</filename> and generates new kinds of
           output.  &Abuild;'s own bootstrapping uses
           <filename>private/bin/bootstrap_native_platform</filename>.
          </para>
         </listitem>
         <listitem>
          <para>
           Full cross-platform dependency support is fully implemented.
           It is now possible to mention a platform type and platform
           selection criteria on a dependency declaration using the
           <varname>-platform</varname> option in the
           <varname>deps</varname> key in
           <filename>Abuild.conf</filename>.
          </para>
         </listitem>
         <listitem>
          <para>
           The <varname>USE_MSVC</varname> environment variable is no
           longer required for using Visual C/C++.  Instead, &abuild;
           will try to use it if the <varname>VCINSTALLDIR</varname>
           variable is set.  Based on Microsoft documentation, this
           appears to be a reliable test that the appropriate Visual
           Studio variables are in the environment.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para><option>--dump-data</option> changes</para>
        <itemizedlist>
         <listitem>
          <para>
           Since writable backing areas are no longer supported, there
           is no longer a <varname>writable</varname> attribute to the
           <varname>backing-area</varname> element.
          </para>
         </listitem>
         <listitem>
          <para>
           The <varname>platform-data</varname> element has been added.
           This gives overall platform information as well as
           build-tree-specific platform information.
          </para>
         </listitem>
         <listitem>
          <para>
           The <varname>deleted-items</varname> element has been added
           to <varname>build-tree</varname>.
          </para>
         </listitem>
         <listitem>
          <para>
           Several attributes and elements have been added because of
           plugin support.  In particular, the
           <varname>is-plugin</varname> and
           <varname>is-plugin-anywhere</varname> attributes have been
           added to <varname>build-item</varname>, the
           <varname>has-shadowed-dependencies</varname> attribute has
           been changed to <varname>has-shadowed-references</varname>
           and is also true if plugins are shadowed, and the new
           <varname>plugins</varname> element has been added.
          </para>
         </listitem>
         <listitem>
          <para>
           The new attribute <varname>external-depth</varname> has been
           added to <varname>build-item</varname>.  Items local to the
           build tree from which &abuild; was started are now
           detectable by having both <varname>external-depth</varname>
           and <varname>backing-depth</varname> equal to
           <varname>0</varname>.  (They can, as before, also be
           detected by having their home tree be the current build
           tree.)
          </para>
         </listitem>
         <listitem>
          <para>
           With full cross-platform dependencies supported, the
           <varname>dependency</varname> element now has an optional
           <varname>platform-type</varname> attribute.
          </para>
         </listitem>
         <listitem>
          <para>
           The <varname>build-platforms</varname> and
           <varname>known-platforms</varname> attributes have been
           removed from <varname>build-item</varname>, and the
           <varname>buildable-platforms</varname> attribute has been
           added.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a19: July 31, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>Java changes</para>
        <itemizedlist>
         <listitem>
          <para>
           <emphasis>Non-compatible change</emphasis>: Previously
           undocumented <filename>ear-contents</filename> and
           <filename>war-classpath</filename> directories are no longer
           used.  New documented <filename>classpath</filename>
           directory has been introduced for use in copying classpath
           files into archives.  This mechanism may change in the
           future.
          </para>
         </listitem>
         <listitem>
          <para>
           <emphasis>Non-compatible change</emphasis>: It is no longer
           possible to create a local JAR file in the same build item
           as an EAR file.  The EAR example in the Java Archive Types
           example has been updated to illustrate a different way to do
           this.
          </para>
         </listitem>
         <listitem>
          <para>
           <emphasis>Non-compatible change</emphasis>: For WAR build
           items, the property <varname>abuild.war-type</varname> must
           now be set to either <varname>client</varname> or
           <varname>server</varname>.
          </para>
         </listitem>
         <listitem>
          <para>
           It is now possible to add arbitrary files to an EAR file and
           to populate an EAR file's <filename>META-INF</filename>
           directory.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>New functionality</para>
        <itemizedlist>
         <listitem>
          <para>
           The new <option>--print-abuild-top</option> flag has been
           added to print the name of the &abuild;'s installation
           directory.
          </para>
         </listitem>
         <listitem>
          <para>
           <emphasis>Non-compatible change</emphasis>: the
           <varname>autofiles</varname> statement in
           <filename>Abuild.interface</filename> has been changed to
           <function>after-build</function> to more accurately reflect
           its purpose and functionality.
          </para>
         </listitem>
         <listitem>
          <para>
           Interface flags are now supported.  Build items can declare
           supported flags in their <filename>Abuild.conf</filename>
           files and can reference those flags in their
           <filename>Abuild.interface</filename> files.  They can also
           specify which flags should be set for other build items in
           their direct dependency list.
          </para>
         </listitem>
         <listitem>
          <para>
           <emphasis>Non-compatible change</emphasis>: in light of the
           introduction of interface flags,
           <varname>BI_PRIVATE</varname> and
           <filename>Private.mk</filename> are no longer supported.
           The private interface example illustrates how to support
           this construct in a cleaner way using interface flags.
          </para>
         </listitem>
         <listitem>
          <para>
           Build item traits are now supported.  This allows build
           items to be grouped based on functionality or relationships
           to other build items that fall outside of the dependency
           graph.
          </para>
         </listitem>
         <listitem>
          <para>
           Several examples in the documentation have been updated to
           demonstrate new functionality.  Some new examples have also
           been added.
          </para>
         </listitem>
         <listitem>
          <para>
           It is now possible to reset a variable in
           <filename>Abuild.interface</filename> using the
           <varname>reset</varname>, <varname>reset-all</varname>, and
           <varname>no-reset</varname> statements.  Please see the
           relevant sections of the document to understand how these
           work and the subtleties of their use.
          </para>
         </listitem>
         <listitem>
          <para>
           Externals that are resolved through backing areas now appear
           in the <option>--dump-data</option> output with the
           <varname>backed="1"</varname> attribute.  Before, they did
           not appear at all.
          </para>
         </listitem>
         <listitem>
          <para>
           Information about traits and flags have been added to
           <option>--dump-data</option> output.
          </para>
         </listitem>
         <listitem>
          <para>
           All whitespace-separated lists have been removed from
           <option>--dump-data</option> output and have been replaced
           by nested elements instead.  This made room for inclusion of
           flag and trait information in the dump data output and also
           makes it easier for applications to parse the XML.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
       <listitem>
        <para>Bug fixes</para>
        <itemizedlist>
         <listitem>
          <para>
           Incorrect regular expression could cause &ldquo;memory
           exhausted&rdquo; to be printed when certain syntax errors
           appeared in <filename>Abuild.conf</filename> files.
          </para>
         </listitem>
         <listitem>
          <para>
           Several cases involving whitespace handling were fixed in
           the interface parser.  Specifically, the following patterns
           could result in parse errors: trailing whitespace at the end
           an interface file without a line terminator, a continuation
           character in a file with Windows-style newlines, and a
           continuation character followed by a line that did not start
           with a space.
          </para>
         </listitem>
         <listitem>
          <para>
           Path comparison on Windows is now case-insensitive when
           computing one path relative to another.  When asking for one
           path relative to a path on a different drive, the first path
           is returned unchanged.  This should make &abuild; itself able
           to use backing areas on different drives, though this case
           has not been thoroughly tested.
          </para>
         </listitem>
         <listitem>
          <para>
           Short forms of command-line options added in 1.0.a14 have
           been added to <command>abuild --help</command>'s output.
          </para>
         </listitem>
        </itemizedlist>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a18: July 18, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Run junit tests with <varname>fork="true"</varname> for better
         performance.
        </para>
       </listitem>
       <listitem>
        <para>
         Support added for WAR files.
        </para>
       </listitem>
       <listitem>
        <para>
         The <filename>src/java</filename> directory is now optional.
         It makes sense to omit it for some WAR files as well as for
         JAR files that consist entirely of resources or automatically
         generated code.
        </para>
       </listitem>
       <listitem>
        <para>
         In order to support a wider range of java archive types, the
         <varname>abuild.jar-name</varname> and
         <varname>abuild.ear-name</varname> properties in
         <filename>Abuild-ant.properties</filename> must now include
         the filename extension of the archive file.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a17: July 9, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Implemented new build item accessibility scheme that allows
         nested namespace scopes.  To upgrade your build item names,
         please run <filename>misc/upgrade-scope-names</filename> from
         the &abuild; installation directory.  Two consecutive dashes
         (<varname>--</varname>) no longer has any special meaning in
         build item names.  &Abuild; also no longer requires the
         public parent of a private build item to exist.  For details
         on the new accessibility system, see <xref
         linkend="ref.build-item-name-scoping"/>.
        </para>
       </listitem>
       <listitem>
        <para>
         Added optional <varname>visible-to</varname> field to the
         <filename>Abuild.conf</filename> file to allow build items to
         expand their visibility as otherwise restricted by the new
         scoping rules.  This is also an optional attribute to
         <classname>BuildItem</classname> in the
         <option>--dump-data</option> output.
        </para>
       </listitem>
       <listitem>
        <para>
         Added &ldquo;mixed classification&rdquo; example to the
         complete example section.  This shows a pattern of how one
         might organize build items in a mixed classification
         environment.  It also shows a real-world application of the
         new <varname>visible-to</varname> field in the
         <filename>Abuild.conf</filename> file.
        </para>
       </listitem>
       <listitem>
        <para>
         Added an optional <varname>description</varname> field to
         <filename>Abuild.conf</filename>.  This is for informational
         use only.  It appears in the <option>--dump-data</option>
         output if present.
        </para>
       </listitem>
       <listitem>
        <para>
         Run pre- and post- compile and package hooks in Java even if
         the compile and package targets are not being run.  This makes
         it possible to, for example, generate wrappers from
         post-package hooks even if no packages are being created.  The
         Java example has been enhanced to illustrate this case.
        </para>
       </listitem>
       <listitem>
        <para>
         Bug fix: autoconf rules have been modified slightly so that
         they should work properly when <option>--make-jobs</option>
         is used.
        </para>
       </listitem>
       <listitem>
        <para>
         Added cygwin as a valid platform type as distinct from
         Windows.  Although &abuild; should in principle work just fine
         if compiled as a cygwin application, this has not been tested
         and there is no intention of actually supporting it.  However,
         there's also no good reason to hard-code into &abuild; the idea
         that when cygwin is present, it means Windows, not cygwin.
        </para>
       </listitem>
       <listitem>
        <para>
         Change layout of source directory: manual sources are now in
         <filename>src/manual</filename> and dump data DTD is now in
         the <filename>src</filename> directory.  The compiled manual
         in PDF and HTML formats along with the DTD are included in the
         <filename>doc</filename> directory in the binary distribution.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a16: June 22, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         &Abuild; no longer has to be in a directory called
         <filename>abuild</filename>.  Instead, it looks above the full
         path of the &abuild; executable for a directory that contains
         <filename>make/abuild.mk</filename>.  This means it's possible
         to install &abuild; under a directory named
         <filename>abuild-</filename><varname>version</varname>, for
         example.
        </para>
       </listitem>
       <listitem>
        <para>
         The ant <varname>package</varname> target has been recoded to
         avoid multiple invocations of the <varname>compile</varname>
         target.
        </para>
       </listitem>
       <listitem>
        <para>
         A small error was corrected in
         <filename>abuild_data.dtd</filename>.  A test case has been
         added to ensure that it is always accurate in future releases.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a15: June 18, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Basic Java support has been added.
        </para>
       </listitem>
       <listitem>
        <para>
         Add <option>-mlongcall</option> to vxworks compilation
        </para>
       </listitem>
       <listitem>
        <para>
         The documentation has been reorganized somewhat for greater
         clarity.  The contents of the example files have been moved to
         an appendix at the back of the document which makes them
         easier to separate when going through examples.
        </para>
       </listitem>
       <listitem>
        <para>
         A standard <command>doc</command> target has been added,
         though it does not yet do anything for make-based target types
        </para>
       </listitem>
       <listitem>
        <para>
         The <command>test</command> and <command>check</command>
         targets are now identical in functionality.  It used to be
         that <command>test</command> did not depend on all, but this
         is no longer the case.
        </para>
       </listitem>
       <listitem>
        <para>
         &Abuild; now looks in the <filename>qtest</filename> directory
         rather than the <filename>tests</filename> for qtest test
         suites.
        </para>
       </listitem>
       <listitem>
        <para>
         Environment variables may now appear in interface files using
         the syntax <varname>$(ENV:VARIABLE)</varname>.  Use sparingly.
        </para>
       </listitem>
       <listitem>
        <para>
         When cleaning with a clean set, items that have no build files
         are skipped.
        </para>
       </listitem>
       <listitem>
        <para>
         The <option>--</option> argument has been dropped in favor
         of <option>--make</option> and <option>--ant</option>
         options which pass arguments specifically to make or ant.
         Both options can be specified so that a mixed build can pass
         different arguments to make and to ant.
        </para>
       </listitem>
       <listitem>
        <para>
         The style of element names used in
         <option>--dump-data</option> has been changed from
         <varname>ThisStyle</varname> to <varname>this-style</varname>
        </para>
       </listitem>
       <listitem>
        <para>
         There is no longer a default value for the
         <varname>platform-types</varname> key in
         <filename>Abuild.conf</filename>.  The
         <filename>upgrade-interfaces</filename> script that assists
         with upgrading from pre-1.0.a14 versions of &abuild; will create
         values when necessary based on the old rules.
        </para>
       </listitem>
       <listitem>
        <para>
         Build item names are restricted to containing only
         alphanumeric characters, underscores, periods, and dashes.
        </para>
       </listitem>
       <listitem>
        <para>
         Added <option>--dump-build-graph</option> debugging option.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a14: May 18, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         A new XML-based <option>--dump-data</option> format has been
         implemented.
        </para>
       </listitem>
       <listitem>
        <para>
         Short forms of <option>--build=set</option>,
         <option>--clean=set</option>, and
         <option>--with-deps</option> options have been provided.
         See command line syntax for details.
        </para>
       </listitem>
       <listitem>
        <para>
         Clean sets are no longer automatically expanded to include
         recursively expanded dependencies.  The
         <varname>deps</varname> and <varname>current</varname>
         build/clean sets have been redefined to explicitly include
         expanded dependencies and therefore have no change of
         semantics.  The main result of this change is that running
         <option>--clean=desc</option> now no longer ever cleans
         anything not below the directory from which &abuild; was
         invoked.
        </para>
       </listitem>
       <listitem>
        <para>
         The option to pass <option>VAR=value</option> arguments to
         &abuild; and to have those passed on to make has been removed.
         If you need to do this, place these arguments after
         <option>--</option>, since all those arguments are passed
         directly to the backend anyway.
        </para>
       </listitem>
       <listitem>
        <para>
         The documentation was updated to accurately reflect recent
         changes of platform handling, the new interface system, and
         refactoring that was performed during the C++ port.
        </para>
       </listitem>
       <listitem>
        <para>
         Implementation of completely new interface system.  Interfaces
         now use <filename>Abuild.interface</filename> instead of
         <filename>Interface.mk</filename>.  The new interface files
         are loaded internally by &abuild; and are no longer tied to GNU
         Make.
        </para>
       </listitem>
       <listitem>
        <para>
         Remove Windows-only <varname>XLIBS</varname> interface
         variable.  Instead of appending <filename>xyz</filename> to
         <varname>XLIBS</varname>, append <filename>xyz.lib</filename>
         to <varname>XLINKFLAGS</varname>.
        </para>
       </listitem>
       <listitem>
        <para>
         Bug fix: detect parent/child loops better while reading
         <filename>Abuild.conf</filename> files.  Parent loops were
         previously detected properly, but child loops were not
         necessarily detected.
        </para>
       </listitem>
       <listitem>
        <para>
         Terminology change: &ldquo;architecture&rdquo; is now
         &ldquo;platform&rdquo;, &ldquo;architecture category&rdquo; is
         now &ldquo;platform type&rdquo;, and &ldquo;architecture
         class&rdquo; is now &ldquo;target type.&rdquo; The
         <varname>arch</varname> key in
         <filename>Abuild.conf</filename> is now
         <varname>platform-types</varname>.  The
         <varname>archclass</varname> key in
         <filename>Abuild.interface</filename> is now
         <varname>target-type</varname>.
        </para>
       </listitem>
       <listitem>
        <para>
         Changes to platform identifiers: this release includes an
         early implementation of the new
         <varname>os.cpu.toolset.compiler[.flags]</varname> format.
        </para>
       </listitem>
       <listitem>
        <para>
         The <filename>vc7</filename> C/C++ toolchain is now called
         <filename>msvc</filename> since it works with Visual C++
         version 8 as well as version 7.  The environment variable
         USE_MSVC, rather than USE_VC7, now selects it.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a13: May 1, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         &Abuild;, previously implemented in Perl, was rewritten in C++.
        </para>
       </listitem>
       <listitem>
        <para>
         For compilers that support it, gen_deps is bypassed in favor
         of the compiler's internal dependency generation capabilities.
         This will improve build performance for those compilers.  As
         of 1.0.a13, the only compiler that produces exactly what
         &abuild; needs is gcc.
        </para>
       </listitem>
       <listitem>
        <para>
         The default optimization for gcc and xlc has been changed from
         -O3 to -O2 as many people have reported problems with -O3.
         For most cases, -O3 will not make a big difference in
         performance, but there are some cases in which it can be a
         significant difference.  For those cases, it is still possible
         to override this for individual files or individual build
         items if desired.
        </para>
       </listitem>
       <listitem>
        <para>
         &Abuild; no longer provides the variables
         <varname>abHOST_ARCH</varname>, <varname>abHOST_OS</varname>,
         <varname>abHOST_DIST</varname>, or
         <varname>abHOST_CPU</varname> as they did not previously
         contain reliably useful values and were never documented.
        </para>
       </listitem>
       <listitem>
        <para>
         When looking for GNU Make, &abuild; now checks all occurrences
         of gmake and then of make in the path, stopping with the first
         one that appears to be GNU Make version 3.81 or newer.  It
         previously checked only the first occurrence of make or gmake
         and required that occurrence to be GNU Make 3.81 or newer.
        </para>
       </listitem>
       <listitem>
        <para>
         &Abuild; now only checks for GNU Make if at least one build item
         requires it.
        </para>
       </listitem>
       <listitem>
        <para>
         &Abuild; no longer calls umask 002 before starting to build.
         This means that it will not create group-writable files unless
         the calling user's umask is set appropriately.  The old
         behavior of calling umask 002 was a vestige of the past when
         it was common for multiple users to be building in the same
         directory.  Although this may sometimes still be desirable,
         it's not the place of &abuild; to override the user's umask
         setting.
        </para>
       </listitem>
       <listitem>
        <para>
         Starting in version 1.0.a11, &abuild; no longer creates
         <filename>.ab-dynamic.mk</filename> outside of architecture
         directories.  Versions 1.0.a11 and 1.0.a12 deleted stray
         <filename>.ab-dynamic.mk</filename> files created by older
         versions of &abuild;.  This version no longer does.  If you
         are upgrading from a version older than 1.0.a11, you should
         manually remove any <filename>.ab-dynamic.mk</filename> files
         that are left lying around.  Since &abuild; automatically
         creates those that it needs on each run, running
         <command>find . -name .ab-dynamic.mk -exec rm {} \;</command>
         will do the job.
        </para>
       </listitem>
       <listitem>
        <para>
         The <option>--host-arch</option> command line argument was
         removed.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a12: April 2, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         It is now possible to specify that a library should be linked
         in its entirety by defining the variable
         <varname>WHOLE_lib_libname</varname> for library
         <filename>libname</filename> in the
         <filename>Interface.mk</filename> file that provides
         <filename>libname</filename>.  For systems that use the gnu
         linker, this results in the <varname>--whole-archive</varname>
         flag being used for the specified library.  Note that not all
         systems support this feature, so this behavior should not be
         relied upon when not absolutely necessary.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a11: March 30, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Move <varname>XLINKFLAGS</varname> to the end of the link step
         (after <varname>LIBS</varname>) for all C/C++ compilers.
        </para>
       </listitem>
       <listitem>
        <para>
         The <option>-j</option> flag now controls how many build
         items &abuild; will attempt to build in parallel and is no
         longer passed to make.  The new command-line option
         <option>--make-jobs</option> can be used to pass the
         <option>-j</option> flag to make.
        </para>
       </listitem>
       <listitem>
        <para>
         &Abuild; no longer uses any recursion at all.  Rather than
         having a top-level &abuild; process invoke subsidiary &abuild;
         processes for specific builds, &abuild; computes all the
         directories in which builds will be run and invokes the
         backend directly in each directory.  &Abuild; now manages all of
         its build order computations and parallelism computations
         itself rather than relying on GNU Make.  This means that
         &abuild; now uses GNU Make only for performing the actual
         compiles, which greatly simplifies &abuild;'s make code and
         makes it much more able to support alternative backends.  A
         pleasant side effect of this change is that &abuild; runs much
         more quickly and no longer needs to cache any information.  A
         version of &abuild; to appear in the very near future will
         change the mechanism through which build items publish their
         build interfaces, eliminating
         <filename>Interface.mk</filename> and replacing it with some
         other mechanism.
        </para>
       </listitem>
       <listitem>
        <para>
         &Abuild; no longer creates <filename>.abuild-cache.*</filename>
         directories at all and also no longer creates
         <filename>.ab-dynamic.mk</filename> files outside of
         architecture subdirectories.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a10: March 26, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Various Windows portability fixes including changing cache
         file names to make them shorter.
        </para>
       </listitem>
       <listitem>
        <para>
         Deprecated debugging flag removed from VC7 toolchain support
         file.
        </para>
       </listitem>
       <listitem>
        <para>
         &Abuild; now works when run via a symbolic link.  In other
         words, it now works to add a symlink called &abuild; in your
         path and have it point to the real &abuild;.  If you attempted
         to do this in prior versions, you would get an error because
         &abuild; would not be able to find its data files.
        </para>
       </listitem>
       <listitem>
        <para>
         The support test framework is now called
         <filename>qtest</filename>, and the name of its driver is
         <filename>qtest-driver</filename>.  &Abuild; has been updated
         with the new name information.
        </para>
       </listitem>
       <listitem>
        <para>
         Bug fix: &abuild; was previously invoking qtest-driver in a
         manner such that test coverage files would never been seen.
         This is now fixed.  (Requires the qtest version >= 1.0.a1 as
         well.)
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a9: March 14, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Use <varname>$WIND_HOME</varname> instead of
         <filename>/opt/WindRiver</filename> to find the vxworks
         toolchain.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a8: March 13, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Change the hacked vxworks support to be just a little bit less
         hacked.  &Abuild; no longer uses the hacked toolchain on hydra1;
         it now recognizes the vendor-supplied cross compiler toolchain
         if installed in <filename>/opt/WindRiver</filename>, resulting
         in working C++ support for a Linux Intel to vworks ppc cross
         compilation.  This is still a temporary solution, but it is
         closer to the real thing.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a7: March 7, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Make a few changes to the temporary vxworks support to allow
         C++ compilation to succeed.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a6: March 6, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         &Abuild; now loads <filename>Interface.mk</filename> files in
         forward rather than reverse dependency order.  In order to
         avoid having to change all the
         <filename>Interface.mk</filename> files to ensure that library
         ordering is still correct, special case code has been added to
         handle the <varname>INCLUDES</varname>,
         <varname>LIBS</varname>, and <varname>LIBDIRS</varname>
         variables.  This turned out to be a temporary solution, as
         hoped.  For a detailed description of this change, please see
         the 1.0.a6 documentation.
        </para>
       </listitem>
       <listitem>
        <para>
         &Abuild; now loads the C/C++ toolchain configuration before
         loading any architecture-specific rules.  This means that the
         <filename>autoconf</filename> rules will know the proper C/C++
         toolchain even if the <filename>ccxx</filename> rules are not
         also loaded.
        </para>
       </listitem>
       <listitem>
        <para>
         Bug fix: some of the <varname>XCFLAGS</varname>-like variables
         were not being used at all the right places after the
         refactoring of the toolchain support.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a5: March 5, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Bug fix: don't include <filename>Interface.mk</filename> files
         for build items whose architecture categories don't match what
         is being built.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a4: February 23, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Change VxWorks support so that library targets build normal
         <filename>.a</filename> files and executable targets build
         <filename>.out</filename> files that can link with libraries.
         This is still not necessarily the final way it's going to
         work.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a3: February 20, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Fix <varname>.LIBPATTERNS</varname> warning on VxWorks
        </para>
       </listitem>
       <listitem>
        <para>
         Detect when a build set contains no buildable items and exit
         cleanly without attempting to build.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a2: February 19, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         The strings <varname>as C</varname> or <varname>as
         C++</varname> are included in &abuild;'s output when compiling C
         and C++ respectively.
        </para>
       </listitem>
       <listitem>
        <para>
         Internal <filename>make</filename> directory has been
         reorganized.  The two changes that affect the documentation
         are that <filename>make/rules/arch-indep</filename> is now
         <filename>make/rules/indep</filename> and
         <filename>make/rules/arch-dep</filename> is now
         <filename>make/rules/archdep</filename>.  Other changes were
         also made.
        </para>
       </listitem>
       <listitem>
        <para>
         Hacked in support for xlc (IBM compiler) and vxworks.  The xlc
         and vxworks are specific to a particular configuration and
         will disappear in a future release when a suitable facility is
         added for extending &abuild; with external rules.
        </para>
       </listitem>
       <listitem>
        <para>
         The beginning of multiple architecture support has been
         implemented.  It now works to set <varname>arch</varname> in
         <filename>Abuild.conf</filename> to <varname>native
         vxworks</varname> to build for both the native platform and
         for VxWorks or to set it to <varname>vxworks</varname> to
         build for VxWorks only.  The rest of the documentation has not
         been updated to reflect this yet.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>1.0.a1: February 8, 2007</term>
     <listitem>
      <itemizedlist>
       <listitem>
        <para>
         Separate specification of private interfaces are now supported
         through use of the <filename>Private.mk</filename> file.
         (This mechanism was changed in a later release.)
        </para>
       </listitem>
       <listitem>
        <para>
         &Abuild; now enforces that <varname>BI_RULES</varname> in
         <filename>Abuild.mk</filename> may not contain inaccessible
         private build items.
        </para>
       </listitem>
      </itemizedlist>
     </listitem>
    </varlistentry>
   </variablelist>
  </appendix>
  <appendix id="ref.known-limitations">
   <title>Known Limitations</title>
   <para>
    Here we list known limitations of &abuild;.  These limitations will
    hopefully be addressed over time.
   </para>
   <variablelist>
    <varlistentry>
     <term>undefined variable checks</term>
     <listitem>
      <para>
       The way we check for undefined variables in rules files makes
       undefined variable warnings get executed even when running
       debugging targets or help targets such as
       <command>rules-help</command> or
       <command>interfaces-help</command>.  It might be better to have
       a standard location for rules documentation so that &abuild; can
       display it directly without actually including rules.  Perhaps
       the help targets could be come special targets handled directly
       by &abuild; (as are the <varname>no-op</varname> and
       <varname>clean</varname> targets).
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>weak support for test coverage</term>
     <listitem>
      <para>
       The <application>qtest</application> test framework, which is
       integrated with &abuild;, has support for test coverage.  It
       requires that the <varname>TC_SRCS</varname> environment
       variable be initialized with a list of source files to check.
       Right now, users must code this by hand by putting an
       <literal>export TC_SRCS = ...</literal> command in their
       <filename>Abuild.mk</filename> files.  This is somewhat
       error-prone and seems like something &abuild; should handle
       automatically.  The problem is that it is very common for one
       build item to be testing another build item, and there's no
       clean way for a build item to export its source list.  In
       practice, this isn't such a big deal because test suites that
       include coverage support must have intimate knowledge of the
       source code.  As long as we use
       <varname>$(abDIR_build-item)</varname> variables to refer to
       the directory that contains the source files, we're probably
       not in such bad shape.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>no <application>Junit</application> examples</term>
     <listitem>
      <para>
       At this time, our java examples with test suites have
       <application>qtest</application>-based test suites.  It would
       be preferable for us to show
       <application>Junit</application>-based test suites instead or
       as well, but we don't have a good mechanism at present of doing
       this since <application>Junit</application> is not bundled with
       &abuild;.  Most likely, build trees that use
       <application>Junit</application> would include support for it
       as a plugin or as a build item that testers would depend on,
       but it seems unfortunate to have to have a hook or dependency
       in order to make use of some built-in functionality.  Another
       alternative would be to have a contributed plugins area that
       could have plugins for things like boost and
       <application>Junit</application>.  The user of these
       contributed plugins would be responsible for installing the
       third-party tool and configuring the plugins to find them.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>dependence on Cygwin for <application>make</application> on
     Windows</term>
     <listitem>
      <para>
       On Windows, using &abuild; to build Java code works fine and
       should be comparable in performance to building Java code with
       &abuild; on a UNIX platform.  For C/C++ builds, &abuild; uses Cygwin
       for GNU Make and perl.  It can use Visual Studio for compilation
       and can produce targets that don't depend on Cygwin, but
       &abuild; itself uses Cygwin.  The overhead of running things in
       Cygwin is very high, and the result is that &abuild; for C/C++ is
       slow on Windows even though the Windows compilers are actually
       quite fast.  We need to get &abuild; working properly with a
       native GNU Make and remove the last uses of perl from &abuild;,
       which means rewriting <command>gen_deps</command> in C++ or
       otherwise folding it into the &abuild; sources.  The automated
       test system that is integrated in &abuild; is likely to stay in
       perl and likely to continue to require Cygwin, but perhaps that
       can be rewritten or can be ported to a native perl when a native
       Windows perl that supports the <varname>"|-"</varname> form of
       open is released.  Empirical tests suggest that compiling
       multiple source files at once results in negligible performance
       improvement.  Most of the performance penalty on Windows appears
       to be spawning processes, particularly when Cygwin is involved.
       This is true, however, even with Visual Studio's nmake utility
       and not the result of something about how &abuild; is implemented.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Incomplete mingw Support</term>
     <listitem>
      <para>
       Although mingw is partially supported and the mingw compiler
       passes the compiler verification support, mingw support is not
       really complete in &abuild;.  In particular, we only offer
       mingw as a valid compiler if the <envar>MINGW</envar>
       environment variable is set to <literal>1</literal>, and we use
       <command>gcc -mnocygwin</command> from cygwin to get mingw.
       This means that absolute Windows paths won't work.  Although
       &abuild; tries to use relative paths when possible, paths on
       different drive letters are always given as absolute paths.  In
       spite of these limitations, mingw support should work okay for
       build environments in which everything is under the same drive
       letter.  If necessary, builds that have to work with both
       Microsoft Visual C++ and mingw can have conditionals in their
       build or interface files.  Hopefully a future version of
       &abuild; will better address this.
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>Java archive creation</term>
     <listitem>
      <para>
       EAR and WAR files are currently populated from the contents
       of the <varname>abuild.classpath</varname> interface
       variable.  It may be necessary to have some other mechanism
       for specifying the contents of these types of archive files
       should it be necessary to have a build item create and
       &ldquo;export&rdquo; something without wanting it to be
       deployed.  This problem will be addressed again as the need
       arises.
      </para>
      <para>
       EAR and WAR files both contain items that are copied from
       <varname>abuild.classpath</varname>.  There is no general
       facility for allowing this functionality.  If we were to have
       to support some other archive type such as a RAR file that
       also contains items from other build items, there would be no
       convenient way to handle this using &abuild;'s JAR creation
       abilities.  It would be possible to implement it by defining
       a <varname>generate</varname> hook that copied files into the
       generated <filename>src/resources</filename> directory.  The
       names of these files could come from any
       <filename>Abuild.interface</filename> variable, including one
       provided by a build item for this purpose.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </appendix>
  <appendix id="ref.dump-data">
   <title><option>--dump-data</option> Format</title>
   <para>
    The <option>--dump-data</option> option outputs all the
    information &abuild; knows about the build trees after reading all
    the <filename>Abuild.conf</filename> files and performing all of
    its validations.  Its output is in an XML format that corresponds
    to the following DTD.  Comments in the DTD describe the meanings of
    the fields.  The DTD may be found in
    <filename>src/abuild_data.dtd</filename> in the &abuild; source
    distribution or in <filename>doc/abuild_data.dtd</filename> in the
    binary distribution.
   </para>
   <para>
    When there are no errors, the <option>--dump-data</option> output
    always presents build trees and build items such that no reference
    is ever made to an item that has not already been seen.  When there
    are errors, the <varname>errors</varname> attribute to the
    <varname>abuild-data</varname> element will be present and will
    have the value <varname>1</varname>.  In this case, this guarantee
    does not apply as the output may contain circular dependencies,
    unknown build items, etc.
   </para>
   <para>
    The contents of the <filename>abuild_data.dtd</filename> file are
    included here for reference.
    <?dump-data?>
   </para>
  </appendix>
  <appendix id="ref.ccxx.mk">
   <title>The <filename>ccxx.mk</filename> File</title>
   <para>
    Here we include a complete copy of
    <filename>make/rules/object-code/ccxx.mk</filename>.
   </para>
   <?ccxx-mk?>
  </appendix>
  <appendix id="ref.list-of-examples">
   <title>List of Examples</title>
   <para>
    The following sections within this document describe examples from
    <filename>doc/example</filename>.  Many of the files from the
    example directory are included in the document, but not all of
    them are.  For the maximum benefit, you are encouraged to make a
    copy of the <filename>doc/example</filename> directory so that you
    can follow along and make modifications.
   </para>
   <?list-of-examples?>
  </appendix>
 </part>
 <index id="abuild.index"/>
</book>
