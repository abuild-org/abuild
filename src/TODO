
=== Changes Targeted for Version 1.1 ===

Name Changes
============


Core Changes
============

 * Implement an optional 1.0-compatibility mode.  See "Compatibility"
   below.

 * Replace "this" with "name".  Make use of "this" deprecated.

 * Consider moving hook selection into Abuild.conf and removing
   BUILD_ITEM_RULES and abuild.hook-build-items.  This way, abuild can
   automatically create the dependency, accessing checking can be
   handled properly, the rename functionality can be implemented, we
   might be able to remove the ABUILD_DIR stuff, and we can use this
   information for the built-in help system.  We can probably also
   remove ACCESSIBLE_BUILD_ITEMS (or whatever it's called).

 * When abuild is run with no arguments, its default behavior will be
   to act as if --with-deps had been specified.  A new flag
   "--no-deps" can be used for the case in which one should build just
   the item with no dependencies.

 * Require trees to be named.  Replace externals with subtrees.
   Eliminate absolute path and read-only externals, but provide an
   alternative to read-only externals for the desired functionality.
   Simplify Backing Areas. See "Revamped Build Tree Structure" below
   for details.

 * Change build set "all" to mean all known build items in all trees
   in the forest.

 * Add build set "reachable-trees" to mean all build trees in the
   tree-deps chain, including the current build tree.  This build set
   would build what "all" builds in 1.0.

 * Add build set "tree-deps" to mean all build trees that are
   tree-deps (recursively) but not the current build tree.

 * Add flag --with-rdeps to add to the build set all items anywhere in
   the forest that have items in the initial build set in their
   expanded dependency chains.

 * Add -ro-path and -rw-path options to tell abuild to treat some or
   all build items as read only based on path.  This should provide a
   more robust approach than using read-only externals for preventing
   cross-tree builds when they are not desired.  Consider these trees:

         A
       / | \
      B  C  D

   If B and D both have C as a tree dependency and are independent
   from each other, you might want to build C first and then have both
   B and D built in parallel while treating C as read only.  This
   would provide a way to do that.

   Both -ro-path and -rw-path may appear multiple times, but they may
   not both appear.  If neither -ro-path nor -rw-path is specified,
   everything is read/write.  If -ro-path is specified, everything not
   listed in -ro-path is read/write.  If -rw-path is specified,
   everything not specified with -rw-path is read-only.

   Paths may be absolute or relative.  Relative paths are resolved
   relative to the starting directory of abuild (after any -C is
   evaluated).

 * Implement two forms of conditional dependencies:

    - deps: item -optional
    - tree-deps: tree-name -optional

   In the first case, abuild will not complain if a given dependency
   is not found.  Some mechanism will be provided that will enable a
   build item to test in its Abuild.interface file (and therefore in
   its Abuild.mk or Abuild-ant.properties file) whether an optional
   dependency is satisfied.

   In the second case, abuild will not complain if a given tree is not
   found.  Furthermore, any fully qualified regular item dependency of
   the form tree::item for optional tree "tree" will be treated as an
   optional dependency.

   A new boolean interface variable (analogous to abDIR_build-item)
   will be defined for each build item that exists or that is declared
   as an optional dependency.  This variable will be true iff the
   build item exists.

 * Consider a "renamed-to" or "replaced-by" keyword that would be used
   to indicate that a build item has been replaced by another build
   item.  It would be allowed only in root Abuild.conf files.  Its
   semantics would include that BUILD_ITEM_RULES and
   abuild.hook-build-items would follow the name change.  This is
   stronger than using deps to make the old name depend on the new
   name and also eliminates the need to create build items whose only
   purpose is to depend on their replacements.  Internally, abuild
   would make the new name an alias for the old name.  That way,
   things like abDIR_OLD-ITEM-NAME would contain the path to the new
   item.

 * Move "deleted-items" key from root Abuild.conf to Abuild.backing.
   Also add a "deleted-trees" key.  New Abuild.backing format:

     backing-areas: /path/to/backing/area
     deleted-trees: trees not to shadow
     deleted-items: items not to shadow (fully qualified as tree-name::item)

 * It would be good if errors in a part of the collection of build
   trees that are not relevant to you don't impact your build.  For
   example, if a forest contains A, B, and C and your build contains
   no items from C, then integrity errors in C should be ignored
   unless --full-integrity is specified.  (Do we already to this?)

 * Make cross-platform dependencies obey platform selectors.  The
   rationale for not doing this was that the command-line and
   environment should not affect the shape of the build graph, but
   this is a myth anyway.  People can always run with DFLAGS=-g or
   NO_XLC=1.  If a specific compiler or option is required, it can be
   specified explicitly with the platform-specifier in the
   dependency.  This implies additional requirements:

    - Make sure "-platform native:option=" works to specify no option

    - Make sure it is possible to express "I want the version of X
      build with compiler A on platform P but the default compiler
      everywhere else."  This can probably be done with a combination
      of platform-specific dependencies and platform conditionals.


Documentation
=============

 * Describe somewhere why we don't provide information about platforms
   in the interface files for java and indep.  Basically, it would be
   a bug to have an interface variable have a different value in
   different contexts when it might influence a build that could be
   used on multiple platforms.  For example, an indep build item could
   write out some value based on a platform variable and then that
   information could be wrong when the results of the build were used
   on a different platform.  If you really need to know what platform
   you are on for something indep or java, you can always get the
   information using a cross-platform dependency, which at least makes
   it visible.  But remember that text files containing
   platform-dependent values (like pathnames, etc.) are in fact
   platform-dependent.

 * Work this material about the rationale for revamping externals and
   backing areas into an appendix.

   A principal failing in abuild 1.0 stems from the use of paths to
   specify the locations of external build trees -- "external-dirs" is
   used to convey both dependency and location information.  This is
   against a fundamental design principle of abuild and must be
   corrected.  Another serious problem is the interaction between
   backing areas and externals: setting up backing areas for trees
   with lots of externals is complex to the point of being
   impractical.

   Projects that desire certain parts of their trees to be potentially
   compile-time independent from other parts have to break things into
   multiple trees and use externals.  This sometimes results in build
   areas consisting of many more trees than I envisioned in my
   original design.  (I had originally envisioned externals as being a
   rarely-used feature, primarily intended for supporting builds at
   multiple classification levels or supporting central libraries of
   reusable build items.)

   Consider first the case of externals without backing areas.  If
   there are multiple build trees with complex "external"
   relationships between them, then there is an implicit build
   "forest" consisting of multiple build trees which must be organized
   relative to each other in a particular way.  Knowledge of this
   relative organization of trees is not represented in any one place
   but rather is distributed through all the root Abuild.conf files,
   usually with considerable but non-obvious duplication of knowledge
   (exactly the situation abuild's name-based organization was
   designed to avoid).  For example, if A, B, C, and D are build trees
   whose roots are under a common parent, you could have a situation
   in which A declares ../B and ../C as externals and B declares ../D
   as an external.  There is no single place where A, B, C, and D are
   even all mentioned, yet abuild will require them to all be in the
   same directory.  This situation becomes much worse when build trees
   are at different levels -- the same tree may be referred to by
   multiple different relative paths.  This creates great confusion,
   and makes it very to move a tree around or even find who is
   referencing a particular tree.

   When backing areas are added to the mix, the problem is further
   compounded.  If a build tree contains other external build trees
   nested inside of it, use of a backing area with the parent tree, in
   practice, requires use of a specific backing area on the child
   tree, especially when externals need to be resolved from a backing
   area.  Consider this arrangement of build trees:

      A       F
    / | \    /
   B  C  D  G
   |
   E

   with the following external relationships:

   E -> C, D
   D -> G

   Suppose you have a backing area forest containing A and F, and a
   local build area containing only A.  In this case, in the local A,
   it is necessary to have backing areas for E, C, and D in, and they
   all have to point to the right locations under A's backing area.
   In addition to that, people remain generally in the dark about how
   externals are resolved through backing areas.  It's
   (understandably) hard for people to understand the idea that a
   relative path expressed in an Abuild.conf file may be resolve
   relative to another directory that is listed in an Abuild.backing
   file.

   In defense of the original design, when abuild was a simple perl
   script that used "make" to do most of its work, this made the
   initial implementation very easy -- abuild just replaced the tree
   top path with the backing area path and re-invoked itself.
   However, given the current state of abuild's evolution and an
   understanding of how these features are actually used, it is
   obvious that the current implementation is no longer tenable.

   It is clear that build trees deserve to be named entities, and that
   just as is true with build items, the location of any given tree
   must appear in only one place within a build area.  It is also
   clear that use of backing areas when multiple trees are involved is
   too cumbersome to be practical.


Usability Improvements
======================

 * When abuild says "something failed", it should list which items
   failed.  Count only full failures, not dep failures.

 * Provide arguments for querying abuild's state, such as locating
   build items (perhaps with pattern matching), listing all trees with
   locations and dependencies, summarizing the state of all plugin
   information (which items are plugins in any tree, which tree
   provides the plugin, and which trees use the plugin), etc.  The
   --dump-data option will always be available for providing full
   information, but providing a more human-readable format for
   commonly needed information will help.

 * Abuild 1.0's build ordering is created by doing a stable
   topological sort on an alphabetical list of build items.  Instead
   of starting with a straight alphabetical list, have the starting
   list group build items by build tree.  To create the starting list,
   first topologically sort the alphabetical list of trees, and then
   alphabetically sort build items within each tree.  When this list
   is topologically sorted, it should result in build items from the
   same tree being built together (in a single-threaded build), and
   will generally result in items with higher visibility being built
   earlier in the process.

 * Consider adding a new special-case target "help" that would provide
   help in a manner that does not require invoking a back end.  This
   should remove the serious problems with rules-help and
   interface-help, and should get around the problem of trying to echo
   help information from a build file.  This would work by having
   abuild automatically display certain internal help files and build
   item-provided help files.  Most likely, abuild would just display
   all the help files provided by other build items that impact your
   build (dependents, plugins, rule/hook build items, etc.) as well as
   internal help files.  Help files, including internal ones, should
   provide a list of variables that can be set or read, what they
   mean, and how to use them.

 * Make sure abuild --help references the build/clean set list from
   the --build and --clean argument description, and make sure there
   is a reference to the platform selector information from the
   --platform-selector argument description.  Also divide the output
   clearly into OPTIONS and TARGETS.

 * Incorporate as much of abuild-lint as possible or otherwise include
   abuild-lint in the distribution.

 * Provide a way to get --dump-data's into a relational database.
   Ideally, we shouldn't have to link with sqlite.  Maybe have an
   option that causes --dump-data to generate a script file that can
   be used with sqlite3 rather than generating XML data.
   Alternatively, we can create xsl/perl code that loads directly into
   a sqlite database or that creates the input file.  It's probably
   okay if we create the SQL such that an erroneous dumpdata won't
   load.  For example, the SQL can enforce uniqueness and referential
   integrity constraints even though they may not be satisfied when
   there are errors.


Plugins
=======

 * Support buildable plugins with platform type "indep".  See
   "Buildable Plugins" below.


Abuild Contrib
==============

 * Upgrade all contributed build items to use abuild 1.1 files.

 * Make sure any compiler plugins included with abuild contrib have
   the 1.0.2 fixes integrated into them.

 * Include a generic UNIX compiler buildable plugin

 * Consider including a libtool buildable plugin


Platform Issues
===============

 * Allow platforms, but not platform types, to flow "backward" across
   tree dependencies.  Specifically, consider the following:

   A: platform type T1, available platforms p1, p2
   B: platform type T1, available platforms p1
   A -> B

   Allow B to build on platform p2 even if that platform is defined in
   a tree that B doesn't declare as a dependency.  Even allow this if
   the platform that defines p2 is defined in a tree that depends on
   B's tree.

 * Pass information about the native os, cpu, and toolset to
   list_platforms.  See comment in Abuild::loadPlatformData before
   invocation of list_platforms.

 * If possible, remove the temporary ABUILD_FORCE_32BIT hack or make
   it permanent.  Search for FORCE32 in the code.  The only references
   are in private/bin/get_native_platform_data and
   make/toolchains/gcc.mk.  For a description, see release notes in
   the documentation.

 * Implement platform conditionals, described below.


Changes to "make" Code
======================

 * Need a better solution for files that are automatically generated
   by optional tools.  Abuild itself could use this for flex/bison
   files.  We could also use it for cases like xbinder where
   generating the files requires a special license.  We need a clean
   way to handle the following:

    - Regeneration of the files if they are out of date and the tools
      are available.

    - Use of cached files if they are not out of date.

    - Error if the files are out of date and the tools are not
      available.

   This implies, at least for these cases, some kind of checksum-based
   method (rather than using modification times) to tell whether files
   are out of date.  That way, checkouts from the version control
   system can work even when the CM system does not preserve
   modification times.

 * Deprecate LINK_SHLIBS.  Give a deprecation warning of $(origin
   LINK_SHLIBS) is not 'undefined'.  A stub for this already exists in
   ccxx.mk.


Changes to "ant" Code
=====================

 * Strongly consider distributing junit, groovy, and if needed,
   ant-contrib in abuild's lib directory.  If we do the ant launcher,
   we might be able to get away from invoking ant at all, in which
   case we might want to embed ant as well.

 * Strongly consider implementation of ant launcher.

 * Conventions on properties:

    - abuild.property can be set by a user in Abuild-ant.properties.
      These are documented in end user documentation.

    - abuild.protected.property can be safely accessed by hook authors
      or by local build files.  These are documented in hook author
      documentation.

    - abuild.private.property is intended for use within abuild's own
      ant framework and should not be accessed by users.  These
      properties are subject to change at any time.  These are not
      documented unless by comments in the code.

 * Incorporate misc/abuild-groovy.  Load the groovy task and make it
   available for others to use.  In abuild 1.0, there is no mechanism
   for adding a new build target that is visible to all build items
   (as one can do with plugin.mk in make-based builds).  The main
   reason for this is that adding new targets requires use of <import>
   from the top level (or else the new target will not be defined when
   ant tries to invoke it), and there is no way to run import inside a
   target or top-level task.  To get around this, use groovy to
   generate an xml file that imports all the hook files and then
   import that automatically generated xml file as in the
   misc/abuild-groovy example.  Consider folding the logic of
   checkForTarget into run-hooks.  Rethink whether we want to call
   this ant-hooks.xml or something else.  They are now imported, so
   they can contain more than just hooks, but best practices should
   still dictate their use primarily for hooks.  We'll have to remind
   people in the documentation that ant will do what ant does if you
   create the same target in multiple places (whoever gets loaded
   first wins, but everyone's version can be accessed as
   projectname.targetname).  Best practice should be to add a target
   that just calls hooks by the same name.  Everyone can call
   <run-hooks> from their own tasks.  Since hooks are implemented as
   private targets, the name clash problem doesn't happen.  If
   everyone defines their new targets by calling hooks, then if two
   people define new targets with the same names, it won't matter that
   much.  There's still the question of dependencies (in the ant
   sense), but this is no different from what would happen if we had a
   library of ant code that people imported on their own.

 * Remove/deprecate abuild.use-local-hooks and have this behavior
   enabled by default.  Any declared local build file should ben
   imported and searched for hooks.

 * With groovy support, make sure any place we iterate over
   comma-separated lists behaves properly with respect to whitespace.

 * We use the privately set "debug" and "deprecation" properties in
   abuild.xml to set debug and deprecation.  These should really be set
   using documented abuild properties, and we should figure out what
   other similar properties we might want to set in this way.

 * Strongly consider removing support for higher-level archives from
   abuild's ant framework.

 * Provide a way for a user to specify an externally created manifest
   file.  Users can do this cleanly with a <manifest> task in their
   own ant code, and we can hook it in using abuild's own jar creation
   task.

 * With the ability to add new targets, remove the "deploy" and
   "other" targets.  The other ones are probably okay (except
   interface-help, rules-help, and properties-help, which should be
   replaced by the new help system).


Platform Conditionals
=====================

(This item is low priority for 1.1.)

The goal is to support some kind of platform-based conditional
dependency while preserving the fundamental design goal of having a
static build graph.  We will support this only for build items of type
native.  Here's how it would work:

 * Native build items can specify some kind of platform-based
   inclusion/exclusion rules in Abuild.conf.  Maybe we'll add keywords
   build-if-platform-matches and build-unless-platform-matches, each
   of which takes arguments of the form a.b.c.d.  Each field can be a
   fixed string or * and is matched against the corresponding field of
   the platform identifier.  If both keywords appear, platform strings
   have to satisfy both.  For example,

   build-if-platform-matches: linux.*.*.gcc *.*.*.xlc
   build-unless-platform-matches: windows.*.*.*

   would mean to build on linux with gcc and everywhere except windows
   on xlc.

 * Abuild will first construct and validate the build graph
   disregarding platform restrictions.  This ensures that the build
   graph can't be invalid for some combination of available platforms
   and not for others.

 * Once the build graph is validated, abuild will traverse the build
   graph again and prune the graph at each node whose platform doesn't
   satisfy the platform restrictions.

There are several possible implications to think through.  What
happens with build items that get built "as needed" to satisfy
platform constraints but then are no longer needed after pruning?  It
may be that we have to create two build graphs, one that disregards
platform restrictions and one that doesn't.  The second build graph
should always be a proper subset of the first one, so there should be
no possibility of errors existing in the second one.

But actually, it's worse than that.  What about items that get added
to the build set just to satisfy dependencies that are no longer
required?  Do we want those?  It's like we have to mark build items as
explicit or implicit and then prune any unreferenced implicit items
after paying attention to platform restrictions.

Consider native build items:

a: b c
b: d

b is 'windows only'

When doing abuild -d from a on a non-windows platform, we only want to
build a and c, but when doing abuild -b all on a non-windows platform,
we want a, c, and d.  In the first case, d is an implicit member of
the build set, and in the second case, d is an explicit member.  For
the build graph, we can mark things as explicit if they are explicit
items on selected platforms.  Explicit items on as-needed platforms
are implicit.  To detect unreferenced implicit members, we could
traverse the pruned build graph starting from each explicit node and
mark things as seen when we encounter them.  Then, anything that's not
seen can be removed.  We'll need to test cases with platform-specific
dependencies to make sure the logic is sound.  Also consider whether
the special failure build item used to implement recovery from certain
types of cycle errors should be explicit.


Buildable Plugins
=================

There are a number of potential uses for plugins that can't presently
be realized because plugins have to be completely static.  For
example, it would be useful to be able to create a generic UNIX
compiler plugin that must be configured using autoconf by the user
before starting to build or that would use autoconf or libtool to
figure out certain flags, such as the proper flags to create shared
libraries.  Buildable plugins could also be used to force certain
steps to be performed early in a build, such as checking for proper
environment variable settings or making architectural checks on
dependency rules that go beyond what can be enforced through abuild's
internal mechanisms.  It may also be possible to use global, buildable
plugins to implement some kind of project-wide configuration
mechanism.

Making plugins buildable implies that abuild has to have build plugins
before anyone might use them.  Since plugins are loaded in declaration
order in each tree, this results in declaration order implying some
kind of dependency-like relationship.  To determine build order, make
a dependency graph among buildable plugins where a dependency is
created from each plugin to its immediate predecessor in the build
order.  This is done for global plugins and for each tree.  If there
are any cycles (caused by buildable plugins being loaded in different
orders across different trees), it is an error.  If not, the first
phase of the build is to build plugins.

Since plugins are loaded in declaration order in each tree, this
approach guarantees that buildable plugins are built before other
plugins that may reference them.  One could argue that such logic
should be applied to all plugins since it is possible for plugins
to interact, but I would argue that this would create unnecessary
constraints.  If one plugin really requires another plugin, one
should first rethink whether the plugins are being used sensibly,
and if they really are, then the plugin should just check for the
existence of a variable/property defined by the other plugin.  The
case of buildable plugins is a little different because a plugin
may not even work before it is build.

If we require buildable plugins to have platform type "indep", then
it's probably also okay for plugin.interface files to have after-build
files, something that is currently disallowed since plugins are
instantiated for each possible platform.

In order to make it possible for the outcome of a plugin's build step
to influence what platforms it provides, it will be necessary for
abuild to build a plugin before executing its list_platforms file.

Consider carefully how explicit targets should apply to plugins.  As
currently coded, --apply-targets-to-deps will result in explicit
targets being applied to plugins.


Building Abuild
===============

 * Consider creating a ./configure that finds boost libraries and
   deals properly with pthread.  Then consider packaging auto-srcs
   with abuild sources.  Check on debian to see if this works with the
   latest flex.  Consider making the re-entrant scanner switch, made
   possible by controlling the flex and bison files provided that
   there is an autoconf check for the right versions of flex and
   bison.  See ~/source/work-software/argon/third-party-support/boost
   for sample boost autoconf code.

   It might be possible to make this work properly when abuild is
   building itself by having a buildable plugin that checks to make
   sure configure has been run.  Bootstrapping makefile can fail if
   configure hasn't been run.


Revamped Build Tree Structure
=============================

Introduce the concept of a "build forest".  A build forest is a
collection of related build trees that are physically located under a
common root.  Build forests already exist with abuild 1.0, but they
are not an explicit entity.

Eliminate the parent-dir key.  Build item X's parent directory is the
next higher directory, if any, whose Abuild.conf lists X's directory
in its child-dirs key.  We must enforce that child-dirs may not
contain .. in any path element, and that there are no intervening
Abuild.conf files between a parent and child Abuild.conf.

Require build tree root Abuild.conf files to include a "tree-name" key
which provides the name of the build tree.  Any Abuild.conf file may
contain a tree-name key.  This makes it the root of a subtree, which
functions very much as externals do in abuild 1.0.  Subtrees are
hooked into the forest like any other build item: through a
higher-level directory's child-dirs key.

Eliminate the external-dirs key.  Introduce in its place a "tree-deps"
key which takes a list of tree names rather than tree paths.  Since we
have no longer have the concept of externals, we no longer have the
concept of read-only externals.  To support the pattern of building a
tree without building any of the other subtrees that it uses, users
must specify -ro-path or -rw-path on the command line at build time.
Absolute path externals also disappear, but they were a bad idea to
begin with.

Introduce the tree-name::item-name syntax to refer to a
fully-qualified build item name.  This allows build item names to be
disambiguated across build trees.  If build tree A includes X and Y
with X -> Y and build tree B shows up with its own Y, a reference to Y
from within A should resolve to A's Y.  If there is a desire to reach
a Y in tree B, A can refer to B::Y.  Since colon is not currently a
valid character in a build item name, there is no issue with backward
compatibility.  (Need to think about how this interacts with
name-based access control, but it will probably interact fine.)

Allow Abuild.backing files only at forest roots, and allow multiple
backing areas.  Introduce a new Abuild.backing syntax in which one or
more backing areas may be specified in a backing-areas keyword, as in

  backing-areas: /path/to/ba1 /path/to/ba2

Backing areas as searched in the order in which they appear, and in a
depth-first fashion.  The normal integrity guarantee still applies.

Disallow build item directories from being symbolic links.  When a
symbolic link is detected, suggest for people to use a backing area
instead.  This is more practical with support for multiple backing
areas.

Traits, supported flags, and plugins behave with respect to subtrees
in 1.1 just as they behaved with respect to externals in 1.0.  This
means that it is still necessary to repeat plugin declaration lists
for each subtree.  Although this is somewhat unfortunate, it makes it
possible to have reasonable semantics when building an isolated
subtree outside of the context of a backing area.

Example:

  OLD:

   Top-level Abuild.conf files in each leaf below.  No way to know of
   all build trees or their relative positions without visiting each
   root.  No way to get list of build tree roots other than exhaustive
   search.

   top                  (no Abuild.conf)
   |
   |-- common           root Abuild.conf; no externals
   |
   |-- proj1
   |   |
   |   |-- interface
   |   |   |
   |   |   |-- comp1    external-dirs: ../../../common
   |   |   |
   |   |   `-- comp2    external-dirs: ../../../common
   |   |
   |   `-- private
   |       |
   |       |-- comp1    external-dirs: ../../interface/comp1
   |       |
   |       `-- comp2    external-dirs: ../../interface/comp2 ../comp1
   |
   `-- proj2
       |
       |-- common       external-dirs: ../../common
       |
       |-- comp1        external-dirs: ../common
       |
       `-- comp2        external-dirs: ../comp1

  Note that ../../common from proj2/common is the same as
  ../../../common from proj1/interface/comp1 and different from
  ../common in proj2/comp1.


  NEW:

   Top-level Abuild.conf file in top directory; subtrees are hooked in
   with child-dirs just like any other subdirectory.

   top                  tree-name: top
   |
   |-- common           tree-name: common
   |
   |-- proj1
   |   |
   |   |-- interface
   |   |   |
   |   |   |-- comp1    tree-name: proj1-comp1; tree-deps: common
   |   |   |
   |   |   `-- comp2    tree-name: proj1-comp2; tree-deps: common
   |   |
   |   `-- private
   |       |
   |       |-- comp1    tree-name: proj1-comp1-impl; tree-deps: proj1-comp1
   |       |
   |       `-- comp2    tree-name: proj1-comp2-impl;
   |                    tree-deps: proj1-comp2 proj1-comp1
   `-- proj2
       |
       |-- common       tree-name: proj2-common; tree-deps: common
       |
       |-- comp1        tree-name: proj2-comp1; tree-deps: proj2-common
       |
       `-- comp2        tree-name: proj2-comp2; tree-deps: proj2-comp1



Traversal algorithm (approximate since the real algorithm will have
compatibility stuff in it):

 * Find the root of the current build forest.

   English:

   Keep walking up the file system looking for directories containing
   Abuild.conf.  If you find one such that there is no higher
   Abuild.conf or the next higher one doesn't reference it as a child,
   and if this Abuild.conf file has a tree-name key or contains no
   keys other than child-dirs, it is the forest root.

   Pseudocode:

   cur_build_item = this directory
   forest_top = nil

   do until end search
     if cur_build_item's Abuild.conf contains tree-name key OR
           cur_build_item's Abuild.conf contains only child-dirs
        forest_top = cur_build_item
     parent_build_item = next higher Abuild.conf
     if parent_build_item exists and has child pointing to cur_build_item
        cur_build_item = parent_build_item
     else
        if forest_top == cur_build_item
           this is found forest root
	   end search
        else
           forest_top = nil
           error: unable to find top of build forest

   Note that if a parent Abuild.conf is found but it doesn't have a
   child-dirs key that points to the child build item, and if the
   child build item is a build tree root, the search stops, and there
   is no error or warning reported.  This is a normal case of a
   separate, independent tree nested inside another tree.  Examples of
   when you might have this would include test suites that create
   build trees (such as abuild's own test suite) or instances in which
   abuild may be used to build third-party software distributions
   nested within something that contains Abuild.conf files.  If this
   tree was supposed to be connected into higher trees and was not,
   there will probably be unresolved tree-deps or deps values.

 * If the root of the forest does not contain an Abuild.backing, then
   this is an unbacked forest.  If it does contain an Abuild.backing
   file, ensure that each backing area points to a tree root (not
   necessarily a forest root).  In that case, search for the backing
   tree's forest root.  Continue until an unbacked forest is found.
   Traverse the unbacked forest (as described below).

   Note that we impose no restrictions on whether the backing area
   points to the same tree or even to a backing forest that contains
   the same tree.  This makes it possible to add an entirely new
   subtree in a work area that backs to some other area, and then to
   have the backing area later get included inside of a higher-level
   tree without impacting the work area.  This also means that cases
   where we might have used read-only, absolute-path externals in
   abuild 1.0 would now work with multiple backing areas in abuild
   1.1.

 * Traverse the build forest.

     traverse:

     if current item has a tree-name key
        set cur_tree to name of tree
     store current build item in cur_tree
     for each dir in child-dirs
        ensure that dir has no path elements equal to ".."
        if dir has more than one path element
           ensure that no intermediate directories have Abuild.conf
        traverse recursively from dir

 * Verify that each tree in the forest is uniquely named

 * Copy build items from the backing area forests that are absent from
   the local forest into the local list.  Exclude build items that are
   listed as deleted or that belong to trees that are listed as
   deleted in the Abuild.backing file.

 * Make sure that the graph implied by the tree-deps key is an
   error-free directed acyclic graph.  Do not do checks to ensure that
   is bipartite with respect to backing area traversal; save this
   check for the build item level.  This makes it possible to sparsely
   shadow a build tree for the purpose of adding items to it.

 * Check dependencies and build item references (but do not report
   errors) for the whole forest rather than doing it separately for
   each build item and copying build items around.  (We only copy
   build items from backing areas, not subtrees.)  Just disallow
   resolution of any build item name in a tree not declared as used.
   This makes it possible to issue error messages akin to "A is not
   allowed to depend on B since A-tree has not declared B-tree as in
   its tree-used key."

 * If in full integrity mode, report all dependency and integrity
   errors.  Otherwise, report errors only for subtrees relevant to the
   current build.

Need to flesh out an example that includes both searchlight and
lh3-style trees.


Compatibility
=============

By default, abuild 1.1 will recognize all valid 1.0 build trees and
will issue deprecation warnings with concrete fix suggestions,
including a reference to the 1.0 to 1.1 conversion tool, whenever it
sees a deprecated construct.  It will also be possible to run abuild
in strict 1.1 mode, in which case obsolete 1.0 constructs will not be
recognized at all.  In compatibility mode, there will be an option for
suppressing deprecation warnings for backing areas a read-only
externals only.  There will be no option for suppressing deprecation
warnings for writable build trees and build items.

Compatibility mode will work by having abuild map a 1.0 structure into
the internal representation of a 1.1 structure.  Compatibility does
not apply to the command-line invocation of abuild, but only to
Abuild.conf and other build files.  There are some corner cases where
abuild will possibly fail in compatibility mode, such as with
interleaved build items (parent and child dirs skipping over each
other) or backing areas that point to different backing forests.

Algorithm for determining whether a build item is a root build item:

 * If any key that is only allowed in a root build item appears, it is
   a root

 * Else if there is an Abuild.backing in the same directory, it is a
   root

 * Else if there is a parent-dir key, it is not a root

 * Else if it has any obsolete 1.0 keys ("this"), it is a root

 * Else if it has any new 1.1 keys, it is not a root

 * Else if any children have parent-dir keys, assume it is a root

 * Else assume it is not a root

Here is the full traversal algorithm, including compatibility support.

  // Find candidate top.  If this is pure 1.1, this will find the
  // actual top.

  cur_build_item = this directory
  candidate_top = nil

  do until end search
    if cur_build_item looks like a root (as determined above) OR
	  cur_build_item's Abuild.conf contains only child-dirs
       candidate_top = cur_build_item
    parent_build_item = next higher Abuild.conf
    if parent_build_item exists and has child pointing to cur_build_item
       cur_build_item = parent_build_item
    else
       if candidate_top == cur_build_item
	  end search
       else
	  candidate_top = nil
	  error: unable to find top of build forest

  If no obsolete 1.0 keys were found, done.  Otherwise, proceed.

  // Traverse looking for build items with externals.

  roots (queue) = candidate_top

  while roots
     candidate_root = shift(roots)

XXX HERE.  We need some rules about when externals can appear.  For
example, maybe we should disallow anything child-dirs: points to from
containing external-dirs.  This means you have to convert a build tree
to 1.1 before you can hook it into a forest with child-dirs.  A
converted tree could still have an external that points to an
unconverted tree, and an unconverted tree could have an external that
points to a converted tree.  This means you don't have to go looking
through child-dirs for external-dirs.

So child-dirs: -> something with external-dirs: is an error.

Will that work?

We could create a virtual top level that uses external-dirs to point
into other trees that haven't been converted and child-dirs to point
to trees that have been converted.

When we are looking for the root, if we end up with a root that has
external-dirs, we know there's not going to be a higher tree that
points to it with child-dirs.  We could, in that case, look for a
higher tree that points to it with external-dirs.  Then THAT would be
the forest root for the hybrid case.

Maybe it's not necessary.

-----





The following mapping is used in compatibility mode.  Unless otherwise
stated, all statements apply to parsing of Abuild.conf files.  In all
cases, a deprecation warning is issued when any mapping rule is
applied.

 * If "this" is seen:

    - If "name" is also seen, error

    - Else treat "this" as name

 * If "parent-dir" is seen:

    - If there are any Abuild.conf between here and the parent, error

    - Else if parent does not point to us as child, error

    - Else give a warning about parent-dir and ignore

 * If "deleted-items" is seen, give a warning, and treat it as if we
   had read it out of an Abuild.backing file.

 * If this is a root build item (see below for how we detect this) and
   there is no "tree-name" key, generate a tree name of the form
   _tree.<rnd>.<nnn> where <rnd> is a random number (to prevent anyone
   from referencing these tree names anywhere) and nnn is a sequential
   number incremented each time we see a new tree.

 * If external-dirs is encountered:

    - If external dir is an absolute path, treat it as a backing area.
      This is not exactly the same thing, but it's the best we can do.

    - If the external is read-only and no -ro-path or -rw-path flags
      were given on the command line, act as if its path had been
      specified with -ro-path.  This is also slightly different since
      any subtrees would be treated as read-only by -ro-path and not
      be a read-only external.

    - If the external points to a tree with no name, generate a name
      for the tree and generate the appropriate tree dependency

 * If an Abuild.backing file is found that contains a path on a line
   by itself, treat it as if it were a file that contained a single
   backing area and no deletions.

Make a list of build tree roots that are not accessed as an external
or child from any other build item.  Assert that if there were no
errors and we didn't apply any 1.0-compatibility logic, then there is
only one such root.  If is exactly one such root, allow an
Abuild.backing file to exist in that location, and ignore (with
deprecation warning) any other Abuild.backing files.  Otherwise,
ignore (with deprecation warning) all Abuild.backing files.  This is
not strictly compatible behavior either since it breaks cases of lots
of trees pointing to different backing areas.


Conversion
==========

XXX

 * find all roots

 * explore connections via externals between roots to identify islands

 * create virtual top for each island?

 * create single virtual top for all islands?



----------------------------------------------------------------------

=== Things with no Specific Release Target ===

Windows Issues
==============

 * There are some Windows path issues.  You can't use absolute paths
   in Windows as long as cygwin is in use because cygwin gnu make will
   not interpret absolute paths in the same way that Windows will for
   purposes of dependencies in .dep files, library dependencies, etc.
   Relative paths should work, but they don't always work because
   Windows seems to have limits on the number of times .. may appear
   in a path (among possibly other things), and besides, there is no
   way to construct a relative path to a file under another drive
   letter.  Ideally, we should be using something like msys and/or
   gnuwin32 rather than cygwin, along with supporting ActivePerl, but
   this has major implications since qtest doesn't currently work
   without cygwin, not to mention the fact that the test suite makes
   free use of unix constructs.

 * gen_deps: rewrite in C++ so that it doesn't force a runtime
   dependency on perl.  It should be a fallback for cases when
   compilers can't generate dependency information.  With gcc, use -MD
   -MF -MP to generate proper .dep files.  xlc: "-M -MF a.dep" works,
   but there is no equivalent to -MP, so we'll need to postprocess.
   VC: there seems to be a /showIncludes option that we may be able to
   exploit.  Not sure what versions of VC++ have this.  This will be
   worth doing if we can remove a runtime dependency on Cygwin for
   Windows/C++.  For non-Windows systems, requiring perl is not a big
   deal.


Compiler/Platform Configuration
===============================

There is a general problem with compiler options, 32-bit and 64-bit
compilers, project-specific configuration, supporting compilers that
aren't known in advance, etc.  This is kind of what toolset was
designed to handle.  The following items are possibly contradictory or
interdependent and need to be sorted out better.  These items all
imply certain things that may need to be done very early in abuild's
life even before private/bin/get_native_platform_data is called.

 * Need a more flexible way of handling compiler options.  It should
   be possible to create plugins that add compiler options to
   internally supported compilers, and options should be able to be
   meaningfully selected in groups.  For example, it should be
   possible to add {m32, m64} that can't be specified together and
   {debug, release} that can't be specified together while allowing
   debug+m32 or release+m64 or other permutations.  This implies the
   need for a canonical form.

 * We need some way for people to change the toolset portion of the
   platform string in a global way for a particular collection of
   build trees.

 * There needs to be better cross-compiler support for things like
   building 32-bit code on a 64-bit system.  Adding -m32 doesn't
   really do it because why should have you
   linux.x86_64.rhel51.gcc.m32 be the same as linux.ix86.rhel51.gcc?


Java Problems
=============

We probably need a different approach to Java.  Ant was not designed
to be used as a framework, and it doesn't work very well when used in
this way.

 * In order to get wars in ear files, we need to add them to
   abuild.classpath.  Although this is harmless, it's sort of an abuse
   of abuild.classpath.

 * Ant launcher: consider having a Java-based ant launcher that abuild
   communicates with via some kind of IPC to make launching ant more
   efficient.  See ~/argon/tmp/ant-launcher and email X-ArgonCount:
   23536 in abuild, 4/3/2008, subject "preliminary ant launcher
   experiment".  For communication between abuild and the ant
   launcher, see ~/source/examples/portability/socket-java-c++-workers.

 * ant with build failure appears not to exit abnormally in Windows.
   This is a bug in ant.bat and could be worked around by using our
   own ant launcher.

 * We don't detect when inaccessible build items are referenced in
   abuild.hook-build-items.  This won't matter anymore if we move hook
   specification to Abuild.conf.

 * Abuild has no real way to support a difference between compile-time
   classpaths and run-time classpaths.

 * Reconsider using depends task for compile in abuild.xml.

 * Signed jar support will eventually be required.  See whether this
   should be provided by default.  Most likely it should not as it can
   be provided easily with a hook.

 * Our default java compile rule doesn't notice if a .java file was
   removed.  Maybe we want to force full recompilation if the list of
   files changed, or maybe we want to delete class files that appear
   to have come from non-existent java files.  I'm not sure what
   happens with nested/inner classes that disappeared....does javac
   automatically remove the corresponding class files?  This would be
   an easy experiment to try.

 * Consider supporting creation of multiple jar files with different
   contents analogous to different libraries being created from a
   single C++ build item.

 * Ant seems to not complain when populating an ear file from a
   classpath that contains non-existent items.  In general, there may
   be an issue with not getting any notification of non-existent
   classpath items.  Note that, sometimes, you want to try to create
   an ear even of some of its contents aren't there, so this may not
   really be a problem worth fixing.  If we can fix it, we should be
   able to control on a per-build-item basis whether it is an error
   condition or just a warning, probably having "error" be the
   default.

 * The classpath in the manifest for a jar should only include
   first-level dependencies.  Transitive dependencies are satisfied
   automatically.


Known Bugs
==========

 * Piping ANSI color stuff through ant on Windows doesn't work.  When
   running qtest from ant on Windows, qtest correctly generates the
   ansi color codes, but they don't get displayed right through ant,
   at least in cygwin.


Issues, Enhancement Ideas
=========================

See also "Known Limitations" in the documentation.

 * Test qtest coverage from abuild test suite.  Relatively low
   priority since abuild's test suite itself uses coverage, so
   abuild's qtest coverage support is exercised every time the abuild
   test suite is run.  (It's just that you might not notice if it
   weren't there.)

 * Think about implementing a dependency analyzer that would look at
   first-level includes to figure out what the correct list of direct
   dependencies should be.

 * Consider having --silent invoke make with --no-print-directory.  If
   we do this, we should follow build item failure with a message that
   contains the name, path, and platform of whatever failed.

 * Consider having an abuild template generator that can run if no
   Abuild.conf or other files are present.  This would spit out
   commented template files.  Alternatively, could be a command-line
   wizard or something.

 * To check for all Abuild.mk files that define local targets:
   pcregrep '^\s*\S+\s*:(\Z|[^=])' **/Abuild.mk

 * Consider using re-entrant scanners instead of C++ scanners.  This
   requires flex >= 2.5.33.  Have abuild's own build process detect
   whether or not a new enough version of flex is available.  If so,
   it should generate the parsers and attempt to update a cached copy
   of the automatically generated files if they have changed.
   Otherwise, it should use the cached files by adding them to SRCS in
   place of the automatically generated ones.  We also need to disable
   warnings for the flex-generated code.  Use %option nounistd.  (This
   suggestion may be simplified if better support for files generated
   by optional tools is added.)

 * It would be nice if there were a mechanism for providing
   documentation on traits so that --list-traits could tell the user
   how each trait was intended to be used.

 * Consider capturing the output of the backend so that we can
   de-interleave output when running parallel builds (or mark each
   line of output with the build item/platform data), separate error
   from informational output, etc.  It is possible to create pipe-like
   handles with CreatePipe in Windows and to use them to initialize
   hStdInput, hStdOutput, and hStdError fields of the startupinfo
   parameter to CreateProcess.  There is an example at
   http://lists.trolltech.com/qt-interest/1999-09/thread00282-0.html
   There is also some kind of Win32 Job API used by the perl
   Win32::Job classes (CreateJobObject).  This may provide a better
   solution than our current CTRL-C handling.  See if boost provides
   anything that could do this.

 * Clean up ~/source/examples/java/native/abuild and use as JNI
   example

 * ccxx: Consider enforcing that no object file may appear both as a
   program and a library object file and that no object file may be
   generated from more than one source file (with different suffixes)

 * Consider converting abuild_data.dtd to a schema for tighter
   validation (which attributes are allowed in which contexts).
   Search for DTD in the documentation and test suite.  Probably don't
   really want to do this.

 * In the manual, it would be nice if we could use higher resolution
   figures for the PDF than for the HTML.  There is plenty of material
   in the sagehill.net DocBook XSL guide about this.  The best
   solution would be to convert the figures to SVG.  It may work to
   use graphviz to generate the SVG.

 * Orphan target detection won't find orphan targets in
   subdirectories.  This is very hard to fix in general.  We could
   search directories represented in the source lists, but that
   wouldn't help if we removed the last file from a subdirectory.  For
   now, we'll just not handle this case.

 * Mingw support isn't that complete: see known limitations in the
   documentation and comments in private/list_platforms.  If it is
   improved, consider improving support for recognizing it so that the
   user doesn't have to set MINGW=1.  Search for mingw in the
   documentation and adjust as needed.

 * Consider adding a trouble shooting section to the documentation,
   web site, or wiki

    - example: library name inconsistency between Abuild.mk and
      Abuild.interface

 * Cass Dalton reports that he sometimes gets "resource busy" errors
   when running autoconf with --make-jobs.

 * Abuild.interface files necessarily duplicate information from
   Abuild-ant.properties or Abuild.mk such as jar names or library
   names.  This is probably okay as you can always avoid it by having
   a convention of setting "local" variables (i.e., variables named in
   such a way to not conflict with anything) that are referenced in
   the Abuild.mk or Abuild-ant.propertiesd. files.

 * It might be useful to have abuild recognize certain error
   conditions currently reported as global as instead being specific
   to a given build item, but this would be a high-risk change that
   has some of its own disadvantages.

   The idea would be to detect errors currently reported as global
   and, instead of having them prevent any builds from happening, have
   them just block builds of the specific items they pertain to.  This
   would make it possible, for example, to have a --build=desc work
   properly if there are dependency errors, cycles, or other similar
   types of errors on build items that are not related to the portion
   of the tree being built.

   Exmaple error conditions that could be handled in this way include
   depending on an unknown item, participating in a dependency cycle,
   referencing an unknown item in a trait, referencing an unknown flag
   for another item, having an invalid platform-specific dependency,
   etc.  An implementation strategy for doing this would be to have a
   buildError method that takes an item name and platform string, with
   an empty platform string indicating an error that would apply to
   all platform instantiations for the item.  Abuild would report the
   error but not increment the global error count, thus preventing
   exitIfErrors from exiting.  It would also store fact that an error
   was associated with the specific build item and/or build
   item/platform pair.  During the build of the item, if any
   non-platform-specific errors or if an error for the specific
   item/platform had been issued, the build for that item would be
   skipped.

   The above change, as described, would be straightforward to
   implement, but there are two siginificant issues:

    - This change would allow certain error conditions that really do
      have to get fixed from being purposely ignored or even
      accidentally overlooked for a longer period of time.  This goes
      against the idea of abuild trying to force early detection and
      correction of errors.

    - The code as currently implemented performs numerous validations.
      Once call to exitIfErrors has been made, subsequent code assumes
      all previous validations have succeeded.  For any current error
      condition that would be changed to a buildError, the rest of the
      code would have to be carefully inspected to ensure that prior
      assumptions have not become invalid.  This would be a shame
      since the early validation of certain error conditions helps to
      reduce the complexity of the abuild code.

   Consider the implications, especially of the second point.  Build
   graph construction code assumes that all platform information and
   dependency information stored in a build item is valid, and that
   information is accessed in a read-only fashion from the build
   item's config data.  This means that we either have to add checks
   throughout the code to make sure any dependency we retrieve is
   valid or else we need to remove a dependency from the list of
   dependencies.  The former would complicate the code and make it
   more fragile, not to mention the fact that the test suite doesn't
   cover any such cases now since they are prevented from happening.
   The latter would also have disadvantages.  For example, it would no
   longer be possible to use --dump-data to locate build items that
   depend on a particular unknown build item or otherwise to help
   clean up errors of this type.
