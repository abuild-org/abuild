
=== Changes Targeted for Version 1.1 ===

Core Changes
============

 * Implement some kind of compatibility framework that allows
   specification of minimum compatibility level.  It should be
   possible to make some code conditional (at runtime) on the minimum
   compatibility level and issue deprecation warnings.  See
   "Compatibility" below.

 * Replace "this" with "item-name".  Give a warning if "this" is
   encountered unless running in explicit 1.0 compatibility mode.

 * Require trees to be named.  Replace externals with subtrees.
   Simplify Backing Areas. See "Revamped Build Tree Structure" below
   for details.

 * It should be possible to declare a plugin as global.  Global
   plugins are loaded before non-global plugins.  Appropriate caveats
   should apply -- this is not appropriate for most kinds of plugins.
   The most likely use case would be for plugins that provide new
   platform information.  Another use case may be for plugins that
   check for compliance to internal policy.  Global plugins can also
   be used to support some form of project-wide configuration.

 * Consider a "renamed-to" or "replaced-by" keyword that would be used
   to indicate that a build item has been replaced by another build
   item.  Its semantics would include that BUILD_ITEM_RULES and
   abuild.hook-build-items would follow the name change.  This is
   stronger than using deps to make the old name depend on the new
   name.  Maybe this would be implemented by having a root Abuild.conf
   provide the information.  Then abuild could make one item an alias
   for another.  That way, things like ABUILD_DIR_ITEM-NAME would
   contain the right information.  This approach would also eliminate
   the need to create backward compatibility build items that just
   depend on their replacements.

 * Cosmetic change: when topologically sorting build items based on
   dependency, instead of starting with a straight alphabetical list
   of build items, first group build items together by tree using a
   topologically sorted alphabetical list of trees.  This should
   result in build items from the same tree being built together (in a
   single-threaded build).

 * It would be nice if plugins could build stuff.  For example, this
   would make it possible to implement a compiler plugin that uses
   autoconf to figure out the correct compiler invocation so that it
   would be possible to support a generic unix compiler or libtool
   from a plugin.  It would also be possible for a plugin to do some
   kind of startup check, which in turn could make it possible to
   implement some kind of forest/site-wide configuration.  One could
   conceive of a generic UNIX compiler plugin that would force you to
   manually run ./configure with certain arguments before being able
   to do a build.

   Making plugins buildable implies that abuild has to have build
   plugins before anyone might use them.  Since plugins are loaded in
   declaration order in each tree, this results in declaration order
   implying some kind of dependency-like relationship.  To determine
   build order, make a dependency graph among buildable plugins where
   a dependency is created from each plugin to its immediate
   predecessor in the build order.  This is done for global plugins
   and for each tree.  If there are any cycles (caused by buildable
   plugins being loaded in different orders across different trees),
   it is an error.  If not, the first phase of the build is to build
   plugins.  We should probably require that buildable plugins have
   platform type indep.  In this case, it's probably also okay for
   plugin.interface files to have after-build files as well.

   Since plugins are loaded in declaration order in each tree, this
   approach guarantees that buildable plugins are built before other
   plugins that may reference them.  One could argue that such logic
   should be applied to all plugins since it is possible for plugins
   to interact, but I would argue that this would create unnecessary
   constraints.  If one plugin really requires another plugin, one
   should first rethink whether the plugins are being used sensibly,
   and if they really are, then the plugin should just check for the
   existence of a variable/property defined by the other plugin.  The
   case of buildable plugins is a little different because a plugin
   may not even work before it is build.

 * Provide arguments for querying abuild's state, such as locating
   build items (perhaps with pattern matching), listing all trees with
   locations and dependencies, summarizing the state of all plugin
   information (which items are plugins in any tree, which tree
   provides the plugin, and which trees use the plugin), etc.


Abuild Contrib
==============

 * Make sure any compiler plugins included with abuild contrib have
   the 1.0.2 fixes integrated into them.

 * Include a generic UNIX compiler buildable plugin

 * Consider including a libtool buildable plugin


Platform Issues
===============

 * Pass information about the native os, cpu, and toolset to
   list_platforms.  See comment in Abuild::loadPlatformData before
   invocation of list_platforms.

 * It would be nice if -p native:skip didn't actually disable native
   platforms but instead just took them out of the default build list.
   That way, when doing -p native:skip, if a java or indep build item
   depends on a native build item, abuild can still build the native
   item "as needed" just as it would for other platform-specific
   dependencies.

 * There should be a way to tell abuild to skip java or indep build
   items.  Maybe support -p java:skip and -p indep:skip with the same
   semantic as -p native:skip (prevent from building by default, but
   still build to satisfy dependencies).

 * Remove temporary ABUILD_FORCE_32BIT hack or make it permanent.
   Search for FORCE32 in the code.  The only references are in
   private/bin/get_native_platform_data and make/toolchains/gcc.mk.
   For a description, see release notes in the documentation.

 * Implement platform conditionals, described below.


Make Changes
============

 * Need a better solution for files that are automatically generated
   by optional tools.  Abuild itself could use this for flex/bison
   files.  We could also use it for cases like xbinder where
   generating the files requires a special license.  We need a clean
   way to handle the following:

    - Regeneration of the files if they are out of date and the tools
      are available.

    - Use of cached files if they are not out of date.

    - Error if the files are out of date and the tools are not
      available.

   This implies, at least for these cases, some kind of checksum-based
   method (rather than using modification times) to tell whether files
   are out of date.  That way, checkouts from the version control
   system can work without modification time preservation.

 * We really need a way to be able to use autoconf to find out
   information about a specific compiler.  This would be especially
   useful for figuring out what flags to use for PIC when building
   shared libraries.  This should be possible with buildable plugins.


Building Abuild
===============

 * Consider creating a ./configure that finds boost libraries and
   deals properly with pthread.  Then consider packaging auto-srcs
   with abuild sources.  Check on debian to see if this works with the
   latest flex.  Consider making the re-entrant scanner switch, made
   possible by controlling the flex and bison files provided that
   there is an autoconf check for the right versions of flex and
   bison.  See ~/source/work-software/argon/third-party-support/boost
   for sample boost autoconf code.

   It might be possible to make this work properly when abuild is
   building itself by having a buildable plugin that checks to make
   sure configure has been run.  Bootstrapping makefile can fail if
   configure hasn't been run.


Platform Conditionals
=====================

People want conditional dependencies, but mainly for platform issues.
Consider one or both of the following ideas:

 * Platform restrictions per build item.  If a build item has a
   platform restriction, it will be excluded from the initial build
   set construction.  Then what happens if it get pulled in to satisfy
   a dependency?  This should be an error, but that causes problems in
   some cases.  See next idea for a possible solution.

 * Sometimes we use dependencies just to force something to build, as
   in the case of the "compile-all" item in searchlight or some
   "top-level" builds.  We really need the concept of a "build-also"
   keyword that specifies build items that should be built if this one
   is built.  It effectively just adds them to the build set.  The
   build-also keyword doesn't have any restrictions about cycles -- it
   is just used during initial build set construction.  As such, it
   can have platform-based conditionals.  Build items that use this
   feature are probably not allowed to have deps or to build anything
   themselves.

Using these two features together, it should be possible to achieve
the goal of supporting platform-based conditional dependencies in a
safe manner.


Revamped Build Tree Structure
=============================

Problem Statement
-----------------

A principal failing in abuild 1.0 stems from the use of paths to
specify the locations of external build trees -- "external-dirs" is
used to convey both dependency and location information.  A serious
and related problem is the interaction between backing areas and
externals.

Projects that desire certain parts of their trees to be potentially
compile-time independent from other parts have to break things into
multiple trees and use externals.  This sometimes results in build
areas consisting of many more trees than I envisioned in my original
design.

Consider first the case of externals without backing areas.  If there
are multiple build trees with complex "external" relationships between
them, then there is an implicit build "forest" consisting of multiple
build trees which must be organized relative to each other in a
particular way.  Knowledge of this relative organization of trees is
not represented in any one place but rather is distributed through all
the root Abuild.conf files.  For example, if A, B, C, and D are build
trees whose roots are under a common parent, you could have a
situation in which A declares ../B and ../C as externals and B
declares ../D as an external.  There is no single place where A, B, C,
and D are even all mentioned, yet abuild will require them to all be
in the same directory.  This situation becomes much worse when build
trees are at different levels -- the same tree may be referred to by
multiple different relative paths.  This creates great confusion, and
makes it very to move a tree around or even find who is referencing a
particular tree.  When backing areas are added to the mix, the problem
is further compounded.  If a build tree contains other external build
trees nested inside of it, use of a backing area with the parent tree,
in practice, requires use of a specific backing area on the child
tree, especially when externals need to be resolved from a backing
area.  Consider this arrangement of build trees:

   A       F
 / | \    /
B  C  D  G
|
E

with the following external relationships:

E -> C, D
D -> G

Suppose you have a backing area forest containing A and F, and a local
build area containing only A.  In this case, in the local A, it is
necessary to have backing areas for E, C, and D in, and they all have
to point to the right locations in A'.

It is clear that build trees deserve to be named entities, and that
just as is true with build items, the location of any given tree must
appear in only one place within a build area.  It is also clear that
use of backing areas when multiple trees are involved is too
cumbersome to be practical.

A better traversal system is required in order to make abuild aware of
all the possible build trees and their locations.  The following other
problems must be addressable by this:

 * It is impossible to pass information, such as extra compilers or
   flags, backwards across the external gap, so if you use a
   collection of common build items (like tps-build-items), there's no
   way to get those items to compile using your own compiler.  This
   applies also to test suite build items that are separate trees
   nested within the tree that provides the items they are testing.
   (tests for boost, xbinder, etc.).  This should be addressed by the
   global plugin concept.

 * If it is desired to build one portion of a build area without
   having other portions build, there needs to be a mechanism for
   abuild to treat certain trees as read-only for the duration of the
   build, but this information should probably not be encoded into the
   Abuild.conf files.  Consider:

         A
       / | \
      B  C  D

   If B and D both have C as an external and are independent from each
   other, you might want to build C first and then have both B and D
   built in parallel while treating C as read only.  Maybe we can
   specify one or more read/write or read-only roots on the
   command-line.  If none are specified, all externals are read/write.
   If read-only roots are specified, all externals are read/write
   except for those explicitly listed as read-only.  If any read/write
   roots are specified, all externals are read-only except those
   specified as read/write.  It is an error to specify both.

 * It would be nice to be able to build everything from a single build
   even if there is no single build item that can see all the build
   trees.  In the above example, there may be no single place from
   which B, C, and D are all known, but it would still be nice to be
   abuild to do a build that includes all the trees, even if B and D
   have duplicated names in them.

 * Name disambiguation would be nice across build trees.  Named trees
   allows fully qualified build items of the form tree::name.  If
   build item A includes X and Y with X -> Y and build tree B shows up
   with its own Y, a reference to Y from within A should resolve to
   A's Y.  If there is a desire to reach a Y in tree B, A can refer to
   B::Y.  Need to think about how this interacts with name-based
   access control, but it will probably interact fine.

 * It would be good if errors in a part of the collection of build
   trees that are not relevant to you don't impact your build.  For
   example, a build of B above should not fail or even necessarily
   tell you if there are errors in D.  Perhaps we can figure out which
   trees are touched in a build set and disregard errors in untouched
   trees unless --full-integrity is specified.

 * There is no way to find all build tree roots without doing an
   exhaustive search of all Abuild.conf files.

Solution
--------

Introduce this file system hierarchy restriction:

 * All build items in a local collection of build trees, called a
   forest, must be located physically under the root of the topmost
   build tree.

Imposing this restriction makes it possible to eliminate the
parent-dir key.  Enforcing this restriction involves verifying that
child-dirs may not contain .. in any path element, and that there are
no intervening Abuild.conf files between a parent and child
Abuild.conf.

This also implies elimination of absolute path externals, and makes it
impossible to have multiple roots without a common parent directory.
Hopefully this isn't too strict, but imposing it simplifies things a
lot and doesn't actually significantly change the state of practice.
Splitting builds across disks is already impractical, and with
junction points and loopback mounts, there are ways around it anyway.

Introduce the concept of a "build forest", which is a local collection
of build trees that are all found beneath some common ancestor
directory.

Abuild.backing files may appear only at forest roots.

Require build tree roots to include a "tree-name" key which provides
the name of the build tree.  Any Abuild.conf file may contain a
tree-name key.  This makes it the root of a subtree, which functions
very much as externals do in abuild 1.0.

Replace "external-dirs" with "trees-used" which takes a list of tree
names rather than tree paths.  Since we have no longer have the
concept of externals, we no longer have the concept of read-only
externals.  To support the pattern of building a tree without building
any of the other subtrees that it uses, we add another mechanism such
as declaration of one or more read-only or read/write root directories
outside of which all build trees are to be treated as read-only, or
perhaps explicit specification of read-only or read/write build trees,
though it's less clear in that case how to handle nested subtrees.

Traits, supported flags, and plugins behave with respect to subtrees
in 1.1 just as they behaved with respect to externals in 1.0.  This
means that it is still possible to repeat plugin declaration lists
for each subtree.  Global plugins apply to all subtrees and inherit
through backing areas.

New Abuild.backing format:

  backing-area: /path/to/backing/area
  deleted-trees: trees not to shadow
  deleted-items: items not to shadow (fully qualified as tree-name::item-name)

Remove deleted-items from Abuild.conf.

For compatibility, continue to accept Abuild.backing files that are
just paths with nothing else, but give a deprecation warning.


Example:

  OLD:

   Top-level Abuild.conf files in each leaf below; no way to know of
   all build trees or their relative positions without visiting each
   root.  No way to get list of build tree roots other than exhaustive
   search.

   /-- common
   |
   |-- proj1
   |   |
   |   |-- interface
   |   |   |
   |   |   |-- comp1    external-dirs: ../../../common
   |   |   |
   |   |   `-- comp2    external-dirs: ../../../common
   |   |
   |   `-- private
   |       |
   |       |-- comp1    external-dirs: ../../interface/comp1
   |       |
   |       `-- comp2    external-dirs: ../../interface/comp2 ../comp1
   |
   `-- proj2
       |
       |-- common       external-dirs: ../../common
       |
       |-- comp1        external-dirs: ../common
       |
       `-- comp2        external-dirs: ../comp1

  NEW:

   Top-level Abuild.conf file in top directory; subtrees are hooked in
   with child-dirs just like any other subdirectory.

   /-- common           tree-name: common
   |
   |-- proj1
   |   |
   |   |-- interface
   |   |   |
   |   |   |-- comp1    tree-name: proj1-comp1; trees-used: common
   |   |   |
   |   |   `-- comp2    tree-name: proj1-comp2; trees-used: common
   |   |
   |   `-- private
   |       |
   |       |-- comp1    tree-name: proj1-comp1-impl; trees-used: proj1-comp1
   |       |
   |       `-- comp2    tree-name: proj1-comp2-impl;
   |                    trees-used: proj1-comp2 proj1-comp1
   `-- proj2
       |
       |-- common       tree-name: proj2-common; trees-used: common
       |
       |-- comp1        tree-name: proj2-comp1; trees-used: proj2-common
       |
       `-- comp2        tree-name: proj2-comp2; trees-used: proj2-comp1



Traversal algorithm:

 * Find the root of the current build forest.

   cur_build_item = this directory
   forest_top = nil

   do until no more Abuild.conf files
     if cur_build_item's Abuild.conf contains tree-name key
        forest_top = cur_build_item
     parent_build_item = next higher Abuild.conf
     if parent_build_item exists and has child pointing to cur_build_item
        cur_build_item = parent_build_item
     else
        if forest_top == cur_build_item
           okay; found
        else
           forest_top = nil
           error: unable to find top of build forest

   Note that if a parent Abuild.conf is found but it doesn't have a
   child-dirs key that points to the child build item and if the child
   build item is a build tree root, the search stops, and there is no
   error or warning reported.  This is a normal case of a separate,
   independent tree nested inside another tree.  Examples of when you
   might have this would include test suites that create build trees
   (such as abuild's own test suite) or instances in which abuild may
   be used to build third-party software distributions nested within
   something that contains Abuild.conf files.  If this tree was
   supposed to be connected into higher trees and was not, there will
   probably be unresolved trees-used or deps values.

 * If the root of the forest does not contain an Abuild.backing, then
   this is an unbacked forest.  If it does contain an Abuild.backing
   file, ensure that it points to a tree root (not necessarily a
   forest root).  In that case, search for the backing tree's forest
   root.  Continue until an unbacked forest is found.  Traverse the
   unbacked forest (as described below).

   Note that we impose no restrictions on whether the backing area
   points to the same tree or even to a backing forest that contains
   the same tree.  This makes it possible to add an entirely new
   subtree in a work area that backs to some other area, and then to
   have the backing area later get included inside of a higher-level
   tree without impacting the work area.

 * Traverse the build forest.

     traverse:

     if current item has a tree-name key
        set cur_tree to name of tree
     store current build item in cur_tree
     for each dir in child-dirs
        ensure that dir has no path elements equal to ".."
        if dir has more than one path element
           ensure that no intermediate directories have Abuild.conf
        traverse recursively from dir

 * Verify that each tree in the forest is uniquely named

 * Copy build items from the backing area forest that are absent from
   the local forest into the local list.  Exclude build items that are
   listed as deleted or that belong to trees that are listed as
   deleted in the Abuild.backing file.

 * Make sure that the graph implied by the trees-used key is an
   error-free directed acyclic graph.  Do not do checks to ensure that
   is bipartite with respect to backing area traversal; save this
   check for the build item level.  This makes it possible to sparsely
   shadow a build tree for the purpose of adding items to it.

 * Check dependencies and build item references for the whole forest
   rather than doing it separately for each build item and copying
   build items around.  (We only copy build items from backing areas,
   not subtrees.)  Just disallow resolution of any build item name in
   a tree not declared as used.  This makes it possible to issue error
   messages akin to "A is not allowed to depend on B since A-tree has
   not declared B-tree as in its tree-used key."

(Test case: staggered build items or subtrees: with A/B/C/D/E, have
A -> B, C; B -> C/D; C -> D/E.  Should generate an error.)

Figure out how to make global plugins work with this and what
restrictions, if any, should be imposed on them (like maybe they're
not allowed to have interfaces or rules but are just allowed to be
platform type or compiler plugins).  Shouldn't be that hard.

Need to flesh out an example that includes both searchlight and
lh3-style trees.  Think about external build item library concept,
whether it's sensible, and how it interacts with global plugins.  Also
consider the case of nested build trees with externals that point up
such as in the test suites of some of the plugins.


Compatibility
=============

When abuild starts up, a version compatibility flag may be provided.
We should probably support this from the command line or from the
environment.  If no flag is specified, abuild should attempt to
automatically determine whether to run in 1.0 compatibility mode.
Abuild must store the reason why it chose a particular version so it
can report that in error messages as needed.  By default, abuild will
give deprecation warnings for 1.0 constructs.  These can optionally be
made into errors, but they cannot be suppressed.

Think about whether it is possible to support some kind of hybrid
mode where some build trees are 1.0 and some are 1.1.

 * If build item has a parent-dir or external-dirs key, use 1.0

 * Else if the local build item has an item-name key or any other key
   that was introduced in version 1.1, use 1.1

 * Else if build item has any keys that are allowed in build tree
   roots or has an Abuild.backing file, use 1.0 (since if it had a
   tree-name key, we would have already chosen 1.1)

 * Else if build item has a child-dirs key and child build item has a
   parent-dir key, use 1.0

 * Else could be single-build-item 1.0 tree or normal case 1.1 build
   item.  If the next higher Abuild.conf refers to this as a child,
   use 1.1.  Otherwise, give a warning and proceed to treat as a
   single build-item 1.0 tree.

----------------------------------------------------------------------

=== Things with no Specific Release Target ===

Windows Issues
==============

 * There are some Windows path issues.  You can't use absolute paths
   in Windows as long as cygwin is in use because cygwin gnu make will
   not interpret absolute paths in the same way that Windows will for
   purposes of dependencies in .dep files, library dependencies, etc.
   Relative paths should work, but they don't always work because
   Windows seems to have limits on the number of times .. may appear
   in a path (among possibly other things), and besides, there is no
   way to construct a relative path to a file under another drive
   letter.  Ideally, we should be using something like msys and/or
   gnuwin32 rather than cygwin, along with supporting ActivePerl, but
   this has major implications since qtest doesn't currently work
   without cygwin, not to mention the fact that the test suite makes
   free use of unix constructs.

 * gen_deps: rewrite in C++ so that it doesn't force a runtime
   dependency on perl.  It should be a fallback for cases when
   compilers can't generate dependency information.  With gcc, use -MD
   -MF -MP to generate proper .dep files.  xlc: "-M -MF a.dep" works,
   but there is no equivalent to -MP, so we'll need to postprocess.
   VC: there seems to be a /showIncludes option that we may be able to
   exploit.  Not sure what versions of VC++ have this.  This will be
   worth doing if we can remove a runtime dependency on Cygwin for
   Windows/C++.  For non-Windows systems, requiring perl is not a big
   deal.


Compiler/Platform Configuration
===============================

There is a general problem with compiler options, 32-bit and 64-bit
compilers, project-specific configuration, supporting compilers that
aren't known in advance, etc.  This is kind of what toolset was
designed to handle.  The following items are possibly contradictory or
interdependent and need to be sorted out better.  These items all
imply certain things that may need to be done very early in abuild's
life even before private/bin/get_native_platform_data is called.

 * Need a more flexible way of handling compiler options.  It should
   be possible to create plugins that add compiler options to
   internally supported compilers, and options should be able to be
   meaningfully selected in groups.  For example, it should be
   possible to add {m32, m64} that can't be specified together and
   {debug, release} that can't be specified together while allowing
   debug+m32 or release+m64 or other permutations.  This implies the
   need for a canonical form.

 * We need some way for people to change the toolset portion of the
   platform string in a global way for a particular collection of
   build trees.

 * There needs to be better cross-compiler support for things like
   building 32-bit code on a 64-bit system.  Adding -m32 doesn't
   really do it because why should have you
   linux.x86_64.rhel51.gcc.m32 be the same as linux.ix86.rhel51.gcc?


Java Problems
=============

We probably need a different approach to Java.  Ant was not designed
to be used as a framework, and it doesn't work very well when used in
this way.

 * In order to get wars in ear files, we need to add them to
   abuild.classpath.  Although this is harmless, it's sort of an abuse
   of abuild.classpath.

 * Ant launcher: consider having a Java-based ant launcher that abuild
   communicates with via some kind of IPC to make launching ant more
   efficient.  See ~/argon/tmp/ant-launcher and email X-ArgonCount:
   23536 in abuild, 4/3/2008, subject "preliminary ant launcher
   experiment".  For communication between abuild and the ant
   launcher, see
   ~/source/examples/portability/socket-java-c++-workers/README

 * ant with build failure appears not to exit abnormally in Windows.
   This is a bug in ant.bat and could be worked around by using our
   own ant launcher.

 * We don't detect when inaccessible build items are referenced in
   abuild.hook-build-items

 * Abuild has no real way to support a difference between compile-time
   classpaths and run-time classpaths.

 * NOTE: It was necessary to create /usr/{share,lib}/java-1.6.0 in
   order for build-classpath from jpackage to do the right thing when
   launching ant 1.7.0 in fedora core 5.  Not sure how general of a
   problem this is.

 * Reconsider using depends task for compile in abuild.xml.

 * Signed jar support will eventually be required.

 * Our default java compile rule doesn't notice if a .java file was
   removed.  Maybe we want to force full recompilation if the list of
   files changed, or maybe we want to delete class files that appear
   to have come from non-existent java files.  I'm not sure what
   happens with nested/inner classes that disappeared....does javac
   automatically remove the corresponding class files?  This would be
   an easy experiment to try.

 * Consider supporting creation of multiple jar files with different
   contents analogous to different libraries being created from a
   single C++ build item.

 * Ant seems to not complain when populating an ear file from a
   classpath that contains non-existent items.  In general, there may
   be an issue with not getting any notification of non-existent
   classpath items.  Note that, sometimes, you want to try to create
   an ear even of some of its contents aren't there, so this may not
   really be a problem worth fixing.  If we can fix it, we should be
   able to control on a per-build-item basis whether it is an error
   condition or just a warning, probably having "error" be the
   default.

 * We use the privately set "debug" and "deprecation" properties in
   abuild.xml to set debug and deprecation.  These should really be set
   using documented abuild properties, and we should figure out what
   other similar properties we might want to set in this way.

 * There is presently no mechanism for adding a new build target that
   is visible to all build items (as one can do with plugin.mk in
   make-based builds).  Figure out again why we can't add a custom
   target in ant code that is loaded as a plugin or hook build item.
   Was there a reason we didn't use import?

   I think the reason is this: with make, if two different build items
   define the same target, if at least one uses a : target instead of
   a :: target, it's an error.  Otherwise, all the variants of the
   target get run.  With ant, there is no such facility.  All but one
   of the definitions of the target will get mangled to
   project.target, and there's no way to run all of the
   implementations.  The only way to get this behavior right now is to
   use hooks.


Known Bugs
==========

 * Piping ANSI color stuff through ant on Windows doesn't work.  When
   running qtest from ant on Windows, qtest correctly generates the
   ansi color codes, but they don't get displayed right through ant,
   at least in cygwin.


Issues, Enhancement Ideas
=========================

See also "Known Limitations" in the documentation.

 * Test qtest coverage from abuild test suite.  Relatively low
   priority since abuild's test suite itself uses coverage, so
   abuild's qtest coverage support is exercised every time the abuild
   test suite is run.  (It's just that you might not notice if it
   weren't there.)

 * Think about implementing a dependency analyzer that would look at
   first-level includes to figure out what the correct list of direct
   dependencies should be.

 * Consider having --silent invoke make with --no-print-directory.  If
   we do this, we should follow build item failure with a message that
   contains the name, path, and platform of whatever failed.

 * Consider having an abuild template generator that can run if no
   Abuild.conf or other files are present.  This would spit out
   commented template files.  Alternatively, could be a command-line
   wizard or something.

 * To check for all Abuild.mk files that define local targets:
   pcregrep '^\s*\S+\s*:(\Z|[^=])' **/Abuild.mk

 * It might be useful to have the ability to find all references to a
   particular interface variable and/or to find the origin and
   variable history for a specific variable.  This comes back to the
   interface tracing mode or dump mode.  Examples: I see some
   interface variable in a build item's Abuild.interface file and want
   to know who uses it, or I see some variable in someone's
   Abuild-ant.properties or Abuild.mk and want to know who defines it.

 * Consider using re-entrant scanners instead of C++ scanners.  This
   requires flex >= 2.5.33.  Have abuild's own build process detect
   whether or not a new enough version of flex is available.  If so,
   it should generate the parsers and attempt to update a cached copy
   of the automatically generated files if they have changed.
   Otherwise, it should use the cached files by adding them to SRCS in
   place of the automatically generated ones.  We also need to disable
   warnings for the flex-generated code.  Use %option nounistd.  (This
   suggestion may be simplified if better support for files generated
   by optional tools is added.)

 * It would be nice if there were a mechanism for providing
   documentation on traits so that --list-traits could tell the user
   how each trait was intended to be used.

 * Consider capturing the output of the backend so that we can
   de-interleave output when running parallel builds, separate error
   from informational output, etc.  It is possible to create pipe-like
   handles with CreatePipe in Windows and to use them to initialize
   hStdInput, hStdOutput, and hStdError fields of the startupinfo
   parameter to CreateProcess.  There is an example at
   http://lists.trolltech.com/qt-interest/1999-09/thread00282-0.html
   There is also some kind of Win32 Job API used by the perl
   Win32::Job classes (CreateJobObject).  This may provide a better
   solution than our current CTRL-C handling.  See if boost provides
   anything that could do this.

 * Clean up ~/source/examples/java/native/abuild and use as JNI
   example

 * ccxx: Consider enforcing that no object file may appear both as a
   program and a library object file and that no object file may be
   generated from more than one source file (with different suffixes)

 * Consider converting abuild_data.dtd to a schema for tighter
   validation (which attributes are allowed in which contexts).
   Search for DTD in the documentation and test suite.

 * In the manual, it would be nice if we could use higher resolution
   figures for the PDF than for the HTML.  There is plenty of material
   in the sagehill.net DocBook XSL guide about this.

 * Orphan target detection won't find orphan targets in
   subdirectories.  This is very hard to fix in general.  We could
   search directories represented in the source lists, but that
   wouldn't help if we removed the last file from a subdirectory.  For
   now, we'll just not handle this case.

 * Scott Lemke points out that abuild has a lot of knowledge about
   things that are not relevant to any particular build.  One thing to
   consider would be having abuild analyze error conditions to
   determine which ones are not relevant to the local build.  This
   might enable abuild, in some cases, to build a local group of items
   even when there are integrity errors in other parts of the build
   tree.  This may or may not be a desirable feature.  If we support
   this, it should be done only when -k is specified.

 * Mingw support isn't that complete: see known limitations in the
   documentation and comments in private/list_platforms.  If it is
   improved, consider improving support for recognizing it so that the
   user doesn't have to set MINGW=1.  Search for mingw in the
   documentation and adjust as needed.

 * Consider adding a trouble shooting section to the documentation,
   web site, or wiki

    - example: library name inconsistency between Abuild.mk and
      Abuild.interface

 * Cass Dalton reports that he sometimes gets "resource busy" errors
   when running autoconf with --make-jobs.

 * Abuild.interface files necessarily duplicate information from
   Abuild-ant.properties or Abuild.mk such as jar names or library
   names.  This is probably okay as you can always avoid it by setting
   "local" variables (i.e., variables named in such a way to not
   conflict with anything) that are referenced in the Abuild.mk or
   Abuild-ant.propertiesd. files.
