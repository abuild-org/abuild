
=== Changes Targeted for Version 1.1 ===

Notes for Next Release
======================


 _________________________________
/vv Changes made on Java Branch vv\
-----------------------------------



___________________________________
\^^ Changes made on Java Branch ^^/
 ---------------------------------



Remember to keep deprecated features list up-to-date.  Add the
following:

 * ...

These changes have already been made and need to make it into the
release notes.

 * NON-COMPATIBLE CHANGE: -winpath is no longer a valid option to
   external-dirs.

 * NON-COMPATIBLE CHANGE: absolute path externals are no longer
   supported.

 * Compatibility level can be set with the ABUILD_COMPAT_LEVEL
   environment variable in addition to the command line argument.  The
   command line argument takes precedence.

 * Document somewhere that, when converting, abuild will be happier if
   you don't change this to name on trees whose roots don't have
   tree-name.


Groovy Framework
================

 * Find sun conventions on directory structure for _base.groovy

 * Update rules/java/java_help.txt

 * Consider whether we should embed it junit.  If so, which version?
   Groovy embeds 3.8.2.  Current is 4.5.  Right now, you must have
   some version of junit in your classpath for the junit tasks in the
   java rules (or ant code) to work.  This seems okay to me since it
   avoids the need to worry about abuild's integrated junit taking
   precedence over a user-provided version.

 * There is no way to specify separate includes and excludes for the
   various filesets inside of jar, war, or ear.  I can think of three
   possible solutions:

    - Don't bother supporting this.  People can always put their own
      closures in abuild.packageJar if they want this.  Besides, we
      have enough different directories that we use that there are
      plenty of other approaches.

    - Allow the map entries passed to java.packageJar (etc.) to be
      either directories or maps.  If an entry is a map, it is treated
      as arguments to fileset.

    - Have a parameter that maps directories to includes and excludes.
      This is a little more obscure than the previous option, but it
      enables customization of the contents of standard directories
      without having to resort to using java.packageJar and copying
      names of standard directories around.

   Which way we goes probably depends on how much this functionality
   is needed.  I personally feel that doing selective includes and
   excludes for creating jars makes things unnecessarily obtuse, but
   I've seen lots of examples of people doing things like creating
   test jars that include all files and non-test jars that exclude
   Test*.class.

 * No specific mechanism (like plugin.groovy) is provided for
   pre-initialization of parameters to be used by build item-supplied
   rules.  This facility does not exist on the make side either, and
   it has never been missed.  If code generators really need this
   facility, they can set interface variables.  Note that parameters {
   interface.variable << 'new-val' } does actually work as of 1.1.a3.

 * Consider providing a way to "decorate" targets by adding closures
   to be run before and after.  A pre-target closure would be run
   after all dependencies were satisfied and before any of the
   target's closures.  A post-target closure would be run after.
   Alternatively, perhaps we should provide a mechanism for prepending
   rather than appending a target closure, which might ave the same
   effect.  This may no longer be necessary with the way
   abuild.runActions works.


Core Changes
============

 * Implement an optional 1.0-compatibility mode.  See "Compatibility"
   below.

 * Replace "this" with "name".  Make use of "this" deprecated.

 * When abuild is run with no arguments, its default behavior will be
   to act as if --with-deps had been specified.  A new flag
   "--no-deps" can be used for the case in which one should build just
   the item with no dependencies.

 * Require trees to be named.  Replace externals with subtrees.
   Eliminate absolute path and read-only externals, but provide an
   alternative to read-only externals for the desired functionality.
   Simplify Backing Areas. See "Revamped Build Tree Structure" below
   for details.

 * Change build set "all" to mean all known build items in all trees
   in the forest.

 * Add build set "reachable-trees" to mean all build trees in the
   tree-deps chain, including the current build tree.  This build set
   would build what "all" builds in 1.0.

 * Add build set "tree-deps" to mean all build trees that are
   tree-deps (recursively) but not the current build tree.

 * Add flag --with-rdeps to add to the build set all items anywhere in
   the forest that have items in the initial build set in their
   expanded dependency chains.  (Note that is recursive by nature: if
   A depends on X and B depends on A, then B also depends on X.)

 * Add -ro-path and -rw-path options to tell abuild to treat some or
   all build items as read only based on path.  This should provide a
   more robust approach than using read-only externals for preventing
   cross-tree builds when they are not desired.  Consider these trees:

         A
       / | \
      B  C  D

   If B and D both have C as a tree dependency and are independent
   from each other, you might want to build C first and then have both
   B and D built in parallel while treating C as read only.  This
   would provide a way to do that.

   Both -ro-path and -rw-path may appear multiple times, but they may
   not both appear.  If neither -ro-path nor -rw-path is specified,
   everything is read/write.  If -ro-path is specified, everything not
   listed in -ro-path is read/write.  If -rw-path is specified,
   everything not specified with -rw-path is read-only.

   Paths may be absolute or relative.  Relative paths are resolved
   relative to the starting directory of abuild (after any -C is
   evaluated).

 * Implement two forms of conditional dependencies:

    - deps: item -optional
    - tree-deps: tree-name -optional

   In the first case, abuild will not complain if a given dependency
   is not found.  Some mechanism will be provided that will enable a
   build item to test in its Abuild.interface file (and therefore in
   its Abuild.mk or Abuild-ant.properties file) whether an optional
   dependency is satisfied.  In the second case, abuild will not
   complain if a given tree is not found.

   A new boolean interface variable (analogous to abDIR_build-item)
   will be defined for each build item that exists or that is declared
   as an optional dependency.  This variable will be true iff the
   build item exists.

 * Create a "replaces" keyword that would be used to indicate that a
   build item is a replacement for one or more other build items.  Any
   values for the replaces key would not be allowed to exist on their
   own.  Any references to them in Abuild.conf files would be treated
   as references to the new build items.  This is stronger than using
   deps to make the old name depend on the new name and also
   eliminates the need to create build items whose only purpose is to
   depend on their replacements.

 * Move "deleted-items" key from root Abuild.conf to Abuild.backing.
   Also add a "deleted-trees" key.  New Abuild.backing format:

     backing-areas: /path/to/backing/area
     deleted-trees: trees not to shadow
     deleted-items: items not to shadow

 * It would be good if errors in a part of the collection of build
   trees that are not relevant to you don't impact your build.  For
   example, if a forest contains A, B, and C and your build contains
   no items from C, then integrity errors in C should be ignored
   unless --full-integrity is specified.  (Do we already to this?)

 * Make cross-platform dependencies obey platform selectors.  The
   rationale for not doing this was that the command-line and
   environment should not affect the shape of the build graph, but
   this is a myth anyway.  People can always run with DFLAGS=-g or
   NO_XLC=1.  If a specific compiler or option is required, it can be
   specified explicitly with the platform-specifier in the
   dependency.  This implies additional requirements:

    - Make sure "-platform native:option=" works to specify no option

    - Make sure it is possible to express "I want the version of X
      built with compiler A on platform P but the default compiler
      everywhere else."  This can probably be done with a combination
      of platform-specific dependencies and platform conditionals.

 * Drop internal "clean" targets and update documentation.


Documentation
=============

 * Incorporate manual/groovy-framework.txt

 * Read through all 1.1 release notes and update the body of the
   documentation accordingly.  Save this until all the new features
   are implemented, if possible.

 * Note: references to ant examples are still in the documentation.
   There are comments like <!-- ?example ....? --> marking where the
   file references used to be.  Files can be found in the abuild-ant
   test suite.  Paths that used to start with java now start with
   basic.

 * Describe groovy framework (obviously).  Specific things to remember:

    - For groovy backends, defining a new test procedure requires only
      defining a closure for the 'test-only' target.  Abuild
      automatically calls this from test or check.

    - document fields and interface of BuildState ("abuild").  Also
      describe parameter handling.  setParameter vs. getVariable, which
      looks at defines, parameters, interface, and default in that order

    - QTest.export prop for groovy backend; also automatic export of
      TESTS

    - abuild.local-rules, abuild.rules

 * Describe somewhere why we don't provide information about platforms
   in the interface files for java and indep.  Basically, it would be
   a bug to have an interface variable have a different value in
   different contexts when it might influence a build that could be
   used on multiple platforms.  For example, an indep build item could
   write out some value based on a platform variable and then that
   information could be wrong when the results of the build were used
   on a different platform.  If you really need to know what platform
   you are on for something indep or java, you can always get the
   information using a cross-platform dependency, which at least makes
   it visible.  But remember that text files containing
   platform-dependent values (like pathnames, etc.) are in fact
   platform-dependent.

 * Work this material about the rationale for revamping externals and
   backing areas into an appendix.

   A principal failing in abuild 1.0 stems from the use of paths to
   specify the locations of external build trees -- "external-dirs" is
   used to convey both dependency and location information.  This is
   against a fundamental design principle of abuild and must be
   corrected.  Another serious problem is the interaction between
   backing areas and externals: setting up backing areas for trees
   with lots of externals is complex to the point of being
   impractical.

   Projects that desire certain parts of their trees to be potentially
   compile-time independent from other parts have to break things into
   multiple trees and use externals.  This sometimes results in build
   areas consisting of many more trees than I envisioned in my
   original design.  (I had originally envisioned externals as being a
   rarely-used feature, primarily intended for supporting builds at
   multiple classification levels or supporting central libraries of
   reusable build items.)

   Consider first the case of externals without backing areas.  If
   there are multiple build trees with complex "external"
   relationships between them, then there is an implicit build
   "forest" consisting of multiple build trees which must be organized
   relative to each other in a particular way.  Knowledge of this
   relative organization of trees is not represented in any one place
   but rather is distributed through all the root Abuild.conf files,
   usually with considerable but non-obvious duplication of knowledge
   (exactly the situation abuild's name-based organization was
   designed to avoid).  For example, if A, B, C, and D are build trees
   whose roots are under a common parent, you could have a situation
   in which A declares ../B and ../C as externals and B declares ../D
   as an external.  There is no single place where A, B, C, and D are
   even all mentioned, yet abuild will require them to all be in the
   same directory.  This situation becomes much worse when build trees
   are at different levels -- the same tree may be referred to by
   multiple different relative paths.  This creates great confusion,
   and makes it very to move a tree around or even find who is
   referencing a particular tree.

   When backing areas are added to the mix, the problem is further
   compounded.  If a build tree contains other external build trees
   nested inside of it, use of a backing area with the parent tree, in
   practice, requires use of a specific backing area on the child
   tree, especially when externals need to be resolved from a backing
   area.  Consider this arrangement of build trees:

      A       F
    / | \    /
   B  C  D  G
   |
   E

   with the following external relationships:

   E -> C, D
   D -> G

   Suppose you have a backing area forest containing A and F, and a
   local build area containing only A.  In this case, in the local A,
   it is necessary to have backing areas for E, C, and D in, and they
   all have to point to the right locations under A's backing area.
   In addition to that, people remain generally in the dark about how
   externals are resolved through backing areas.  It's
   (understandably) hard for people to understand the idea that a
   relative path expressed in an Abuild.conf file may be resolve
   relative to another directory that is listed in an Abuild.backing
   file.

   In defense of the original design, when abuild was a simple perl
   script that used "make" to do most of its work, this made the
   initial implementation very easy -- abuild just replaced the tree
   top path with the backing area path and re-invoked itself.
   However, given the current state of abuild's evolution and an
   understanding of how these features are actually used, it is
   obvious that the current implementation is no longer tenable.

   It is clear that build trees deserve to be named entities, and that
   just as is true with build items, the location of any given tree
   must appear in only one place within a build area.  It is also
   clear that use of backing areas when multiple trees are involved is
   too cumbersome to be practical.


Usability Improvements
======================

 * Provide arguments for querying abuild's state, such as locating
   build items (perhaps with pattern matching), listing all trees with
   locations and dependencies, summarizing the state of all plugin
   information (which items are plugins in any tree, which tree
   provides the plugin, and which trees use the plugin), etc.  The
   --dump-data option will always be available for providing full
   information, but providing a more human-readable format for
   commonly needed information will help.

 * Abuild 1.0's build ordering is created by doing a stable
   topological sort on an alphabetical list of build items.  Instead
   of starting with a straight alphabetical list, have the starting
   list group build items by build tree.  To create the starting list,
   first topologically sort the alphabetical list of trees, and then
   alphabetically sort build items within each tree.  When this list
   is topologically sorted, it should result in build items from the
   same tree being built together (in a single-threaded build), and
   will generally result in items with higher visibility being built
   earlier in the process.  Also, make sure the : separator between
   build item and platform doesn't mess up sorting.  In 1.0, "item"
   sorts after "item2" because the strings being compared are
   item:platform and item2:platform, and : sorts after numbers.

 * Consider adding a new special-case target "help" that would provide
   help in a manner that does not require invoking a back end.  This
   should remove the serious problems with rules-help and
   interface-help, and should get around the problem of trying to echo
   help information from a build file.  This would work by having
   abuild automatically display certain internal help files and build
   item-provided help files.  Most likely, abuild would just display
   all the help files provided by other build items that impact your
   build (dependents, plugins, rule/hook build items, etc.) as well as
   internal help files.  Help files, including internal ones, should
   provide a list of variables that can be set or read, what they
   mean, and how to use them.

 * Make sure abuild --help references the build/clean set list from
   the --build and --clean argument description, and make sure there
   is a reference to the platform selector information from the
   --platform-selector argument description.  Also divide the output
   clearly into OPTIONS and TARGETS.

 * Incorporate as much of abuild-lint as possible or otherwise include
   abuild-lint in the distribution.

 * Provide a way to get --dump-data's into a relational database.
   Ideally, we shouldn't have to link with sqlite.  Maybe have an
   option that causes --dump-data to generate a script file that can
   be used with sqlite3 rather than generating XML data.
   Alternatively, we can create xsl/perl code that loads directly into
   a sqlite database or that creates the input file.  It's probably
   okay if we create the SQL such that an erroneous dumpdata won't
   load.  For example, the SQL can enforce uniqueness and referential
   integrity constraints even though they may not be satisfied when
   there are errors.


Plugins
=======

 * Support buildable plugins with platform type "indep".  See
   "Buildable Plugins" below.


Abuild Contrib
==============

 * Upgrade all contributed build items to use abuild 1.1 files.

 * Make sure any compiler plugins included with abuild contrib have
   the 1.0.2 fixes integrated into them.

 * Include a generic UNIX compiler buildable plugin

 * Consider including a libtool buildable plugin


Platform Issues
===============

 * Allow platforms, but not platform types, to flow "backward" across
   tree dependencies.  Specifically, consider the following:

   A: platform type T1, available platforms p1, p2
   B: platform type T1, available platforms p1
   A -> B

   Allow B to build on platform p2 even if that platform is defined in
   a tree that B doesn't declare as a dependency.  Even allow this if
   the platform that defines p2 is defined in a tree that depends on
   B's tree.

 * Pass information about the native os, cpu, and toolset to
   list_platforms.  See comment in Abuild::loadPlatformData before
   invocation of list_platforms.

 * If possible, remove the temporary ABUILD_FORCE_32BIT hack or make
   it permanent.  Search for FORCE32 in the code.  The only references
   are in private/bin/get_native_platform_data and
   make/toolchains/gcc.mk.  For a description, see release notes in
   the documentation.

 * Implement platform conditionals, described below.


Changes to "make" Code
======================

 * Need a better solution for files that are automatically generated
   by optional tools.  Abuild itself could use this for flex/bison
   files.  We could also use it for cases like xbinder where
   generating the files requires a special license.  We need a clean
   way to handle the following:

    - Regeneration of the files if they are out of date and the tools
      are available.

    - Use of cached files if they are not out of date.

    - Error if the files are out of date and the tools are not
      available.

   This implies, at least for these cases, some kind of checksum-based
   method (rather than using modification times) to tell whether files
   are out of date.  That way, checkouts from the version control
   system can work even when the CM system does not preserve
   modification times.

 * According to Microsoft, we should always be using /Zi.  We need to
   revisit all the arguments passed to msvc to see what they really
   mean and to figure out which to use in release and debug modes.

 * To build for .NET, we need to pass /clr rather than /EHsc to msvc.
   /EHsc is hard-coded into $(CC) right now.  We need to fix msvc.mk
   to make it easier to override these flags.  When going back through
   all flags to see what they do, create variables that can be
   overridden based on function.


Platform Conditionals
=====================

(This item is low priority for 1.1.)

The goal is to support some kind of platform-based conditional
dependency while preserving the fundamental design goal of having a
static build graph.  We will support this only for build items of type
native.  Here's how it would work:

 * Native build items can specify some kind of platform-based
   inclusion/exclusion rules in Abuild.conf.  Maybe we'll add keywords
   build-if-platform-matches and build-unless-platform-matches, each
   of which takes arguments of the form a.b.c.d.  Each field can be a
   fixed string or * and is matched against the corresponding field of
   the platform identifier.  If both keywords appear, platform strings
   have to satisfy both.  For example,

   build-if-platform-matches: linux.*.*.gcc *.*.*.xlc
   build-unless-platform-matches: windows.*.*.*

   would mean to build on linux with gcc and everywhere except windows
   on xlc.

 * Abuild will first construct and validate the build graph
   disregarding platform restrictions.  This ensures that the build
   graph can't be invalid for some combination of available platforms
   and not for others.

 * Once the build graph is validated, abuild will traverse the build
   graph again and prune the graph at each node whose platform doesn't
   satisfy the platform restrictions.

There are several possible implications to think through.  What
happens with build items that get built "as needed" to satisfy
platform constraints but then are no longer needed after pruning?  It
may be that we have to create two build graphs, one that disregards
platform restrictions and one that doesn't.  The second build graph
should always be a proper subset of the first one, so there should be
no possibility of errors existing in the second one.

But actually, it's worse than that.  What about items that get added
to the build set just to satisfy dependencies that are no longer
required?  Do we want those?  It's like we have to mark build items as
explicit or implicit and then prune any unreferenced implicit items
after paying attention to platform restrictions.

Consider native build items:

a: b c
b: d

b is 'windows only'

When doing abuild -d from a on a non-windows platform, we only want to
build a and c, but when doing abuild -b all on a non-windows platform,
we want a, c, and d.  In the first case, d is an implicit member of
the build set, and in the second case, d is an explicit member.  For
the build graph, we can mark things as explicit if they are explicit
items on selected platforms.  Explicit items on as-needed platforms
are implicit.  To detect unreferenced implicit members, we could
traverse the pruned build graph starting from each explicit node and
mark things as seen when we encounter them.  Then, anything that's not
seen can be removed.  We'll need to test cases with platform-specific
dependencies to make sure the logic is sound.  Also consider whether
the special failure build item used to implement recovery from certain
types of cycle errors should be explicit.


Buildable Plugins
=================

There are a number of potential uses for plugins that can't presently
be realized because plugins have to be completely static.  For
example, it would be useful to be able to create a generic UNIX
compiler plugin that must be configured using autoconf by the user
before starting to build or that would use autoconf or libtool to
figure out certain flags, such as the proper flags to create shared
libraries.  Buildable plugins could also be used to force certain
steps to be performed early in a build, such as checking for proper
environment variable settings or making architectural checks on
dependency rules that go beyond what can be enforced through abuild's
internal mechanisms.

Making plugins buildable implies that abuild has to build plugins
before anyone might use them.  Since plugins are loaded in declaration
order in each tree, this results in declaration order implying some
kind of dependency-like relationship.  To determine build order, make
a dependency graph among buildable plugins where a dependency is
created from each plugin to its immediate predecessor in the build
order.  This is done for each tree.  If there are any cycles (caused
by buildable plugins being loaded in different orders across different
trees), it is an error.  If not, the first phase of the build is to
build plugins.

Since plugins are loaded in declaration order in each tree, this
approach guarantees that buildable plugins are built before other
plugins that may reference them.  One could argue that such logic
should be applied to all plugins since it is possible for plugins
to interact, but I would argue that this would create unnecessary
constraints.  If one plugin really requires another plugin, one
should first rethink whether the plugins are being used sensibly,
and if they really are, then the plugin should just check for the
existence of a variable/property defined by the other plugin.  The
case of buildable plugins is a little different because a plugin
may not even work before it is built.

If we require buildable plugins to have platform type "indep", then
it's probably also okay for plugin.interface files to have after-build
files, something that is currently disallowed since plugins are
instantiated for each possible platform.

In order to make it possible for the outcome of a plugin's build step
to influence what platforms it provides, it will be necessary for
abuild to build a plugin before executing its list_platforms file.

Consider carefully how explicit targets should apply to plugins.  As
currently coded, --apply-targets-to-deps will result in explicit
targets being applied to plugins.


Building Abuild
===============

 * Consider creating a ./configure that finds boost libraries and
   deals properly with pthread.  Then consider packaging auto-srcs
   with abuild sources.  Check on debian to see if this works with the
   latest flex.  Consider making the re-entrant scanner switch, made
   possible by controlling the flex and bison files provided that
   there is an autoconf check for the right versions of flex and
   bison.  See ~/source/work-software/argon/third-party-support/boost
   for sample boost autoconf code.

   It might be possible to make this work properly when abuild is
   building itself by having a buildable plugin that checks to make
   sure configure has been run.  Bootstrapping makefile can fail if
   configure hasn't been run.


Revamped Build Tree Structure
=============================

Introduce the concept of a "build forest".  A build forest is a
collection of related build trees that are physically located under a
common root.  Build forests already exist with abuild 1.0, but they
are not an explicit entity.

Eliminate the parent-dir key.  Build item X's parent directory is the
next higher directory, if any, whose Abuild.conf lists X's directory
in its child-dirs key.  We must enforce that child-dirs may not
contain .. in any path element, and that there are no intervening
Abuild.conf files between a parent and child Abuild.conf.

Require build tree root Abuild.conf files to include a "tree-name" key
which provides the name of the build tree.  Any Abuild.conf file may
contain a tree-name key.  This makes it the root of a subtree, which
functions very much as externals do in abuild 1.0.  Subtrees are
hooked into the forest like any other build item: through a
higher-level directory's child-dirs key.

Eliminate the external-dirs key.  Introduce in its place a "tree-deps"
key which takes a list of tree names rather than tree paths.  Since we
have no longer have the concept of externals, we no longer have the
concept of read-only externals.  To support the pattern of building a
tree without building any of the other subtrees that it uses, users
must specify -ro-path or -rw-path on the command line at build time.
Absolute path externals also disappear, but they were a bad idea to
begin with.

Allow Abuild.backing files only at forest roots, and allow multiple
backing areas.  Introduce a new Abuild.backing syntax in which one or
more backing areas may be specified in a backing-areas keyword, as in

  backing-areas: /path/to/ba1 /path/to/ba2

Backing areas as searched in the order in which they appear, and in a
depth-first fashion.  The normal integrity guarantee still applies.

Disallow build item directories from being symbolic links.  When a
symbolic link is detected, suggest for people to use a backing area
instead.  This is more practical with support for multiple backing
areas.

Traits, supported flags, and plugins behave with respect to subtrees
in 1.1 just as they behaved with respect to externals in 1.0.  This
means that it is still necessary to repeat plugin declaration lists
for each subtree.  Although this is somewhat unfortunate, it makes it
possible to have reasonable semantics when building an isolated
subtree outside of the context of a backing area.

Example:

  OLD:

   Top-level Abuild.conf files in each leaf below.  No way to know of
   all build trees or their relative positions without visiting each
   root.  No way to get list of build tree roots other than exhaustive
   search.

   top                  (no Abuild.conf)
   |
   |-- common           root Abuild.conf; no externals
   |
   |-- proj1
   |   |
   |   |-- interface
   |   |   |
   |   |   |-- comp1    external-dirs: ../../../common
   |   |   |
   |   |   `-- comp2    external-dirs: ../../../common
   |   |
   |   `-- private
   |       |
   |       |-- comp1    external-dirs: ../../interface/comp1
   |       |
   |       `-- comp2    external-dirs: ../../interface/comp2 ../comp1
   |
   `-- proj2
       |
       |-- common       external-dirs: ../../common
       |
       |-- comp1        external-dirs: ../common
       |
       `-- comp2        external-dirs: ../comp1

  Note that ../../common from proj2/common is the same as
  ../../../common from proj1/interface/comp1 and different from
  ../common in proj2/comp1.


  NEW:

   Top-level Abuild.conf file in top directory; subtrees are hooked in
   with child-dirs just like any other subdirectory.

   top                  tree-name: top
   |
   |-- common           tree-name: common
   |
   |-- proj1
   |   |
   |   |-- interface
   |   |   |
   |   |   |-- comp1    tree-name: proj1-comp1; tree-deps: common
   |   |   |
   |   |   `-- comp2    tree-name: proj1-comp2; tree-deps: common
   |   |
   |   `-- private
   |       |
   |       |-- comp1    tree-name: proj1-comp1-impl; tree-deps: proj1-comp1
   |       |
   |       `-- comp2    tree-name: proj1-comp2-impl;
   |                    tree-deps: proj1-comp2 proj1-comp1
   `-- proj2
       |
       |-- common       tree-name: proj2-common; tree-deps: common
       |
       |-- comp1        tree-name: proj2-comp1; tree-deps: proj2-common
       |
       `-- comp2        tree-name: proj2-comp2; tree-deps: proj2-comp1



Traversal algorithm (approximate since the real algorithm will have
compatibility stuff in it):

 * Find the root of the current build forest.

   English:

   Keep walking up the file system looking for directories containing
   Abuild.conf.  If you find one such that there is no higher
   Abuild.conf or the next higher one doesn't reference it as a child,
   and if this Abuild.conf file has a tree-name key or contains no
   keys other than child-dirs, it is the forest root.

   Pseudocode:

   cur_build_item = this directory
   forest_top = nil

   do until end search
     if cur_build_item's Abuild.conf contains tree-name key OR
           cur_build_item's Abuild.conf contains only child-dirs
        forest_top = cur_build_item
     parent_build_item = next higher Abuild.conf
     if parent_build_item exists and has child pointing to cur_build_item
        cur_build_item = parent_build_item
     else
        if forest_top == cur_build_item
           this is found forest root
	   end search
        else
           forest_top = nil
           error: unable to find top of build forest

   Note that if a parent Abuild.conf is found but it doesn't have a
   child-dirs key that points to the child build item, and if the
   child build item is a build tree root, the search stops, and there
   is no error or warning reported.  This is a normal case of a
   separate, independent tree nested inside another tree.  Examples of
   when you might have this would include test suites that create
   build trees (such as abuild's own test suite) or instances in which
   abuild may be used to build third-party software distributions
   nested within something that contains Abuild.conf files.  If this
   tree was supposed to be connected into higher trees and was not,
   there will probably be unresolved tree-deps or deps values.

 * If the root of the forest does not contain an Abuild.backing, then
   this is an unbacked forest.  If it does contain an Abuild.backing
   file, ensure that each backing area points to a tree root (not
   necessarily a forest root).  In that case, search for the backing
   tree's forest root.  Continue until an unbacked forest is found.
   Traverse the unbacked forest (as described below).

   Note that we impose no restrictions on whether the backing area
   points to the same tree or even to a backing forest that contains
   the same tree.  This makes it possible to add an entirely new
   subtree in a work area that backs to some other area, and then to
   have the backing area later get included inside of a higher-level
   tree without impacting the work area.  This also means that cases
   where we might have used read-only, absolute-path externals in
   abuild 1.0 would now work with multiple backing areas in abuild
   1.1.

 * Traverse the build forest.

     traverse:

     if current item has a tree-name key
        set cur_tree to name of tree
     store current build item in cur_tree
     for each dir in child-dirs
        ensure that dir has no path elements equal to ".."
        if dir has more than one path element
           ensure that no intermediate directories have Abuild.conf
        traverse recursively from dir

 * Verify that each tree in the forest is uniquely named

 * Copy build items from the backing area forests that are absent from
   the local forest into the local list.  Exclude build items that are
   listed as deleted or that belong to trees that are listed as
   deleted in the Abuild.backing file.

 * Make sure that the graph implied by the tree-deps key is an
   error-free directed acyclic graph.  Do not do checks to ensure that
   is bipartite with respect to backing area traversal; save this
   check for the build item level.  This makes it possible to sparsely
   shadow a build tree for the purpose of adding items to it.

   Implementation note: use DependencyGraph.  when we see a new tree
   root, add the node.  When we see a tree-deps, add a dependency.

 * Check dependencies and build item references (but do not report
   errors) for the whole forest rather than doing it separately for
   each build item and copying build items around.  (We only copy
   build items from backing areas, not subtrees.)  Just disallow
   resolution of any build item name in a tree not declared as used.
   This makes it possible to issue error messages akin to "A is not
   allowed to depend on B since A-tree has not declared B-tree as in
   its tree-used key."

 * If in full integrity mode, report all dependency and integrity
   errors.  Otherwise, report errors only for subtrees relevant to the
   current build.

Need to flesh out an example that includes both searchlight and
lh3-style trees.


Compatibility
=============

Starting with version 1.1, abuild runs with a compatibility level
equal to x.y where x.y is a released major/minor version.  In version
1.1, the only valid compatibility levels are 1.0 and 1.1.  When abuild
is running at compatibility level x.y, backward compatibility is
disabled for features deprecated at or before version x.y.  For
example, at compatibility level 1.0, abuild will recognize the "this"
keyword in Abuild.conf, issue a deprecation warning, and treat it as
if it were "name".  At compatibility level 1.1, abuild will not
recognize the "this" key at all.

The default compatibility level is 1.0.  At the present time, there is
no expectation of supporting compatibility levels more than one minor
release old, but this general capability level framework would make
that possible if it were desired.

When abuild recognizes feature from a version between the
compatibility level and the current version, it will issue a
deprecation warning.  Abuild can be run in a mode in which deprecation
warnings are treated as errors.  There will be no option for
suppressing deprecation warnings.

Compatibility mode will work by having abuild map a 1.0 structure into
the internal representation of a 1.1 structure.  Compatibility does
not apply to the command-line invocation of abuild, but only to
Abuild.conf and other build files.  There are some corner cases where
abuild will possibly fail in compatibility mode, such as with
interleaved build items (parent and child dirs skipping over each
other) or backing areas that point to different backing forests, but
the goal is for all "normal" abuild 1.0 trees to create the same
builds with 1.1 as with 1.0.

With pure abuild 1.1, a build item is a build tree root iff it has a
tree-name key.  In pure abuild 1.0, a build item was a build tree root
iff it did not have parent-dir key.  In 1.1 operating at 1.0
compatibility level, the logic is somewhat more complex.  See comments
in ItemConfig::isTreeRoot() for details on how the determination is made.

Note that a build item with only a child-dirs key in its Abuild.conf
can be a forest root even if it is not a tree root.

Here is the full traversal algorithm, including compatibility support.

  # Find forest top.

  forest_top = nil
  candidate_top = nil
  cur_build_item = this directory

  do until end search
     if cur_build_item looks like a root (as determined above) OR
           cur_build_item's Abuild.conf contains only child-dirs
        candidate_top = cur_build_item
     parent_build_item = next higher Abuild.conf
     if parent_build_item exists and has child pointing to cur_build_item
        cur_build_item = parent_build_item
     else
        if candidate_top == cur_build_item
           forest_root = candidate_top
           end search
        else
           error: unable to find top of build forest

# XXXXXX ABOVE THIS POINT IS CODED AND TESTED.

  # Find backing areas

  read any Abuild.backing file in the same directory as forest_top
  if in compatibility mode
     traverse graph formed by external-dirs pointers to locate all
        1.0 roots
     if Abuild.backing file exists, issue deprecation warning, read
     it, and store in a list

  traverse backing areas in order with forest root backing file first
     and then other backing areas as discovered

  traverse local items by doing a depth-first traversal following
     child-dirs pointers and, if in compatibility mode, then following
     external-dirs pointers

XXX Other things to work in: child-dirs and external-dirs should not
be allowed to traverse symbolic links.

XXX Deprecation warnings on old trees: detect if any build item in a
tree uses deprecated features.  This includes both using deprecated
keys and also being a root and not having tree-name.  If that happens
for any item in the tree, issue a single deprecation warning that
points to the user to abuild --upgrade-trees.  Something like

  The build tree whose root build item is located at X uses deprecated
  features.  When you are ready to upgrade this build tree, you can
  use "abuild --upgrade-trees" to do most of the work.  Please see the
  section in the abuild user's manual entitled "Upgrading Build Trees"
  for details.

The build_tree structure changes a bit.  Rather than having a single
list for each tree, we'll have a single list for the forest.  This is
described in the revamped build tree section above.

Note that the traversal of a typical 1.0 build tree will happen in a
slightly different order.  In particular, consider this case:

  A -ext-> B
  A -backs-> A'
  B -backs-> B'
  A' -ext-> B'

In 1.0, traversal would be in the order B', A', B, A.  In 1.1, it will
be A', B', A, B.

During traversal, if we see an Abuild.backing file in any directory
with an Abuild.conf other than those from which we have already
processed the file, report an error message.  This means that, in
compatibility mode, we will not get error messages for Abuild.backing
files in 1.0 roots, but in all cases, we will get error messages for
any other rogue Abuild.backing files.

During traversal, in compatibility mode, we will need to read 1.0
Abuild.conf files as if they were 1.1 files.  The following mapping is
used when reading Abuild.conf files.  In all cases, a deprecation
warning is issued when any mapping rule is applied.

 * If "this" is seen:

    - If "name" is also seen, error

    - Else treat "this" as name

 * If "parent-dir" is seen:

    - If there are any Abuild.conf between here and the parent, error

    - Else if parent does not point to us as child, error

    - Else give a warning about parent-dir and ignore

 * If "deleted-items" is seen, give a warning, and treat it as if we
   had read it out of an Abuild.backing file.

 * If this is a root build item and there is no "tree-name" key,
   generate a tree name.  If the tree has a backing area, use the name
   of the backing area tree.  Otherwise, generate a name of the form
   _tree.<rnd>.<nnn> where <rnd> is a random number (to prevent anyone
   from referencing these tree names anywhere) and nnn is a sequential
   number incremented each time we see a new tree.

 * If external-dirs is encountered:

    - If the external is read-only, if no -ro-path or -rw-path flags
      were given on the command line, act as if its path had been
      specified with -ro-path.  This is also slightly different since
      any subtrees would be treated as read-only by -ro-path and not
      be a read-only external.  If any -ro-path or -rw-path arguments
      were given, indicate that the -ro flag is ignored and that build
      items' read-only status is being determined by the -ro-path and
      -rw-path arguments.

    - Handle the external-dirs as if it were a tree-deps, generating a
      name for the destination tree if it doesn't already have one
      (either explicitly or as a result of an earlier name
      generation).

In addition to the above, we can easily recognize a 1.0 Abuild.backing
file and treat it as if it were a 1.1 file.  We only do this when the
Abuild.backing file is in a directory that appears to contain a 1.0
root, which can, in turn, happen only in compatibility mode.

In all of the above, remember that external-dirs can still appear in a
1.1 root build item if it points to an external tree that has not yet
been converted, and that 1.0 root can have an external-dirs that
points to a 1.1 tree.


1.0 to 1.1 Conversion Tool
==========================

Most or all of the conversion tool should be implemented inside of
abuild proper so that we have the benefit of the real Abuild.conf
parser (ItemConfig) and the DependencyGraph object.

Usage: abuild --upgrade-trees

If abuild.upgrade-data exists, read it.  It can contain two pieces of
information: a mapping from paths (relative to current directory) to
tree names, and a list of directories to prune.  The string *** is
used as a place holder for names of trees that we don't know.

----
[ignore-directories]
# place the names of directories specified relative to the current
# directory, one per line, that you wish to not traverse while
# searching for trees to upgrade.
relative-path
relative-path
...

[island]
path: name
...

[island]
path: name
...

...
----

Traverse file system reading all Abuild.conf files.  Keep track of
which items are roots and which items have errors.

Use DependencyGraph to create a dependency of all build tree roots.

Exit if errors

Analyze the dependency graph to identify islands.

Rewrite abuild.upgrade-data, preserving any previous prune directories
and tree names, with all tree names arranged in islands.  For any tree
for which no name was known, write *** as a place-holder.

If any trees had unknown names, tell user to edit abuild.upgrade-data,
and exit.

Otherwise, for every Abuild.conf that needs to be rewritten, write
Abuild-1.1.conf.

When completely finished, if all went well, for each rewritten file,
rename Abuild.conf to Abuild-1.0.conf and rename Abuild-1.1.conf to
Abuild.conf.

Other issues to work in:

 * Backing areas: we need to be able to resolve externals through
   backing areas and convert backing area files.  When an external is
   resolved through a backing area, make sure the external in the
   backing area has been converted, and pull its name from there.  Do
   not generate a new tree name.  Maybe a good way to do this would be
   to generate an explicit backing area chain for each root and check
   it iteratively.  Need to figure out the exact behavior of
   Abuild.backing files with respect to hybrid 1.0/1.1 trees, if this
   is not already discussed above.

 * If we have externals that fall outside of the forest or in a pruned
   area (i.e., we can find the directory, but it is not one we know
   about either as a root or a regular item), maybe we should leave it
   as an external.  This makes it possible to have forests with
   mixtures of 1.0 and 1.1 trees, which may be important for the
   transition.  E.g., we could leave tps-build-items as 1.0 when
   updating some forests that use it but not others.

   One way to approach this would be to include their paths, relative
   to the start directory, in the abuild.upgrade-data file in a
   section of trees that should remain unconverted.  Only in those
   cases should we leave the external-dirs alone and create a hybrid
   situation.


Converting Abuild.conf files:

 * For root files

    - add tree-name

    - if next Abuild.conf up belongs to a tree in the same island,
      append to (or create) its child-dirs.

 * this -> name

 * parent-dir: remove

 * external-dirs: replace with tree-deps.

 * deleted: remove and store; will be used when we rewrite
   Abuild.backing files.

Converting Abuild.backing files:

 * XXX fill in...process is more or less described in compatibility
   section.

----------------------------------------------------------------------

=== Things with no Specific Release Target ===

Windows Issues
==============

 * There are some Windows path issues.  You can't use absolute paths
   in Windows as long as cygwin is in use because cygwin gnu make will
   not interpret absolute paths in the same way that Windows will for
   purposes of dependencies in .dep files, library dependencies, etc.
   Relative paths should work, but they don't always work because
   Windows seems to have limits on the number of times .. may appear
   in a path (among possibly other things), and besides, there is no
   way to construct a relative path to a file under another drive
   letter.  Ideally, we should be using something like msys and/or
   gnuwin32 rather than cygwin, along with supporting ActivePerl, but
   this has major implications since qtest doesn't currently work
   without cygwin, not to mention the fact that the test suite makes
   free use of unix constructs.

 * gen_deps: rewrite in C++ so that it doesn't force a runtime
   dependency on perl.  It should be a fallback for cases when
   compilers can't generate dependency information.  With gcc, use -MD
   -MF -MP to generate proper .dep files.  xlc: "-M -MF a.dep" works,
   but there is no equivalent to -MP, so we'll need to postprocess.
   VC: there seems to be a /showIncludes option that we may be able to
   exploit.  Not sure what versions of VC++ have this.  This will be
   worth doing if we can remove a runtime dependency on Cygwin for
   Windows/C++.  For non-Windows systems, requiring perl is not a big
   deal.


Compiler/Platform Configuration
===============================

There is a general problem with compiler options, 32-bit and 64-bit
compilers, project-specific configuration, supporting compilers that
aren't known in advance, etc.  This is kind of what toolset was
designed to handle.  The following items are possibly contradictory or
interdependent and need to be sorted out better.  These items all
imply certain things that may need to be done very early in abuild's
life even before private/bin/get_native_platform_data is called.

 * Need a more flexible way of handling compiler options.  It should
   be possible to create plugins that add compiler options to
   internally supported compilers, and options should be able to be
   meaningfully selected in groups.  For example, it should be
   possible to add {m32, m64} that can't be specified together and
   {debug, release} that can't be specified together while allowing
   debug+m32 or release+m64 or other permutations.  This implies the
   need for a canonical form.

 * We need some way for people to change the toolset portion of the
   platform string in a global way for a particular collection of
   build trees.

 * There needs to be better cross-compiler support for things like
   building 32-bit code on a 64-bit system.  Adding -m32 doesn't
   really do it because why should have you
   linux.x86_64.rhel51.gcc.m32 be the same as linux.ix86.rhel51.gcc?


Java Problems
=============

 * Reconsider using depends task for compile in abuild.xml.

 * Our default java compile rule doesn't notice if a .java file was
   removed.  Maybe we want to force full recompilation if the list of
   files changed, or maybe we want to delete class files that appear
   to have come from non-existent java files.  I'm not sure what
   happens with nested/inner classes that disappeared....does javac
   automatically remove the corresponding class files?  This would be
   an easy experiment to try.

 * Ant seems to not complain when populating an ear file from a
   classpath that contains non-existent items.  In general, there may
   be an issue with not getting any notification of non-existent
   classpath items.  Note that, sometimes, you want to try to create
   an ear even of some of its contents aren't there, so this may not
   really be a problem worth fixing.  If we can fix it, we should be
   able to control on a per-build-item basis whether it is an error
   condition or just a warning, probably having "error" be the
   default.


Known Bugs
==========

 * Piping ANSI color stuff through ant on Windows doesn't work.  When
   running qtest from ant on Windows, qtest correctly generates the
   ansi color codes, but they don't get displayed right through ant,
   at least in cygwin.


Issues, Enhancement Ideas
=========================

See also "Known Limitations" in the documentation.

 * Test qtest coverage from abuild test suite.  Relatively low
   priority since abuild's test suite itself uses coverage, so
   abuild's qtest coverage support is exercised every time the abuild
   test suite is run.  (It's just that you might not notice if it
   weren't there.)

 * Think about implementing a dependency analyzer that would look at
   first-level includes to figure out what the correct list of direct
   dependencies should be.

 * Consider having --silent invoke make with --no-print-directory.  If
   we do this, we should follow build item failure with a message that
   contains the name, path, and platform of whatever failed.

 * Consider having an abuild template generator that can run if no
   Abuild.conf or other files are present.  This would spit out
   commented template files.  Alternatively, could be a command-line
   wizard or something.

 * To check for all Abuild.mk files that define local targets:
   pcregrep '^\s*\S+\s*:(\Z|[^=])' **/Abuild.mk

 * Consider using re-entrant scanners instead of C++ scanners.  This
   requires flex >= 2.5.33.  Have abuild's own build process detect
   whether or not a new enough version of flex is available.  If so,
   it should generate the parsers and attempt to update a cached copy
   of the automatically generated files if they have changed.
   Otherwise, it should use the cached files by adding them to SRCS in
   place of the automatically generated ones.  We also need to disable
   warnings for the flex-generated code.  Use %option nounistd.  (This
   suggestion may be simplified if better support for files generated
   by optional tools is added.)

 * It would be nice if there were a mechanism for providing
   documentation on traits so that --list-traits could tell the user
   how each trait was intended to be used.

 * Consider capturing the output of the backend so that we can
   de-interleave output when running parallel builds (or mark each
   line of output with the build item/platform data), separate error
   from informational output, etc.  It is possible to create pipe-like
   handles with CreatePipe in Windows and to use them to initialize
   hStdInput, hStdOutput, and hStdError fields of the startupinfo
   parameter to CreateProcess.  There is an example at
   http://lists.trolltech.com/qt-interest/1999-09/thread00282-0.html
   There is also some kind of Win32 Job API used by the perl
   Win32::Job classes (CreateJobObject).  This may provide a better
   solution than our current CTRL-C handling.  See if boost provides
   anything that could do this.

 * Clean up ~/source/examples/java/native/abuild and use as JNI
   example

 * ccxx: Consider enforcing that no object file may appear both as a
   program and a library object file and that no object file may be
   generated from more than one source file (with different suffixes)

 * In the manual, it would be nice if we could use higher resolution
   figures for the PDF than for the HTML.  There is plenty of material
   in the sagehill.net DocBook XSL guide about this.  The best
   solution would be to convert the figures to SVG.  It may work to
   use graphviz to generate the SVG.

 * Orphan target detection in make won't find orphan targets in
   subdirectories.  This is very hard to fix in general.  We could
   search directories represented in the source lists, but that
   wouldn't help if we removed the last file from a subdirectory.  For
   now, we'll just not handle this case.

 * Mingw support isn't that complete: see known limitations in the
   documentation and comments in private/list_platforms.  If it is
   improved, consider improving support for recognizing it so that the
   user doesn't have to set MINGW=1.  Search for mingw in the
   documentation and adjust as needed.

 * Consider adding a trouble shooting section to the documentation,
   web site, or wiki

    - example: library name inconsistency between Abuild.mk and
      Abuild.interface

 * Cass Dalton reports that he sometimes gets "resource busy" errors
   when running autoconf with --make-jobs.

 * It might be useful to have abuild recognize certain error
   conditions currently reported as global as instead being specific
   to a given build item, but this would be a high-risk change that
   has some of its own disadvantages.

   The idea would be to detect errors currently reported as global
   and, instead of having them prevent any builds from happening, have
   them just block builds of the specific items they pertain to.  This
   would make it possible, for example, to have a --build=desc work
   properly if there are dependency errors, cycles, or other similar
   types of errors on build items that are not related to the portion
   of the tree being built.

   Exmaple error conditions that could be handled in this way include
   depending on an unknown item, participating in a dependency cycle,
   referencing an unknown item in a trait, referencing an unknown flag
   for another item, having an invalid platform-specific dependency,
   etc.  An implementation strategy for doing this would be to have a
   buildError method that takes an item name and platform string, with
   an empty platform string indicating an error that would apply to
   all platform instantiations for the item.  Abuild would report the
   error but not increment the global error count, thus preventing
   exitIfErrors from exiting.  It would also store fact that an error
   was associated with the specific build item and/or build
   item/platform pair.  During the build of the item, if any
   non-platform-specific errors or if an error for the specific
   item/platform had been issued, the build for that item would be
   skipped.

   The above change, as described, would be straightforward to
   implement, but there are two siginificant issues:

    - This change would allow certain error conditions that really do
      have to get fixed from being purposely ignored or even
      accidentally overlooked for a longer period of time.  This goes
      against the idea of abuild trying to force early detection and
      correction of errors.

    - The code as currently implemented performs numerous validations.
      Once call to exitIfErrors has been made, subsequent code assumes
      all previous validations have succeeded.  For any current error
      condition that would be changed to a buildError, the rest of the
      code would have to be carefully inspected to ensure that prior
      assumptions have not become invalid.  This would be a shame
      since the early validation of certain error conditions helps to
      reduce the complexity of the abuild code.

   Consider the implications, especially of the second point.  Build
   graph construction code assumes that all platform information and
   dependency information stored in a build item is valid, and that
   information is accessed in a read-only fashion from the build
   item's config data.  This means that we either have to add checks
   throughout the code to make sure any dependency we retrieve is
   valid or else we need to remove a dependency from the list of
   dependencies.  The former would complicate the code and make it
   more fragile, not to mention the fact that the test suite doesn't
   cover any such cases now since they are prevented from happening.
   The latter would also have disadvantages.  For example, it would no
   longer be possible to use --dump-data to locate build items that
   depend on a particular unknown build item or otherwise to help
   clean up errors of this type.
