
Abuild Lint
==============

 * Upgrade abuild-lint to make it useful and then include it in
   abuild-contrib or as its own release.

 * Detect -- in build item names and warn about not meaning private
   anymore.


Windows Issues
==============

 * There are some Windows path issues.  You can't use absolute paths
   in Windows as long as cygwin is in use because cygwin gnu make will
   not interpret absolute paths in the same way that Windows will for
   purposes of dependencies in .dep files, library dependencies, etc.
   Relative paths should work, but they don't always work because
   Windows seems to have limits on the number of times .. may appear
   in a path (among possibly other things), and besides, there is no
   way to construct a relative path to a file under another drive
   letter.  Ideally, we should be using something like msys and/or
   gnuwin32 rather than cygwin, along with supporting ActivePerl, but
   this has major implications since qtest doesn't currently work
   without cygwin, not to mention the fact that the test suite makes
   free use of unix constructs.  I believe this problem is also a
   contributor to the lack of good mingw support, and is certainly
   the cause of builds not being able to work properly with files
   spanning multiple drive letters.

 * gen_deps: rewrite in C++ so that it doesn't force a runtime
   dependency on perl.  It should be a fallback for cases when
   compilers can't generate dependency information.  With gcc, use -MD
   -MF -MP to generate proper .dep files.  xlc: "-M -MF a.dep" works,
   but there is no equivalent to -MP, so we'll need to postprocess.
   VC: there seems to be a /showIncludes option that we may be able to
   exploit.  Not sure what versions of VC++ have this.  This will be
   worth doing if we can remove a runtime dependency on Cygwin for
   Windows/C++.  For non-Windows systems, requiring perl is not a big
   deal.


Information Extraction
======================

 * Provide arguments for querying abuild's state, such as listing all
   trees with locations and dependencies, summarizing the state of all
   plugin information (which items are plugins in any tree, which tree
   provides the plugin, and which trees use the plugin), etc.  The
   --dump-data option will always be available for providing full
   information, but providing a more human-readable format for
   commonly needed information will help.  Or maybe provide some
   sample xslt scripts to the above.

 * Provide a way to get --dump-data's output into a relational
   database.  Ideally, we shouldn't have to link with sqlite.  Maybe
   have an option that causes --dump-data to generate a script file
   that can be used with sqlite3 rather than generating XML data.
   Alternatively, we can create xsl/perl code that loads directly into
   a sqlite database or that creates the input file.  It's probably
   okay if we create the SQL such that an erroneous dumpdata won't
   load.  For example, the SQL can enforce uniqueness and referential
   integrity constraints even though they may not be satisfied when
   there are errors.


Compiler/Platform Configuration
===============================

There is a general problem with compiler options, 32-bit and 64-bit
compilers, project-specific configuration, supporting compilers that
aren't known in advance, etc.  This is kind of what toolset was
designed to handle.  The following items are possibly contradictory or
interdependent and need to be sorted out better.  These items all
imply certain things that may need to be done very early in abuild's
life even before private/bin/get_native_platform_data is called.

 * Need a more flexible way of handling compiler options.  It should
   be possible to create plugins that add compiler options to
   internally supported compilers, and options should be able to be
   meaningfully selected in groups.  For example, it should be
   possible to add {m32, m64} that can't be specified together and
   {debug, release} that can't be specified together while allowing
   debug+m32 or release+m64 or other permutations.  This implies the
   need for a canonical form.

 * We need some way for people to change the toolset portion of the
   platform string in a global way for a particular collection of
   build trees.  Right now, it can only be done for "native" by
   editing private/bin/get_native_platform_data.

 * Use of ABUILD_FORCE{32,64}_BIT is close for 32/64-bit
   configurations, but it doesn't always make the platform consistent
   without the object file format.  For example, ppc64 on rhel5 is
   32-bit by default, and on Solaris, the platform name doesn't change
   depending on 32- or 64-bit.  Adding another field to the platform
   seems like overkill, though generating smarter CPU strings might be
   worth doing.


Platform Conditionals
=====================

There are some problems with this proposal...

The goal is to support some kind of platform-based conditional
dependency while preserving the fundamental design goal of having a
static build graph.  We will support this only for build items of type
native.  Here's how it would work:

 * Native build items can specify some kind of platform-based
   inclusion/exclusion rules in Abuild.conf.  Maybe we'll add keywords
   build-if-platform-matches and build-unless-platform-matches, each
   of which takes arguments of the form a.b.c.d.  Each field can be a
   fixed string or * and is matched against the corresponding field of
   the platform identifier.  If both keywords appear, platform strings
   have to satisfy both.  For example,

   build-if-platform-matches: linux.*.*.gcc *.*.*.xlc
   build-unless-platform-matches: windows.*.*.*

   would mean to build on linux with gcc and everywhere except windows
   on xlc.

 * Abuild will first construct and validate the build graph
   disregarding platform restrictions.  This ensures that the build
   graph can't be invalid for some combination of available platforms
   and not for others.

 * Once the build graph is validated, abuild will traverse the build
   graph again and prune the graph at each node whose platform doesn't
   satisfy the platform restrictions.

There are several possible implications to think through.  What
happens with build items that get built "as needed" to satisfy
platform constraints but then are no longer needed after pruning?  It
may be that we have to create two build graphs, one that disregards
platform restrictions and one that doesn't.  The second build graph
should always be a proper subset of the first one, so there should be
no possibility of errors existing in the second one.

But actually, it's worse than that.  What about items that get added
to the build set just to satisfy dependencies that are no longer
required?  Do we want those?  It's like we have to mark build items as
explicit or implicit and then prune any unreferenced implicit items
after paying attention to platform restrictions.

Consider native build items:

a: b c
b: d

b is 'windows only'

When doing abuild -d from a on a non-windows platform, we only want to
build a and c, but when doing abuild -b all on a non-windows platform,
we want a, c, and d.  In the first case, d is an implicit member of
the build set, and in the second case, d is an explicit member.  For
the build graph, we can mark things as explicit if they are explicit
items on selected platforms.  Explicit items on as-needed platforms
are implicit.  To detect unreferenced implicit members, we could
traverse the pruned build graph starting from each explicit node and
mark things as seen when we encounter them.  Then, anything that's not
seen can be removed.  We'll need to test cases with platform-specific
dependencies to make sure the logic is sound.  Also consider whether
the special failure build item used to implement recovery from certain
types of cycle errors should be explicit.

It would also be nice if this could enable us to express "I want the
version of X built with compiler A on platform P but the default
compiler everywhere else."  Try to work that in.


Java Problems
=============

 * Wrapper generation for both groovy and ant creates
   platform-specific files in the abuild-java directory.  The wrapper
   is platform-specific because Windows and UNIX need different
   scripts because of different path formats.  Even if they didn't,
   the wrapper may have system-specific paths in it.  This means that
   doing a of a java item on Windows and running the test suite on
   UNIX, or vice versa, may not work properly.

 * Reconsider using depends task for compile in abuild.xml.

 * Our default java compile rule doesn't notice if a .java file was
   removed.  Maybe we want to force full recompilation if the list of
   files changed, or maybe we want to delete class files that appear
   to have come from non-existent java files.  I'm not sure what
   happens with nested/inner classes that disappeared....does javac
   automatically remove the corresponding class files?  This would be
   an easy experiment to try.

 * Ant seems to not complain when populating an ear file from a
   classpath that contains non-existent items.  In general, there may
   be an issue with not getting any notification of non-existent
   classpath items.  Note that, sometimes, you want to try to create
   an ear even of some of its contents aren't there, so this may not
   really be a problem worth fixing.  If we can fix it, we should be
   able to control on a per-build-item basis whether it is an error
   condition or just a warning, probably having "error" be the
   default.


Known Bugs
==========

 * Piping ANSI color stuff through ant on Windows doesn't work.  When
   running qtest from ant on Windows, qtest correctly generates the
   ansi color codes, but they don't get displayed right through ant,
   at least in cygwin.


Capture of Backend Output
=========================

There have been a number of ideas about improving abuild's output,
such as de-interleaving build outputs for multithreaded builds,
prefixing output lines with the name/platform of the item being built,
indenting all non-error output so that error output only is
left-justified, etc.

There are a number of roadblocks that make this difficult.  For one
thing, java builds are all run from a single process with different
threads possibly all generating output.  Some of this output might be
generated with direct prints to stdout or stderr and, as such, cannot
be separated by which build item they are running on behalf of.  It
would potentially be possible to isolate output from each make
invocation or to isolate all java output together.  It would be
possible to sort java output by build item if we ran a separate java
builder for each potential simultaneous build (creating a number equal
to the number of build threads), but this seems like excessive
overhead and complication just to filter output for a multithreaded
build.

It seems to be very difficult to emulate the behavior of a command
writing to a tty in a portable fashion, especially in Windows.  It so
happens that make doesn't buffer its output, so running it through a
pipe works fine, but this is not necessarily the case for things it
invokes.  There's also the question of what to do with stdin.  There
are some interactive test suites, for example, that want access to
stdin, and it would be a shame if running through abuild disabled
this functionality.

General separation of stdout and stderr could probably be achieved
with a stand-alone program.  That program may not even have to be
portable -- it would just be usable on those platforms for which the
functionality exists.

If we did want to capture backend output, here are some notes.  It is
possible to create pipe-like handles with CreatePipe in Windows and to
use them to initialize hStdInput, hStdOutput, and hStdError fields of
the startupinfo parameter to CreateProcess.  There is an example at
http://lists.trolltech.com/qt-interest/1999-09/thread00282-0.html
There is also some kind of Win32 Job API used by the perl Win32::Job
classes (CreateJobObject).  This may provide a better solution than
our current CTRL-C handling.  As of version boost version 1.38, there
is nothing in boost that can do this.


Issues, Enhancement Ideas
=========================

See also "Known Limitations" in the documentation.

 * Think about implementing a dependency analyzer that would look at
   first-level includes to figure out what the correct list of direct
   dependencies should be.

 * Consider having an abuild template generator that can run if no
   Abuild.conf or other files are present.  This would spit out
   commented template files.  Alternatively, could be a command-line
   wizard or something.

 * To check for all Abuild.mk files that define local targets:
   pcregrep '^\s*\S+\s*:(\Z|[^=])' **/Abuild.mk

 * It would be nice if there were a mechanism for providing
   documentation on traits so that --list-traits could tell the user
   how each trait was intended to be used.

 * Clean up ~/source/examples/java/native/abuild and use as JNI
   example

 * ccxx: Consider enforcing that no object file may appear both as a
   program and a library object file and that no object file may be
   generated from more than one source file (with different suffixes)

 * In the manual, it would be nice if we could use higher resolution
   figures for the PDF than for the HTML.  There is plenty of material
   in the sagehill.net DocBook XSL guide about this.  The best
   solution would be to convert the figures to SVG.  It may work to
   use graphviz to generate the SVG.

 * Orphan target detection in make won't find orphan targets in
   subdirectories.  This is very hard to fix in general.  We could
   search directories represented in the source lists, but that
   wouldn't help if we removed the last file from a subdirectory.  For
   now, we'll just not handle this case.

 * Mingw support isn't that complete: see known limitations in the
   documentation and comments in private/list_platforms.  If it is
   improved, consider improving support for recognizing it so that the
   user doesn't have to set MINGW=1.  Search for mingw in the
   documentation and adjust as needed.

 * Consider adding a trouble shooting section to the documentation,
   web site, or wiki

    - example: library name inconsistency between Abuild.mk and
      Abuild.interface

 * Java out of memory problem with ant is reportedly fixed with
   1.5.0_12.  Actually, it still happens with 1.5.0_15, but much less
   often.

 * abuild_contrib: include a generic UNIX compiler configurable plugin
   for which the user can set up the compliation commands using
   autoconf.  Consider including a libtool configurable plugin or
   using libtool in this plugin.
