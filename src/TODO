
=== Changes Targeted for Version 1.1 ===

Notes for Next Release
======================

Remember to keep deprecated features list up-to-date.  Add the
following:

 * ...

These changes have already been made and need to make it into the
release notes.

 * Documentation for new features (other than groovy framework) is
   being placed in src/manual/pending.txt until it is integrated into
   the documentation.

 * In groovy backend, cache loading of rules for a significant
   performance boost

 * NON-COMPATIBLE CHANGES TO EXTERNALS:

    - -winpath is no longer a valid option to external-dirs.

    - Absolute path externals are no longer supported.

    - external-dirs may no longer be symbolic links nor may they cross
      symbolic links.  If you are relying on symbolic links to
      externals, you can probably use externals that do nothing but
      point to other externals instead.  Also, abuild 1.1 supports
      multiple backing areas, which might provide another solution.

    - The -ro flag for externals is ignored; use -ro-path or -rw-path
      instead.  It's also possible that some uses of read-only
      externals could be replaced with backing areas instead,
      especially since multiple backing areas are now supported.

 * Compatibility level can be set with the ABUILD_COMPAT_LEVEL
   environment variable in addition to the command line argument.  The
   command line argument takes precedence.

 * Having a child-dirs entry be a symbolic link or cross a symbolic
   link now results in an explicit error message.  This has never
   really worked, but in the past, the result would most likely have
   been something about a parent/child mismatch.

 * Changed build set "all" to mean all known build items in all trees
   in the forest.

 * Added build set "deptrees" to mean all build trees in the tree-deps
   chain, including the current build tree.  This build set would
   build what "all" builds in 1.0.

 * Default build ordering has changed so that tree ordering is used
   before item ordering in the sort.  This means that if tree A
   declares tree B as a tree dependency (or uses it as an external)
   all of A's build items will build before any of B's build items (in
   a single-threaded build).  Build ordering is always determined by
   build item dependencies.

 * Replaced "this" with "name"

 * The value of parent-dir is completely ignored other than to check
   it enough to make sure that ignoring it doesn't change anything.

 * Require trees to be named.  Replace externals with subtrees.
   Eliminate absolute path and read-only externals, but provide an
   alternative to read-only externals for the desired functionality.

 * Move "deleted-items" key from root Abuild.conf to Abuild.backing.
   Also add a "deleted-trees" key.  New Abuild.backing format:

     backing-areas: /path/to/backing/area
     deleted-trees: trees not to shadow
     deleted-items: items not to shadow

 * Support multiple backing areas.  If there are multiple, independent
   backing areas, they must be disjoint (i.e., they must not both
   supply the same item or tree).

 * Implemented abuild --upgrade-trees.  You should not attempt to
   upgrade trees manually.  Although abuild will work fine with mixed
   1.0/1.1 trees, you will get a lot more warnings and possibly
   incorrect results in some cases (though no such cases are known) if
   you partially upgrade your trees.  There is A LOT to keep track of
   when upgrading your trees.  You are much better off letting abuild
   do it for you.

 * New interface variables ABUILD_ITEM_NAME and ABUILD_TREE_NAME

 * --ro-path, --rw-path

 * Removed all "clean" targets supplied by backends.  Abuild now
   internally handles clean even when run from an output directory.

 * When abuild is run with no arguments, its default behavior will be
   to act as if --with-deps had been specified.  A new flag
   "--no-deps" can be used for the case in which one should build just
   the item with no dependencies.

 * Platform-specific dependencies obey user-supplied platform
   selectors.  The rationale for not doing this before was that the
   command-line and environment should not affect the shape of the
   build graph, but that's not really a good reason since this is a
   myth anyway.  People can always run with DFLAGS=-g or set an
   environment variable used by a specific platform plugin's
   list_platforms script to suppress the platform.  If a specific
   compiler or option is required, it can be specified explicitly with
   the platform-specifier in the dependency.

   To explicitly disregard user-supplied platform selectors, it is
   possible to specify "default" as the platform selector, as in

   deps: item -platform=platform-type:default

   It is also possible to specify an explicitly empty option, as in

   deps: item -platform=platform-type:option=

   Both the empty option and "default" platform selector are available
   on the command-line as well, making it possible to run

   abuild -p option=debug -p native:default

   or

   abuild -p option=debug -p native:option=

 * Introduce new Abuild.conf key "attributes", which can be used to
   assign specific attributes to a build item.  Two attributes are
   initially supported "global-tree-dep", and "global-plugin".

   The "global-tree-dep" attribute may be set for a root build item of
   a named tree.  When set, the tree is implicitly made a tree
   dependency of all trees (other than itself).  As such, trees with
   the global-tree-dep attribute may not themselves declare tree
   dependencies since any such dependencies would be in a cycle
   involving the global tree dependency.

   The "global-plugin" attribute may be declared to any build item
   that is inside a tree with the "global-tree-dep" attribute and
   which meets all of the qualifications of being a plugin.  Such
   build items are implicitly added to the list of plugins for all
   build trees.  At present, global plugins are checked with each
   build tree as if they were explicitly declared as a plugin in each
   tree.  Therefore, certain error messages may be repeated for each
   tree.  The error messages themselves indicate this in some
   instances.

   These are both powerful features that should be used with caution.
   In general, it is better for trees to decide on their own which
   items are going to be plugins and which trees they are going to
   depend on.  However, there are certain instances, such as the
   addition of new compiler plugins or plugins that check project-wide
   policy, where use of global plugins may be advisable.

 * Pass information about the native os, cpu, and toolset to
   list_platforms.  list_platforms is now invoked as

   list_platforms [ --windows ] --native-data os cpu toolset

 * Groovy changes: package-rar has become package-high-level-archive,
   some parameters and attributes have been renamed.


MSVC toolchain
==============

 * According to Microsoft, we should always be using /Zi.  We need to
   revisit all the arguments passed to msvc to see what they really
   mean and to figure out which to use in release and debug modes.

   # /Zi enables all debugging information.
   DFLAGS ?= /Zi
   OFLAGS ?= /O2
   # /Wall is impractical with msvc because too many system headers
   # generate warnings.
   WFLAGS ?=

   ifeq ($(words $(DFLAGS)), 0)
   THREAD_FLAGS = /MD
   else
   THREAD_FLAGS = /MDd
   endif

   CC = cl /Gy /EHsc /nologo $(THREAD_FLAGS)
   CCPP = $(CC) /E
   CXX = $(CC) /TP /GR
   CXXPP = $(CXX) /E

   /Zi
   /O2
   /MD
   /MDd
   /Gy
   /EHsc

   /E
   /TP /GR

 * To build for .NET, we need to pass /clr rather than /EHsc to msvc.
   /EHsc is hard-coded into $(CC) right now.  We need to fix msvc.mk
   to make it easier to override these flags.  When going back through
   all flags to see what they do, create variables that can be
   overridden based on function.


Help system
===========

 * Consider adding a new special-case target "help" that would provide
   help in a manner that does not require invoking a back end.  This
   should remove the serious problems with rules-help and
   interface-help, and should get around the problem of trying to echo
   help information from a build file.  This would work by having
   abuild automatically display certain internal help files and build
   item-provided help files.  Most likely, abuild would just display
   all the help files provided by other build items that impact your
   build (dependents, plugins, rule/hook build items, etc.) as well as
   internal help files.  Help files, including internal ones, should
   provide a list of variables that can be set or read, what they
   mean, and how to use them.


Groovy Framework
================

 * Java out of memory problem with ant is reportedly fixed with
   1.5.0_12.  Actually, it still happens with 1.5.0_15.

 * Update rules/java/java_help.txt

 * Document smoewhere that lazy jar signing is true by default in
   order to have idempotent builds

 * Need to figure out what desired junit and javadoc behavior should
   be.  Maybe junit should be able to support multiple testsuites?

 * Exercise javadoc in test suite.  Use
   abuild-java-rules/data/jars/simple.


Compiler Verification
=====================

 * Update compiler verification to work with compat level 1.1.  Test
   compiler verification for verification of a compiler that requires
   a plugin in another tree.


Core Changes
============

 * Add flag --with-rdeps to add to the build set all items anywhere in
   the forest that have items in the initial build set in their
   expanded dependency chains.  (Note that is recursive by nature: if
   A depends on X and B depends on A, then B also depends on X.)

 * Implement two forms of conditional dependencies:

    - deps: item -optional
    - tree-deps: tree-name -optional

   In the first case, abuild will not complain if a given dependency
   is not found.  Some mechanism will be provided that will enable a
   build item to test in its Abuild.interface file (and therefore in
   its Abuild.mk or Abuild-ant.properties file) whether an optional
   dependency is satisfied.  In the second case, abuild will not
   complain if a given tree is not found.

   A new boolean interface variable (analogous to abDIR_build-item)
   will be defined for each build item that exists or that is declared
   as an optional dependency.  This variable will be true iff the
   build item exists.


Documentation
=============

 * Mention somewhere that people can copy jars into abuild's lib
   directory if I want that to be something people do...

 * Incorporate manual/groovy-framework.txt and manual/pending.txt.

 * Read through all 1.1 release notes and update the body of the
   documentation accordingly.  Save this until all the new features
   are implemented, if possible.

 * Note: references to ant examples are still in the documentation.
   There are comments like <!-- ?example ....? --> marking where the
   file references used to be.  Files can be found in the abuild-ant
   test suite.  Paths that used to start with java now start with
   basic.

 * Describe groovy framework (obviously).  Specific things to remember:

    - For groovy backends, defining a new test procedure requires only
      defining a closure for the 'test-only' target.  Abuild
      automatically calls this from test or check.

    - document fields and interface of BuildState ("abuild").  Also
      describe parameter handling.  setParameter vs. getVariable, which
      looks at defines, parameters, interface, and default in that order

    - QTest.export prop for groovy backend; also automatic export of
      TESTS

    - abuild.local-rules, abuild.rules

 * Describe somewhere why we don't provide information about platforms
   in the interface files for java and indep.  Basically, it would be
   a bug to have an interface variable have a different value in
   different contexts when it might influence a build that could be
   used on multiple platforms.  For example, an indep build item could
   write out some value based on a platform variable and then that
   information could be wrong when the results of the build were used
   on a different platform.  If you really need to know what platform
   you are on for something indep or java, you can always get the
   information using a cross-platform dependency, which at least makes
   it visible.  But remember that text files containing
   platform-dependent values (like pathnames, etc.) are in fact
   platform-dependent.

 * Mention that we don't support descrpition for unnamed build items,
   including nameless tree roots, because we don't store anything
   about unnamed build items.  If you want a description in your tree
   root, give it a name.  Comments are allowed anywhere.


Usability Improvements
======================

 * Provide arguments for querying abuild's state, such as locating
   build items (perhaps with pattern matching), listing all trees with
   locations and dependencies, summarizing the state of all plugin
   information (which items are plugins in any tree, which tree
   provides the plugin, and which trees use the plugin), etc.  The
   --dump-data option will always be available for providing full
   information, but providing a more human-readable format for
   commonly needed information will help.

 * Make sure abuild --help references the build/clean set list from
   the --build and --clean argument description, and make sure there
   is a reference to the platform selector information from the
   --platform-selector argument description.  Also divide the output
   clearly into OPTIONS and TARGETS.

 * Incorporate as much of abuild-lint as possible or otherwise include
   abuild-lint in the distribution.

 * Provide a way to get --dump-data's into a relational database.
   Ideally, we shouldn't have to link with sqlite.  Maybe have an
   option that causes --dump-data to generate a script file that can
   be used with sqlite3 rather than generating XML data.
   Alternatively, we can create xsl/perl code that loads directly into
   a sqlite database or that creates the input file.  It's probably
   okay if we create the SQL such that an erroneous dumpdata won't
   load.  For example, the SQL can enforce uniqueness and referential
   integrity constraints even though they may not be satisfied when
   there are errors.


Plugins
=======

 * Create an example of plugins that have to be preconfigured.
   Examples would include a generic UNIX compiler plugin.  This can
   probably be done without making any changes to the plugin system.
   The generic UNIX compiler plugin may also make a good example of
   using a global plugin.


Abuild Contrib
==============

 * Fix deprecation warnings (Rules.mk) in pkg-config.

 * Make sure any compiler plugins included with abuild contrib have
   the 1.0.2 fixes integrated into them.

 * Include a generic UNIX compiler configurable plugin for which the
   user can set up the compliation commands using autoconf.  Or maybe
   this could be implemented using a global platform build item.

 * Consider including a libtool configurable plugin.


Platform Issues
===============

 * Consider Deprecating ABUILD_FORCE_32BIT and adding
   ABUILD_FORCE_WORDSIZE={32,64}.  Search for FORCE32 in the code.
   The only references are in private/bin/get_native_platform_data and
   make/toolchains/gcc.mk.


Changes to "make" Code
======================

 * Need a better solution for files that are automatically generated
   by optional tools.  Abuild itself could use this for flex/bison
   files.  We could also use it for cases like xbinder where
   generating the files requires a special license.  We need a clean
   way to handle the following:

    - Regeneration of the files if they are out of date and the tools
      are available.

    - Use of cached files if they are not out of date.

    - Error if the files are out of date and the tools are not
      available.

   This implies, at least for these cases, some kind of checksum-based
   method (rather than using modification times) to tell whether files
   are out of date.  That way, checkouts from the version control
   system can work even when the CM system does not preserve
   modification times.


Platform Conditionals
=====================

(This item is low priority for 1.1.)

The goal is to support some kind of platform-based conditional
dependency while preserving the fundamental design goal of having a
static build graph.  We will support this only for build items of type
native.  Here's how it would work:

 * Native build items can specify some kind of platform-based
   inclusion/exclusion rules in Abuild.conf.  Maybe we'll add keywords
   build-if-platform-matches and build-unless-platform-matches, each
   of which takes arguments of the form a.b.c.d.  Each field can be a
   fixed string or * and is matched against the corresponding field of
   the platform identifier.  If both keywords appear, platform strings
   have to satisfy both.  For example,

   build-if-platform-matches: linux.*.*.gcc *.*.*.xlc
   build-unless-platform-matches: windows.*.*.*

   would mean to build on linux with gcc and everywhere except windows
   on xlc.

 * Abuild will first construct and validate the build graph
   disregarding platform restrictions.  This ensures that the build
   graph can't be invalid for some combination of available platforms
   and not for others.

 * Once the build graph is validated, abuild will traverse the build
   graph again and prune the graph at each node whose platform doesn't
   satisfy the platform restrictions.

There are several possible implications to think through.  What
happens with build items that get built "as needed" to satisfy
platform constraints but then are no longer needed after pruning?  It
may be that we have to create two build graphs, one that disregards
platform restrictions and one that doesn't.  The second build graph
should always be a proper subset of the first one, so there should be
no possibility of errors existing in the second one.

But actually, it's worse than that.  What about items that get added
to the build set just to satisfy dependencies that are no longer
required?  Do we want those?  It's like we have to mark build items as
explicit or implicit and then prune any unreferenced implicit items
after paying attention to platform restrictions.

Consider native build items:

a: b c
b: d

b is 'windows only'

When doing abuild -d from a on a non-windows platform, we only want to
build a and c, but when doing abuild -b all on a non-windows platform,
we want a, c, and d.  In the first case, d is an implicit member of
the build set, and in the second case, d is an explicit member.  For
the build graph, we can mark things as explicit if they are explicit
items on selected platforms.  Explicit items on as-needed platforms
are implicit.  To detect unreferenced implicit members, we could
traverse the pruned build graph starting from each explicit node and
mark things as seen when we encounter them.  Then, anything that's not
seen can be removed.  We'll need to test cases with platform-specific
dependencies to make sure the logic is sound.  Also consider whether
the special failure build item used to implement recovery from certain
types of cycle errors should be explicit.

It would also be nice if this could enable us to express "I want the
version of X built with compiler A on platform P but the default
compiler everywhere else."  Try to work that in.


Building Abuild
===============

 * Consider creating a ./configure that finds boost libraries and
   deals properly with pthread.  Then consider packaging auto-srcs
   with abuild sources.  Check on debian to see if this works with the
   latest flex.  Consider making the re-entrant scanner switch, made
   possible by controlling the flex and bison files provided that
   there is an autoconf check for the right versions of flex and
   bison.  See ~/source/work-software/argon/third-party-support/boost
   for sample boost autoconf code.

   It might be possible to make this work properly when abuild is
   building itself by having a plugin that checks to make sure
   configure has been run.  Bootstrapping makefile can fail if
   configure hasn't been run.

----------------------------------------------------------------------

=== Things with no Specific Release Target ===

Windows Issues
==============

 * There are some Windows path issues.  You can't use absolute paths
   in Windows as long as cygwin is in use because cygwin gnu make will
   not interpret absolute paths in the same way that Windows will for
   purposes of dependencies in .dep files, library dependencies, etc.
   Relative paths should work, but they don't always work because
   Windows seems to have limits on the number of times .. may appear
   in a path (among possibly other things), and besides, there is no
   way to construct a relative path to a file under another drive
   letter.  Ideally, we should be using something like msys and/or
   gnuwin32 rather than cygwin, along with supporting ActivePerl, but
   this has major implications since qtest doesn't currently work
   without cygwin, not to mention the fact that the test suite makes
   free use of unix constructs.  I believe this problem is also a
   contributor to the lack of good mingw support, and is certainly
   the cause of builds not being able to work properly with files
   spanning multiple drive letters.

 * gen_deps: rewrite in C++ so that it doesn't force a runtime
   dependency on perl.  It should be a fallback for cases when
   compilers can't generate dependency information.  With gcc, use -MD
   -MF -MP to generate proper .dep files.  xlc: "-M -MF a.dep" works,
   but there is no equivalent to -MP, so we'll need to postprocess.
   VC: there seems to be a /showIncludes option that we may be able to
   exploit.  Not sure what versions of VC++ have this.  This will be
   worth doing if we can remove a runtime dependency on Cygwin for
   Windows/C++.  For non-Windows systems, requiring perl is not a big
   deal.


Compiler/Platform Configuration
===============================

There is a general problem with compiler options, 32-bit and 64-bit
compilers, project-specific configuration, supporting compilers that
aren't known in advance, etc.  This is kind of what toolset was
designed to handle.  The following items are possibly contradictory or
interdependent and need to be sorted out better.  These items all
imply certain things that may need to be done very early in abuild's
life even before private/bin/get_native_platform_data is called.

 * Need a more flexible way of handling compiler options.  It should
   be possible to create plugins that add compiler options to
   internally supported compilers, and options should be able to be
   meaningfully selected in groups.  For example, it should be
   possible to add {m32, m64} that can't be specified together and
   {debug, release} that can't be specified together while allowing
   debug+m32 or release+m64 or other permutations.  This implies the
   need for a canonical form.

 * We need some way for people to change the toolset portion of the
   platform string in a global way for a particular collection of
   build trees.

 * There needs to be better cross-compiler support for things like
   building 32-bit code on a 64-bit system.  Adding -m32 doesn't
   really do it because why should have you
   linux.x86_64.rhel51.gcc.m32 be the same as linux.ix86.rhel51.gcc?


Java Problems
=============

 * Wrapper generation for both groovy and ant creates
   platform-specific files in the abuild-java directory.  The wrapper
   is platform-specific because Windows and UNIX need different
   scripts because of different path formats.  Even if they didn't,
   the wrapper may have system-specific paths in it.  This means that
   doing a of a java item on Windows and running the test suite on
   UNIX, or vice versa, may not work properly.

 * Reconsider using depends task for compile in abuild.xml.

 * Our default java compile rule doesn't notice if a .java file was
   removed.  Maybe we want to force full recompilation if the list of
   files changed, or maybe we want to delete class files that appear
   to have come from non-existent java files.  I'm not sure what
   happens with nested/inner classes that disappeared....does javac
   automatically remove the corresponding class files?  This would be
   an easy experiment to try.

 * Ant seems to not complain when populating an ear file from a
   classpath that contains non-existent items.  In general, there may
   be an issue with not getting any notification of non-existent
   classpath items.  Note that, sometimes, you want to try to create
   an ear even of some of its contents aren't there, so this may not
   really be a problem worth fixing.  If we can fix it, we should be
   able to control on a per-build-item basis whether it is an error
   condition or just a warning, probably having "error" be the
   default.


Known Bugs
==========

 * Piping ANSI color stuff through ant on Windows doesn't work.  When
   running qtest from ant on Windows, qtest correctly generates the
   ansi color codes, but they don't get displayed right through ant,
   at least in cygwin.


Issues, Enhancement Ideas
=========================

See also "Known Limitations" in the documentation.

 * Test qtest coverage from abuild test suite.  Relatively low
   priority since abuild's test suite itself uses coverage, so
   abuild's qtest coverage support is exercised every time the abuild
   test suite is run.  (It's just that you might not notice if it
   weren't there.)

 * Think about implementing a dependency analyzer that would look at
   first-level includes to figure out what the correct list of direct
   dependencies should be.

 * Consider having --silent invoke make with --no-print-directory.  If
   we do this, we should follow build item failure with a message that
   contains the name, path, and platform of whatever failed.

 * Consider having an abuild template generator that can run if no
   Abuild.conf or other files are present.  This would spit out
   commented template files.  Alternatively, could be a command-line
   wizard or something.

 * To check for all Abuild.mk files that define local targets:
   pcregrep '^\s*\S+\s*:(\Z|[^=])' **/Abuild.mk

 * Consider using re-entrant scanners instead of C++ scanners.  This
   requires flex >= 2.5.33.  Have abuild's own build process detect
   whether or not a new enough version of flex is available.  If so,
   it should generate the parsers and attempt to update a cached copy
   of the automatically generated files if they have changed.
   Otherwise, it should use the cached files by adding them to SRCS in
   place of the automatically generated ones.  We also need to disable
   warnings for the flex-generated code.  Use %option nounistd.  (This
   suggestion may be simplified if better support for files generated
   by optional tools is added.)

 * It would be nice if there were a mechanism for providing
   documentation on traits so that --list-traits could tell the user
   how each trait was intended to be used.

 * Consider capturing the output of the backend so that we can
   de-interleave output when running parallel builds (or mark each
   line of output with the build item/platform data), separate error
   from informational output, etc.  It is possible to create pipe-like
   handles with CreatePipe in Windows and to use them to initialize
   hStdInput, hStdOutput, and hStdError fields of the startupinfo
   parameter to CreateProcess.  There is an example at
   http://lists.trolltech.com/qt-interest/1999-09/thread00282-0.html
   There is also some kind of Win32 Job API used by the perl
   Win32::Job classes (CreateJobObject).  This may provide a better
   solution than our current CTRL-C handling.  See if boost provides
   anything that could do this.

 * Clean up ~/source/examples/java/native/abuild and use as JNI
   example

 * ccxx: Consider enforcing that no object file may appear both as a
   program and a library object file and that no object file may be
   generated from more than one source file (with different suffixes)

 * In the manual, it would be nice if we could use higher resolution
   figures for the PDF than for the HTML.  There is plenty of material
   in the sagehill.net DocBook XSL guide about this.  The best
   solution would be to convert the figures to SVG.  It may work to
   use graphviz to generate the SVG.

 * Orphan target detection in make won't find orphan targets in
   subdirectories.  This is very hard to fix in general.  We could
   search directories represented in the source lists, but that
   wouldn't help if we removed the last file from a subdirectory.  For
   now, we'll just not handle this case.

 * Mingw support isn't that complete: see known limitations in the
   documentation and comments in private/list_platforms.  If it is
   improved, consider improving support for recognizing it so that the
   user doesn't have to set MINGW=1.  Search for mingw in the
   documentation and adjust as needed.

 * Consider adding a trouble shooting section to the documentation,
   web site, or wiki

    - example: library name inconsistency between Abuild.mk and
      Abuild.interface

 * Cass Dalton reports that he sometimes gets "resource busy" errors
   when running autoconf with --make-jobs.
