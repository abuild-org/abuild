
=== Changes Targeted for Version 1.1 ===

Notes for Next Release
======================


 _________________________________
/vv Changes made on Java Branch vv\
-----------------------------------



___________________________________
\^^ Changes made on Java Branch ^^/
 ---------------------------------



Remember to keep deprecated features list up-to-date.  Add the
following:

 * ...

These changes have already been made and need to make it into the
release notes.

 * Documentation for new features (other than groovy framework) is
   being placed in src/manual/pending.txt until it is integrated into
   the documentation.

 * In groovy backend, cache loading of rules for a significant
   performance boost

 * NON-COMPATIBLE CHANGES TO EXTERNALS:

    - -winpath is no longer a valid option to external-dirs.

    - absolute path externals are no longer supported.

    - external-dirs may no longer be symbolic links nor may they cross
      symbolic links.

    - the -ro flag for externals is ignored; use -ro-path or -rw-path
      instead

 * Compatibility level can be set with the ABUILD_COMPAT_LEVEL
   environment variable in addition to the command line argument.  The
   command line argument takes precedence.

 * Having a child-dirs entry be a symbolic link or cross a symbolic
   link now results in an explicit error message.  This has never
   really worked, but in the past, the result would most likely have
   been something about a parent/child mismatch.

 * Changed build set "all" to mean all known build items in all trees
   in the forest.

 * Added build set "deptrees" to mean all build trees in the tree-deps
   chain, including the current build tree.  This build set would
   build what "all" builds in 1.0.

 * Default build ordering has changed so that tree ordering is used
   before item ordering in the sort.  This means that if tree A
   declares tree B as a tree dependency (or uses it as an external)
   all of A's build items will build before any of B's build items (in
   a single-threaded build).  Build ordering is always determined by
   build item dependencies.

 * Replaced "this" with "name"

 * The value of parent-dir is completely ignored other than to check
   it enough to make sure that ignoring it doesn't change anything.

 * Require trees to be named.  Replace externals with subtrees.
   Eliminate absolute path and read-only externals, but provide an
   alternative to read-only externals for the desired functionality.

 * Move "deleted-items" key from root Abuild.conf to Abuild.backing.
   Also add a "deleted-trees" key.  New Abuild.backing format:

     backing-areas: /path/to/backing/area
     deleted-trees: trees not to shadow
     deleted-items: items not to shadow

 * Support multiple backing areas.  If there are multiple, independent
   backing areas, they must be disjoint (i.e., they must not both
   supply the same item or tree).

 * Implemented abuild --upgrade-trees.  You should not attempt to
   upgrade trees manually.  Although abuild will work fine with mixed
   1.0/1.1 trees, you will get a lot more warnings and possibly
   incorrect results in some cases (though no such cases are known) if
   you partially upgrade your trees.  There is A LOT to keep track of
   when upgrading your trees.  You are much better off letting abuild
   do it for you.

 * New interface variables ABUILD_ITEM_NAME and ABUILD_TREE_NAME

 * --ro-path, --rw-path

Groovy Framework
================

 * Java out of memory problem with ant is reportedly fixed with
   1.5.0_12.

 * Find sun conventions on directory structure for _base.groovy

 * Update rules/java/java_help.txt

 * Consider whether we should embed it junit.  If so, which version?
   Groovy embeds 3.8.2.  Current is 4.5.  Right now, you must have
   some version of junit in your classpath for the junit tasks in the
   java rules (or ant code) to work.  This seems okay to me since it
   avoids the need to worry about abuild's integrated junit taking
   precedence over a user-provided version.

 * There is no way to specify separate includes and excludes for the
   various filesets inside of jar, war, or ear.  I can think of three
   possible solutions:

    - Don't bother supporting this.  People can always put their own
      closures in abuild.packageJar if they want this.  Besides, we
      have enough different directories that we use that there are
      plenty of other approaches.

    - Allow the map entries passed to java.packageJar (etc.) to be
      either directories or maps.  If an entry is a map, it is treated
      as arguments to fileset.

    - Have a parameter that maps directories to includes and excludes.
      This is a little more obscure than the previous option, but it
      enables customization of the contents of standard directories
      without having to resort to using java.packageJar and copying
      names of standard directories around.

   Which way we goes probably depends on how much this functionality
   is needed.  I personally feel that doing selective includes and
   excludes for creating jars makes things unnecessarily obtuse, but
   I've seen lots of examples of people doing things like creating
   test jars that include all files and non-test jars that exclude
   Test*.class.

 * No specific mechanism (like plugin.groovy) is provided for
   pre-initialization of parameters to be used by build item-supplied
   rules.  This facility does not exist on the make side either, and
   it has never been missed.  If code generators really need this
   facility, they can set interface variables.  Note that parameters {
   interface.variable << 'new-val' } does actually work as of 1.1.a3.

 * Consider providing a way to "decorate" targets by adding closures
   to be run before and after.  A pre-target closure would be run
   after all dependencies were satisfied and before any of the
   target's closures.  A post-target closure would be run after.
   Alternatively, perhaps we should provide a mechanism for prepending
   rather than appending a target closure, which might ave the same
   effect.  This may no longer be necessary with the way
   abuild.runActions works.


Compiler Verification
====================

 * Update compiler verification to work with compat level 1.1.  Test
   compiler verification for verification of a compiler that requires
   a plugin in another tree.



Core Changes
============

 * When abuild is run with no arguments, its default behavior will be
   to act as if --with-deps had been specified.  A new flag
   "--no-deps" can be used for the case in which one should build just
   the item with no dependencies.

 * Add flag --with-rdeps to add to the build set all items anywhere in
   the forest that have items in the initial build set in their
   expanded dependency chains.  (Note that is recursive by nature: if
   A depends on X and B depends on A, then B also depends on X.)

 * Add -ro-path and -rw-path options to tell abuild to treat some or
   all build items as read only based on path.  This should provide a
   more robust approach than using read-only externals for preventing
   cross-tree builds when they are not desired.  Consider these trees:

         A
       / | \
      B  C  D

   If B and D both have C as a tree dependency and are independent
   from each other, you might want to build C first and then have both
   B and D built in parallel while treating C as read only.  This
   would provide a way to do that.

   Both -ro-path and -rw-path may appear multiple times.  If only
   -ro-path appears, build items are writable by default.  If only
   -rw-path appears, build items are read-only by default.  If both
   appear, then either every -ro-path must be a path under some
   -rw-path (in which case build items are read-only by default) or
   every -rw-path must be path under some -ro-path (in which case
   build items are writable by default).  These rules make it possible
   to unambiguously create any combination of read-only/writable build
   items without having the order of the arguments matter.

   Paths may be absolute or relative.  Relative paths are resolved
   relative to the starting directory of abuild (after any -C is
   evaluated).

   When determining whether a build item is read only, the
   determination is made based on the lowest directory in the path to
   the item for which a read/write status is specified.  If none is
   found, the default is used.

 * Implement two forms of conditional dependencies:

    - deps: item -optional
    - tree-deps: tree-name -optional

   In the first case, abuild will not complain if a given dependency
   is not found.  Some mechanism will be provided that will enable a
   build item to test in its Abuild.interface file (and therefore in
   its Abuild.mk or Abuild-ant.properties file) whether an optional
   dependency is satisfied.  In the second case, abuild will not
   complain if a given tree is not found.

   A new boolean interface variable (analogous to abDIR_build-item)
   will be defined for each build item that exists or that is declared
   as an optional dependency.  This variable will be true iff the
   build item exists.

 * Create a "replaces" keyword that would be used to indicate that a
   build item is a replacement for one or more other build items.  Any
   values for the replaces key would not be allowed to exist on their
   own.  Any references to them in Abuild.conf files would be treated
   as references to the new build items.  This is stronger than using
   deps to make the old name depend on the new name and also
   eliminates the need to create build items whose only purpose is to
   depend on their replacements.

 * It would be good if errors in a part of the collection of build
   trees that are not relevant to you don't impact your build.  For
   example, if a forest contains A, B, and C and your build contains
   no items from C, then integrity errors in C should be ignored
   unless --full-integrity is specified.  (Do we already to this?)

 * Make cross-platform dependencies obey platform selectors.  The
   rationale for not doing this was that the command-line and
   environment should not affect the shape of the build graph, but
   this is a myth anyway.  People can always run with DFLAGS=-g or
   NO_XLC=1.  If a specific compiler or option is required, it can be
   specified explicitly with the platform-specifier in the
   dependency.  This implies additional requirements:

    - Make sure "-platform native:option=" works to specify no option

    - Make sure it is possible to express "I want the version of X
      built with compiler A on platform P but the default compiler
      everywhere else."  This can probably be done with a combination
      of platform-specific dependencies and platform conditionals.

 * Drop internal "clean" targets and update documentation.

Documentation
=============

 * Incorporate manual/groovy-framework.txt and manual/pending.txt.

 * Read through all 1.1 release notes and update the body of the
   documentation accordingly.  Save this until all the new features
   are implemented, if possible.

 * Note: references to ant examples are still in the documentation.
   There are comments like <!-- ?example ....? --> marking where the
   file references used to be.  Files can be found in the abuild-ant
   test suite.  Paths that used to start with java now start with
   basic.

 * Describe groovy framework (obviously).  Specific things to remember:

    - For groovy backends, defining a new test procedure requires only
      defining a closure for the 'test-only' target.  Abuild
      automatically calls this from test or check.

    - document fields and interface of BuildState ("abuild").  Also
      describe parameter handling.  setParameter vs. getVariable, which
      looks at defines, parameters, interface, and default in that order

    - QTest.export prop for groovy backend; also automatic export of
      TESTS

    - abuild.local-rules, abuild.rules

 * Describe somewhere why we don't provide information about platforms
   in the interface files for java and indep.  Basically, it would be
   a bug to have an interface variable have a different value in
   different contexts when it might influence a build that could be
   used on multiple platforms.  For example, an indep build item could
   write out some value based on a platform variable and then that
   information could be wrong when the results of the build were used
   on a different platform.  If you really need to know what platform
   you are on for something indep or java, you can always get the
   information using a cross-platform dependency, which at least makes
   it visible.  But remember that text files containing
   platform-dependent values (like pathnames, etc.) are in fact
   platform-dependent.


Usability Improvements
======================

 * Provide arguments for querying abuild's state, such as locating
   build items (perhaps with pattern matching), listing all trees with
   locations and dependencies, summarizing the state of all plugin
   information (which items are plugins in any tree, which tree
   provides the plugin, and which trees use the plugin), etc.  The
   --dump-data option will always be available for providing full
   information, but providing a more human-readable format for
   commonly needed information will help.

 * Consider adding a new special-case target "help" that would provide
   help in a manner that does not require invoking a back end.  This
   should remove the serious problems with rules-help and
   interface-help, and should get around the problem of trying to echo
   help information from a build file.  This would work by having
   abuild automatically display certain internal help files and build
   item-provided help files.  Most likely, abuild would just display
   all the help files provided by other build items that impact your
   build (dependents, plugins, rule/hook build items, etc.) as well as
   internal help files.  Help files, including internal ones, should
   provide a list of variables that can be set or read, what they
   mean, and how to use them.

 * Make sure abuild --help references the build/clean set list from
   the --build and --clean argument description, and make sure there
   is a reference to the platform selector information from the
   --platform-selector argument description.  Also divide the output
   clearly into OPTIONS and TARGETS.

 * Incorporate as much of abuild-lint as possible or otherwise include
   abuild-lint in the distribution.

 * Provide a way to get --dump-data's into a relational database.
   Ideally, we shouldn't have to link with sqlite.  Maybe have an
   option that causes --dump-data to generate a script file that can
   be used with sqlite3 rather than generating XML data.
   Alternatively, we can create xsl/perl code that loads directly into
   a sqlite database or that creates the input file.  It's probably
   okay if we create the SQL such that an erroneous dumpdata won't
   load.  For example, the SQL can enforce uniqueness and referential
   integrity constraints even though they may not be satisfied when
   there are errors.


Plugins
=======

 * Support buildable plugins with platform type "indep".  See
   "Buildable Plugins" below.


Abuild Contrib
==============

 * Upgrade all contributed build items to use abuild 1.1 files.

 * Make sure any compiler plugins included with abuild contrib have
   the 1.0.2 fixes integrated into them.

 * Include a generic UNIX compiler buildable plugin

 * Consider including a libtool buildable plugin


Platform Issues
===============

 * Allow platforms, but not platform types, to flow "backward" across
   tree dependencies.  Specifically, consider the following:

   A: platform type T1, available platforms p1, p2
   B: platform type T1, available platforms p1
   A -> B

   Allow B to build on platform p2 even if that platform is defined in
   a tree that B doesn't declare as a dependency.  Even allow this if
   the platform that defines p2 is defined in a tree that depends on
   B's tree.

 * Pass information about the native os, cpu, and toolset to
   list_platforms.  See comment in Abuild::loadPlatformData before
   invocation of list_platforms.

 * If possible, remove the temporary ABUILD_FORCE_32BIT hack or make
   it permanent.  Search for FORCE32 in the code.  The only references
   are in private/bin/get_native_platform_data and
   make/toolchains/gcc.mk.  For a description, see release notes in
   the documentation.

 * Implement platform conditionals, described below.


Changes to "make" Code
======================

 * Need a better solution for files that are automatically generated
   by optional tools.  Abuild itself could use this for flex/bison
   files.  We could also use it for cases like xbinder where
   generating the files requires a special license.  We need a clean
   way to handle the following:

    - Regeneration of the files if they are out of date and the tools
      are available.

    - Use of cached files if they are not out of date.

    - Error if the files are out of date and the tools are not
      available.

   This implies, at least for these cases, some kind of checksum-based
   method (rather than using modification times) to tell whether files
   are out of date.  That way, checkouts from the version control
   system can work even when the CM system does not preserve
   modification times.

 * According to Microsoft, we should always be using /Zi.  We need to
   revisit all the arguments passed to msvc to see what they really
   mean and to figure out which to use in release and debug modes.

 * To build for .NET, we need to pass /clr rather than /EHsc to msvc.
   /EHsc is hard-coded into $(CC) right now.  We need to fix msvc.mk
   to make it easier to override these flags.  When going back through
   all flags to see what they do, create variables that can be
   overridden based on function.


Platform Conditionals
=====================

(This item is low priority for 1.1.)

The goal is to support some kind of platform-based conditional
dependency while preserving the fundamental design goal of having a
static build graph.  We will support this only for build items of type
native.  Here's how it would work:

 * Native build items can specify some kind of platform-based
   inclusion/exclusion rules in Abuild.conf.  Maybe we'll add keywords
   build-if-platform-matches and build-unless-platform-matches, each
   of which takes arguments of the form a.b.c.d.  Each field can be a
   fixed string or * and is matched against the corresponding field of
   the platform identifier.  If both keywords appear, platform strings
   have to satisfy both.  For example,

   build-if-platform-matches: linux.*.*.gcc *.*.*.xlc
   build-unless-platform-matches: windows.*.*.*

   would mean to build on linux with gcc and everywhere except windows
   on xlc.

 * Abuild will first construct and validate the build graph
   disregarding platform restrictions.  This ensures that the build
   graph can't be invalid for some combination of available platforms
   and not for others.

 * Once the build graph is validated, abuild will traverse the build
   graph again and prune the graph at each node whose platform doesn't
   satisfy the platform restrictions.

There are several possible implications to think through.  What
happens with build items that get built "as needed" to satisfy
platform constraints but then are no longer needed after pruning?  It
may be that we have to create two build graphs, one that disregards
platform restrictions and one that doesn't.  The second build graph
should always be a proper subset of the first one, so there should be
no possibility of errors existing in the second one.

But actually, it's worse than that.  What about items that get added
to the build set just to satisfy dependencies that are no longer
required?  Do we want those?  It's like we have to mark build items as
explicit or implicit and then prune any unreferenced implicit items
after paying attention to platform restrictions.

Consider native build items:

a: b c
b: d

b is 'windows only'

When doing abuild -d from a on a non-windows platform, we only want to
build a and c, but when doing abuild -b all on a non-windows platform,
we want a, c, and d.  In the first case, d is an implicit member of
the build set, and in the second case, d is an explicit member.  For
the build graph, we can mark things as explicit if they are explicit
items on selected platforms.  Explicit items on as-needed platforms
are implicit.  To detect unreferenced implicit members, we could
traverse the pruned build graph starting from each explicit node and
mark things as seen when we encounter them.  Then, anything that's not
seen can be removed.  We'll need to test cases with platform-specific
dependencies to make sure the logic is sound.  Also consider whether
the special failure build item used to implement recovery from certain
types of cycle errors should be explicit.


Buildable Plugins
=================

There are a number of potential uses for plugins that can't presently
be realized because plugins have to be completely static.  For
example, it would be useful to be able to create a generic UNIX
compiler plugin that must be configured using autoconf by the user
before starting to build or that would use autoconf or libtool to
figure out certain flags, such as the proper flags to create shared
libraries.  Buildable plugins could also be used to force certain
steps to be performed early in a build, such as checking for proper
environment variable settings or making architectural checks on
dependency rules that go beyond what can be enforced through abuild's
internal mechanisms.

Making plugins buildable implies that abuild has to build plugins
before anyone might use them.  Since plugins are loaded in declaration
order in each tree, this results in declaration order implying some
kind of dependency-like relationship.  To determine build order, make
a dependency graph among buildable plugins where a dependency is
created from each plugin to its immediate predecessor in the build
order.  This is done for each tree.  If there are any cycles (caused
by buildable plugins being loaded in different orders across different
trees), it is an error.  If not, the first phase of the build is to
build plugins.

Since plugins are loaded in declaration order in each tree, this
approach guarantees that buildable plugins are built before other
plugins that may reference them.  One could argue that such logic
should be applied to all plugins since it is possible for plugins
to interact, but I would argue that this would create unnecessary
constraints.  If one plugin really requires another plugin, one
should first rethink whether the plugins are being used sensibly,
and if they really are, then the plugin should just check for the
existence of a variable/property defined by the other plugin.  The
case of buildable plugins is a little different because a plugin
may not even work before it is built.

If we require buildable plugins to have platform type "indep", then
it's probably also okay for plugin.interface files to have after-build
files, something that is currently disallowed since plugins are
instantiated for each possible platform.

In order to make it possible for the outcome of a plugin's build step
to influence what platforms it provides, it will be necessary for
abuild to build a plugin before executing its list_platforms file.

Consider carefully how explicit targets should apply to plugins.  As
currently coded, --apply-targets-to-deps will result in explicit
targets being applied to plugins.

Think about how buildable plugins interact with read only paths and
backing areas.


Building Abuild
===============

 * Consider creating a ./configure that finds boost libraries and
   deals properly with pthread.  Then consider packaging auto-srcs
   with abuild sources.  Check on debian to see if this works with the
   latest flex.  Consider making the re-entrant scanner switch, made
   possible by controlling the flex and bison files provided that
   there is an autoconf check for the right versions of flex and
   bison.  See ~/source/work-software/argon/third-party-support/boost
   for sample boost autoconf code.

   It might be possible to make this work properly when abuild is
   building itself by having a buildable plugin that checks to make
   sure configure has been run.  Bootstrapping makefile can fail if
   configure hasn't been run.

----------------------------------------------------------------------

=== Things with no Specific Release Target ===

Windows Issues
==============

 * There are some Windows path issues.  You can't use absolute paths
   in Windows as long as cygwin is in use because cygwin gnu make will
   not interpret absolute paths in the same way that Windows will for
   purposes of dependencies in .dep files, library dependencies, etc.
   Relative paths should work, but they don't always work because
   Windows seems to have limits on the number of times .. may appear
   in a path (among possibly other things), and besides, there is no
   way to construct a relative path to a file under another drive
   letter.  Ideally, we should be using something like msys and/or
   gnuwin32 rather than cygwin, along with supporting ActivePerl, but
   this has major implications since qtest doesn't currently work
   without cygwin, not to mention the fact that the test suite makes
   free use of unix constructs.

 * gen_deps: rewrite in C++ so that it doesn't force a runtime
   dependency on perl.  It should be a fallback for cases when
   compilers can't generate dependency information.  With gcc, use -MD
   -MF -MP to generate proper .dep files.  xlc: "-M -MF a.dep" works,
   but there is no equivalent to -MP, so we'll need to postprocess.
   VC: there seems to be a /showIncludes option that we may be able to
   exploit.  Not sure what versions of VC++ have this.  This will be
   worth doing if we can remove a runtime dependency on Cygwin for
   Windows/C++.  For non-Windows systems, requiring perl is not a big
   deal.


Compiler/Platform Configuration
===============================

There is a general problem with compiler options, 32-bit and 64-bit
compilers, project-specific configuration, supporting compilers that
aren't known in advance, etc.  This is kind of what toolset was
designed to handle.  The following items are possibly contradictory or
interdependent and need to be sorted out better.  These items all
imply certain things that may need to be done very early in abuild's
life even before private/bin/get_native_platform_data is called.

 * Need a more flexible way of handling compiler options.  It should
   be possible to create plugins that add compiler options to
   internally supported compilers, and options should be able to be
   meaningfully selected in groups.  For example, it should be
   possible to add {m32, m64} that can't be specified together and
   {debug, release} that can't be specified together while allowing
   debug+m32 or release+m64 or other permutations.  This implies the
   need for a canonical form.

 * We need some way for people to change the toolset portion of the
   platform string in a global way for a particular collection of
   build trees.

 * There needs to be better cross-compiler support for things like
   building 32-bit code on a 64-bit system.  Adding -m32 doesn't
   really do it because why should have you
   linux.x86_64.rhel51.gcc.m32 be the same as linux.ix86.rhel51.gcc?


Java Problems
=============

 * Reconsider using depends task for compile in abuild.xml.

 * Our default java compile rule doesn't notice if a .java file was
   removed.  Maybe we want to force full recompilation if the list of
   files changed, or maybe we want to delete class files that appear
   to have come from non-existent java files.  I'm not sure what
   happens with nested/inner classes that disappeared....does javac
   automatically remove the corresponding class files?  This would be
   an easy experiment to try.

 * Ant seems to not complain when populating an ear file from a
   classpath that contains non-existent items.  In general, there may
   be an issue with not getting any notification of non-existent
   classpath items.  Note that, sometimes, you want to try to create
   an ear even of some of its contents aren't there, so this may not
   really be a problem worth fixing.  If we can fix it, we should be
   able to control on a per-build-item basis whether it is an error
   condition or just a warning, probably having "error" be the
   default.


Known Bugs
==========

 * Piping ANSI color stuff through ant on Windows doesn't work.  When
   running qtest from ant on Windows, qtest correctly generates the
   ansi color codes, but they don't get displayed right through ant,
   at least in cygwin.


Issues, Enhancement Ideas
=========================

See also "Known Limitations" in the documentation.

 * Test qtest coverage from abuild test suite.  Relatively low
   priority since abuild's test suite itself uses coverage, so
   abuild's qtest coverage support is exercised every time the abuild
   test suite is run.  (It's just that you might not notice if it
   weren't there.)

 * Think about implementing a dependency analyzer that would look at
   first-level includes to figure out what the correct list of direct
   dependencies should be.

 * Consider having --silent invoke make with --no-print-directory.  If
   we do this, we should follow build item failure with a message that
   contains the name, path, and platform of whatever failed.

 * Consider having an abuild template generator that can run if no
   Abuild.conf or other files are present.  This would spit out
   commented template files.  Alternatively, could be a command-line
   wizard or something.

 * To check for all Abuild.mk files that define local targets:
   pcregrep '^\s*\S+\s*:(\Z|[^=])' **/Abuild.mk

 * Consider using re-entrant scanners instead of C++ scanners.  This
   requires flex >= 2.5.33.  Have abuild's own build process detect
   whether or not a new enough version of flex is available.  If so,
   it should generate the parsers and attempt to update a cached copy
   of the automatically generated files if they have changed.
   Otherwise, it should use the cached files by adding them to SRCS in
   place of the automatically generated ones.  We also need to disable
   warnings for the flex-generated code.  Use %option nounistd.  (This
   suggestion may be simplified if better support for files generated
   by optional tools is added.)

 * It would be nice if there were a mechanism for providing
   documentation on traits so that --list-traits could tell the user
   how each trait was intended to be used.

 * Consider capturing the output of the backend so that we can
   de-interleave output when running parallel builds (or mark each
   line of output with the build item/platform data), separate error
   from informational output, etc.  It is possible to create pipe-like
   handles with CreatePipe in Windows and to use them to initialize
   hStdInput, hStdOutput, and hStdError fields of the startupinfo
   parameter to CreateProcess.  There is an example at
   http://lists.trolltech.com/qt-interest/1999-09/thread00282-0.html
   There is also some kind of Win32 Job API used by the perl
   Win32::Job classes (CreateJobObject).  This may provide a better
   solution than our current CTRL-C handling.  See if boost provides
   anything that could do this.

 * Clean up ~/source/examples/java/native/abuild and use as JNI
   example

 * ccxx: Consider enforcing that no object file may appear both as a
   program and a library object file and that no object file may be
   generated from more than one source file (with different suffixes)

 * In the manual, it would be nice if we could use higher resolution
   figures for the PDF than for the HTML.  There is plenty of material
   in the sagehill.net DocBook XSL guide about this.  The best
   solution would be to convert the figures to SVG.  It may work to
   use graphviz to generate the SVG.

 * Orphan target detection in make won't find orphan targets in
   subdirectories.  This is very hard to fix in general.  We could
   search directories represented in the source lists, but that
   wouldn't help if we removed the last file from a subdirectory.  For
   now, we'll just not handle this case.

 * Mingw support isn't that complete: see known limitations in the
   documentation and comments in private/list_platforms.  If it is
   improved, consider improving support for recognizing it so that the
   user doesn't have to set MINGW=1.  Search for mingw in the
   documentation and adjust as needed.

 * Consider adding a trouble shooting section to the documentation,
   web site, or wiki

    - example: library name inconsistency between Abuild.mk and
      Abuild.interface

 * Cass Dalton reports that he sometimes gets "resource busy" errors
   when running autoconf with --make-jobs.

 * It might be useful to have abuild recognize certain error
   conditions currently reported as global as instead being specific
   to a given build item, but this would be a high-risk change that
   has some of its own disadvantages.

   The idea would be to detect errors currently reported as global
   and, instead of having them prevent any builds from happening, have
   them just block builds of the specific items they pertain to.  This
   would make it possible, for example, to have a --build=desc work
   properly if there are dependency errors, cycles, or other similar
   types of errors on build items that are not related to the portion
   of the tree being built.

   Exmaple error conditions that could be handled in this way include
   depending on an unknown item, participating in a dependency cycle,
   referencing an unknown item in a trait, referencing an unknown flag
   for another item, having an invalid platform-specific dependency,
   etc.  An implementation strategy for doing this would be to have a
   buildError method that takes an item name and platform string, with
   an empty platform string indicating an error that would apply to
   all platform instantiations for the item.  Abuild would report the
   error but not increment the global error count, thus preventing
   exitIfErrors from exiting.  It would also store fact that an error
   was associated with the specific build item and/or build
   item/platform pair.  During the build of the item, if any
   non-platform-specific errors or if an error for the specific
   item/platform had been issued, the build for that item would be
   skipped.

   The above change, as described, would be straightforward to
   implement, but there are two siginificant issues:

    - This change would allow certain error conditions that really do
      have to get fixed from being purposely ignored or even
      accidentally overlooked for a longer period of time.  This goes
      against the idea of abuild trying to force early detection and
      correction of errors.

    - The code as currently implemented performs numerous validations.
      Once call to exitIfErrors has been made, subsequent code assumes
      all previous validations have succeeded.  For any current error
      condition that would be changed to a buildError, the rest of the
      code would have to be carefully inspected to ensure that prior
      assumptions have not become invalid.  This would be a shame
      since the early validation of certain error conditions helps to
      reduce the complexity of the abuild code.

   Consider the implications, especially of the second point.  Build
   graph construction code assumes that all platform information and
   dependency information stored in a build item is valid, and that
   information is accessed in a read-only fashion from the build
   item's config data.  This means that we either have to add checks
   throughout the code to make sure any dependency we retrieve is
   valid or else we need to remove a dependency from the list of
   dependencies.  The former would complicate the code and make it
   more fragile, not to mention the fact that the test suite doesn't
   cover any such cases now since they are prevented from happening.
   The latter would also have disadvantages.  For example, it would no
   longer be possible to use --dump-data to locate build items that
   depend on a particular unknown build item or otherwise to help
   clean up errors of this type.
