
=== Changes Targeted for Version 1.0.3 ===

These are changes originally targeted for 1.1 and that don't add any
backward compatibility issues to any configuration files or
command-line arguments.  New syntax may be added as long as old syntax
continues to work.

Bug Fixes
=========

 * Version 1.0.3 will ignore the value of LINK_SHLIBS and pass the
   list of libraries to the shared library creation command by
   default.  This is because the decision about whether or not to link
   shared libraries is really more a function of the underlying system
   than something the developer should control.  Some systems require
   shared libraries to be linked while others don't support it at all.

   Version 1.0.3 will link shared libraries unconditionally and
   silently ignore LINK_SHLIBS with a value of 1.  Any other value of
   LINK_SHLIBS will cause an error that will tell the user to use
   "override LIBS :=" if they really want to suppress linking of
   shared libraries.  Version 1.1 will give a deprecation warning for
   LINK_SHLIBS.

 * Add failonerror="true" to the exec that invokes qtest from ant so
   that the build fails if the test suite fails.  Add failing qtest
   with ant and make to test suite.

Core
====

 * Support the explicit concept of internal targets, which are targets
   handled by abuild that don't involve invocation of the backend.
   This is just a command-line argument parsing change.  See "internal
   targets" below.

 * Provide a mechanism to tell clean to only clean certain platforms
   or to not clean certain platforms.

 * Sometimes we use dependencies just to force something to build, as
   in the case of the "compile-all" item in searchlight or some
   "top-level" builds.  For cases in which all we want to do is
   effectively define static build sets, we need something more like a
   "build-also" keyword that specifies build items that should be
   built if this one is built.  It effectively just adds them to the
   build set.  The build-also keyword doesn't have any restrictions
   about cycles -- it is just used during initial build set
   construction.  This avoids the need to use platform-specific
   dependencies in this case.

 * Specifying -p platform-type:skip shouldn't remove platforms from
   that platform type but should instead just take them out of the
   default build list.  That way, when doing -p native:skip, if a java
   or indep build item depends on a native build item, abuild can
   still build the native item "as needed" just as it would for other
   platform-specific dependencies.

 * Support -p java:skip and -p indep:skip with the same semantic as -p
   native:skip (prevent from building by default, but still build to
   satisfy dependencies).

 * (Maybe) Add -ro-path and -rw-path options to tell abuild to treat
   some or all build items as read only based on path.  This should
   provide a more robust approach than using read-only externals for
   preventing cross-tree builds when they are not desired.  Details
   still to be fully worked out, but the basic idea is that if you run
   "abuild --build=desc -rw-path .", abuild will treat all build items
   outside the current tree as read-only.  If you run "abuild
   --build=desc -ro-path ../tps-build-items", then abuild will treat
   everything as read/write except anything under ../tps-build-items,
   which will be read only.  I'll come up with sensible semantics for
   mixing -ro-path and -rw-path and for having multiple occurrences of
   them.

 * If abuild is run with -k (and definitely not otherwise), it should
   continue running if there are dependency graph errors that don't
   impact anything in the build set.  For example:

   a: b
   b: c d
   d
   e: f
   f: e

   abuild -d from "a" should be able to run to completion even though
   there is a cycle in "e" and "f".  Need to think about how this can
   actually be implemented.  One idea would be to break the cycle at
   an arbitrary point (presumably the point at which it was detected)
   and replace the cyclic dependency with a dependency on a fake build
   item that has an initial state of failed.  The failure of this
   build item should be handled in a manner that causes propagation of
   the failure through the build graph just as any other failure
   would.  One way to do this would be to have this build item "get
   built" but fail.  This would require a very small modification to
   Abuild::itemBuilder.  One indication of this working properly is if
   it does the right thing with --no-dep-failures.  Another would be
   if there is proper pruning in the platform-specific dependency
   case.  (We might need to mark the failed build item as explicit.)
   For example, if in the above, you add

   d: e

   and you run with -k only, only c would build, but if you ran with
   --no-dep-failures, then all the build items would build as if there
   were no dependency from f to e.

 * When a build failure causes propagation of failure status to other
   build items, this fact should be reported...something like

   build item X failed
   build item Y will not be built because it depends on X
   build item Z will not be built because it depends on X


Documentation
=============

 * Write subsection of "Cross-Platform Dependencies" entitled
   "Interface Errors" to discuss the duplicate assignment of an
   interface variable across multiple platform instances of a build
   item's interface.  Put a comment above the title of the subsection
   that the title is included in an error message in Interface.cc.
   (Search for Interface.cc in manual.xml to see another such
   comment.) Cover the following:

   This happens under the following very specific circumstances:

    - A depends (directly or indirectly) on two different build items,
      each of which declares a dependency on B

    - At least one of the dependencies on B is platform-specific

    - The two build items depend on B with different platforms

    - B's Abuild.interface makes a "normal" assignment to a non-list
      interface variable with a value that differs on the two
      platforms

   There are several possible remedies.

    - If you want both values and doing this won't hurt other build
      items, use a list variable instead of a non-list variable.  In
      this case, abuild will give you both (all) values.

    - If you don't care which value you get, and doing so doesn't
      cause other problems for other build items, use a fallback or
      override assignment instead of a regular assignment.  Then
      you'll get the first (in the case of fallback) or last (in the
      case of override) assignment that is processed.

    - If you can't change B's interface and A doesn't care about the
      value of the value, you can do a reset on the offending variable
      from the one or more of the items that A depends on and that
      depend on different instances of B.

    - You can rethink why you are trying to depend simultaneously on
      multiple platforms of the same build item and come up with a
      different strategy.  If you are just trying to force multiple
      platforms to build, you can probably replace your dependencies
      with a build-also keyword.

 * Clarify compatibility policy to be explicit that new syntax (file
   and command-line) may be added within a minor version.  In other
   words, we guarantee that anything that worked with 1.x.y will work
   the same way with 1.x.y+1, but we don't preclude adding some new
   functionality in 1.x.y+1 that isn't supported in 1.x.y.  This
   enables releases within a minor version to help with easing in new
   features without breaking compatibility.

Debugging
=========

 * Provide a means to dump a build item's interface in a format that
   shows all internally known information so that it is possible to
   discover the origin of everything known in the interface.  To make
   this as useful as possible, we should also store a reset history.
   Example uses: I see some interface variable in a build item's
   Abuild.interface file and want to know who uses it, I see some
   variable in someone's Abuild-ant.properties or Abuild.mk and want
   to know who defines it, or I see some variable in an .ab-dyanmic*
   file and I want to know who put xyz into its value.  Most likely,
   we get this information by having abuild dump the interface state
   before and after the build to files in the output directory when a
   given flag is present on the command line.  Abuild should probably
   indicate with a message to stdout that it is creating the file.
   Need to figure out what to do about interface only items.  Perhaps
   we provide a way for that information to be output to stdout
   somehow.  Also, make sure we include instance name information in
   the output.

 * Provide an option to be used with --dump-data that delays
   generation of dump data output to include the build graph and the
   build architecture list.

Usability
=========

 * Add "down" and "descending" as synonyms for build set "desc"

 * When abuild exits abnormally, it should say so right before it
   actually exits.  This way, if abuild -jn fails because one of the
   jobs failed, the last line of output will indicate the failure.
   Otherwise, the failed build item may be buried somewhere.

Non-user-visible
================

 * Document places where code relies on certain characters being
   illegal in build item names.  Known examples: format of build
   item/platform pairs for build graph construction, and use of comma
   as a separator in lists of build items in ant code.

Internal Targets
================

Internal targets are invoked with

abuild --internal-target target-name

or

abuild -i target-name

They are mutually exclusive with explicitly stated targets, and only
one can be specified in a given invocation.  Internal targets do not
cause invocation of the backend or processing of interface files.  The
following internal targets will be supported:

 * clean: equivalent to special-case "clean" target

 * no-op: equivalent to special-case "no-op" target

 * print-build-platforms: prints the name of each platform on which
   the build item is to be built

 * print-build-directory-names: prints the last path element of the
   name of each output directory that would be built

 * print-build-directory-paths: prints the full path of each output
   directory that would be built

Java Stuff
==========

 * Time permitting, consider implementing the ant launcher, groovy
   support, and distribution of junit, ant, and groovy.


=== Changes Targeted for Version 1.1 ===

Name Changes
============

 * Need two new build sets: one for all tree dependencies without the
   current tree and one for the current tree and all its tree
   dependencies.  The second of these is what "all" does in 1.0.
   "all" in 1.1 would continue to be defined as all items in all known
   trees, but it would be wider than in 1.0 because abuild will know
   about more trees.


Core Changes
============

 * Implement compatibility framework that allows specification of
   minimum compatibility level.  At the user level, this should be as
   simple as specifying minimum supported compatibility level from the
   command line or environment.  Internally, it should be possible to
   make some code conditional (at runtime) on the minimum
   compatibility level and issue deprecation warnings, and it should
   be easy to isolate backward compatibility code so that deprecated
   features can be removed.  See also "Compatibility" below.

 * Replace "this" with "name".  Make use of "this" deprecated.

 * Consider moving hook selection into Abuild.conf and removing
   BUILD_ITEM_RULES and abuild.hook-build-items.  This way, abuild can
   automatically create the dependency, accessing checking can be
   handled properly, the rename functionality can be implemented, we
   might be able to remove the ABUILD_DIR stuff, and we can use this
   information for the built-in help system.  We can probably also
   remove ACCESSIBLE_BUILD_ITEMS (or whatever it's called).

 * When abuild is run with no arguments, it will build build set
   "desc" instead of not doing a dependency-based build.  A new flag
   "--no-deps" can be used for the case in which one should build just
   the item with no dependencies.  (In explicit 1.0 compatibility
   mode, the old behavior is selected.)

 * Require trees to be named.  Replace externals with subtrees.
   Eliminate absolute path and read-only externals, but provide an
   alternative to read-only externals for the desired functionality.
   Simplify Backing Areas. See "Revamped Build Tree Structure" below
   for details.

 * Implement two forms of conditional dependencies:

    - deps: item -optional
    - tree-deps: tree-name -optional

   In the first case, abuild will not complain if a given dependency
   is not found.  Some mechanism will be provided that will enable a
   build item to test in its Abuild.interface file (and therefore in
   its Abuild.mk or Abuild-ant.properties file) whether an optional
   dependency is satisfied.

   In the second case, abuild will not complain if a given tree is not
   found.  Furthermore, any fully qualified regular item dependency of
   the form tree::item for optional tree "tree" will be treated as an
   optional dependency.

   A new boolean interface variable (analogous to abDIR_build-item)
   will be defined for each build item that exists or that is declared
   as an optional dependency.  This variable will be true iff the
   build item exists.

 * Consider a "renamed-to" or "replaced-by" keyword that would be used
   to indicate that a build item has been replaced by another build
   item.  It would be allowed only in root Abuild.conf files.  Its
   semantics would include that BUILD_ITEM_RULES and
   abuild.hook-build-items would follow the name change.  This is
   stronger than using deps to make the old name depend on the new
   name and also eliminates the need to create build items whose only
   purpose is to depend on their replacements.  Internally, abuild
   would make the new name an alias for the old name.  That way,
   things like abDIR_OLD-ITEM-NAME would contain the path to the new
   item.

 * Move "deleted-items" key from root Abuild.conf to Abuild.backing.
   Also add a "deleted-trees" key.  New Abuild.backing format:

     backing-area: /path/to/backing/area
     deleted-trees: trees not to shadow
     deleted-items: items not to shadow (fully qualified as tree-name::item)

   In 1.0 compatibility mode, continue to accept Abuild.backing files
   that are just paths with nothing else, but give a deprecation
   warning.

 * Make cross-platform dependencies obey platform selectors.  The
   rationale for not doing this was that the command-line and
   environment should not affect the shape of the build graph, but
   this is a myth anyway.  People can always run with DFLAGS=-g or
   NO_XLC=1.  If a specific compiler or option is required, it can be
   specified explicitly with the platform-specifier in the
   dependency.  This implies additional requirements:

    - Make sure "-platform native:option=" works to specify no option

    - Make sure it is possible to express "I want the version of X
      build with compiler A on platform P but the default compiler
      everywhere else."  This can probably be done with a combination
      of platform-specific dependencies and platform conditionals.


Documentation
=============

 * Describe somewhere why we don't provide information about platforms
   in the interface files for java and indep.  Basically, it would be
   a bug to have an interface variable have a different value in
   different contexts when it might influence a build that could be
   used on multiple platforms.  For example, an indep build item could
   write out some value based on a platform variable and then that
   information could be wrong when the results of the build were used
   on a different platform.  If you really need to know what platform
   you are on for something indep or java, you can always get the
   information using a cross-platform dependency, which at least makes
   it visible.  But remember that text files containing
   platform-dependent values (like pathnames, etc.) are in fact
   platform-dependent.


Usability Improvements
======================

 * Provide arguments for querying abuild's state, such as locating
   build items (perhaps with pattern matching), listing all trees with
   locations and dependencies, summarizing the state of all plugin
   information (which items are plugins in any tree, which tree
   provides the plugin, and which trees use the plugin), etc.  The
   --dump-data option will always be available for providing full
   information, but providing a more human-readable format for
   commonly needed information will help.

 * Abuild 1.0's build ordering is created by doing a stable
   topological sort on an alphabetical list of build items.  Instead
   of starting with a straight alphabetical list, have the starting
   list group build items by build tree.  To create the starting list,
   first topologically sort the alphabetical list of trees, and then
   alphabetically sort build items within each tree.  When this list
   is topologically sorted, it should result in build items from the
   same tree being built together (in a single-threaded build), and
   will generally result in items with higher visibility being built
   earlier in the process.

 * Consider adding a new special-case target "help" that would provide
   help in a manner that does not require invoking a back end.  This
   should remove the serious problems with rules-help and
   interface-help, and should get around the problem of trying to echo
   help information from a build file.  This would work by having
   abuild automatically display certain internal help files and build
   item-provided help files.  Most likely, abuild would just display
   all the help files provided by other build items that impact your
   build (dependents, plugins, rule/hook build items, etc.) as well as
   internal help files.  Help files, including internal ones, should
   provide a list of variables that can be set or read, what they
   mean, and how to use them.

 * Make sure abuild --help references the build/clean set list from
   the --build and --clean argument description, and make sure there
   is a reference to the platform selector information from the
   --platform-selector argument description.  Also divide the output
   clearly into OPTIONS and TARGETS.

 * Incorporate as much of abuild-lint as possible or otherwise include
   abuild-lint in the distribution.

 * Provide a way to get --dump-data's into a relational database.
   Ideally, we shouldn't have to link with sqlite.  Maybe have an
   option that causes --dump-data to generate a script file that can
   be used with sqlite3 rather than generating XML data.
   Alternatively, we can create xsl/perl code that loads directly into
   a sqlite database or that creates the input file.  It's probably
   okay if we create the SQL such that an erroneous dumpdata won't
   load.  For example, the SQL can enforce uniqueness and referential
   integrity constraints even though they may not be satisfied when
   there are errors.


Plugins
=======

 * It should be possible to declare a plugin as global.  Global
   plugins are loaded before non-global plugins.  Appropriate caveats
   should apply -- this is not appropriate for most kinds of plugins.
   The most likely use case would be for plugins that provide new
   platform information.  Another use case may be for plugins that
   check for compliance to internal policy.  Global plugins can also
   be used to support some form of project-wide configuration.

 * Support buildable plugins with platform type "indep".  See
   "Buildable Plugins" below.


Abuild Contrib
==============

 * Upgrade all contributed build items to use abuild 1.1 files.

 * Make sure any compiler plugins included with abuild contrib have
   the 1.0.2 fixes integrated into them.

 * Include a generic UNIX compiler buildable plugin

 * Consider including a libtool buildable plugin


Platform Issues
===============

 * Pass information about the native os, cpu, and toolset to
   list_platforms.  See comment in Abuild::loadPlatformData before
   invocation of list_platforms.

 * If possible, remove the temporary ABUILD_FORCE_32BIT hack or make
   it permanent.  Search for FORCE32 in the code.  The only references
   are in private/bin/get_native_platform_data and
   make/toolchains/gcc.mk.  For a description, see release notes in
   the documentation.

 * Implement platform conditionals, described below.


Changes to "make" Code
======================

 * Need a better solution for files that are automatically generated
   by optional tools.  Abuild itself could use this for flex/bison
   files.  We could also use it for cases like xbinder where
   generating the files requires a special license.  We need a clean
   way to handle the following:

    - Regeneration of the files if they are out of date and the tools
      are available.

    - Use of cached files if they are not out of date.

    - Error if the files are out of date and the tools are not
      available.

   This implies, at least for these cases, some kind of checksum-based
   method (rather than using modification times) to tell whether files
   are out of date.  That way, checkouts from the version control
   system can work even when the CM system does not preserve
   modification times.

 * Deprecate LINK_SHLIBS.  Either find some more robust way of dealing
   with shared libraries that does the right thing on more platforms
   (like figuring out a way of using libtool), or go with the 1.0.3
   solution but give a deprecation warning for any use of LINK_SHLIBS.

   Document in the shared libraries section that people who need to
   suppress linking of shared libraries for some reason on a system
   that supports this can always use "override LIBS :=".


Changes to "ant" Code
=====================

 * Strongly consider distributing junit, groovy, and if needed,
   ant-contrib in abuild's lib directory.  If we do the ant launcher,
   we might be able to get away from invoking ant at all, in which
   case we might want to embed ant as well.

 * Conventions on properties:

    - abuild.property can be set by a user in Abuild-ant.properties.
      These are documented in end user documentation.

    - abuild.protected.property can be safely accessed by hook authors
      or by local build files.  These are documented in hook author
      documentation.

    - abuild.private.property is intended for use within abuild's own
      ant framework and should not be accessed by users.  These
      properties are subject to change at any time.  These are not
      documented unless by comments in the code.

 * Incorporate misc/abuild-groovy.  Load the groovy task and make it
   available for others to use.  In abuild 1.0, there is no mechanism
   for adding a new build target that is visible to all build items
   (as one can do with plugin.mk in make-based builds).  The main
   reason for this is that adding new targets requires use of <import>
   from the top level (or else the new target will not be defined when
   ant tries to invoke it), and there is no way to run import inside a
   target or top-level task.  To get around this, use groovy to
   generate an xml file that imports all the hook files and then
   import that automatically generated xml file as in the
   misc/abuild-groovy example.  Consider folding the logic of
   checkForTarget into run-hooks.  Rethink whether we want to call
   this ant-hooks.xml or something else.  They are now imported, so
   they can contain more than just hooks, but best practices should
   still dictate their use primarily for hooks.  We'll have to remind
   people in the documentation that ant will do what ant does if you
   create the same target in multiple places (whoever gets loaded
   first wins, but everyone's version can be accessed as
   projectname.targetname).  Best practice should be to add a target
   that just calls hooks by the same name.  Everyone can call
   <run-hooks> from their own tasks.  Since hooks are implemented as
   private targets, the name clash problem doesn't happen.  If
   everyone defines their new targets by calling hooks, then if two
   people define new targets with the same names, it won't matter that
   much.  There's still the question of dependencies (in the ant
   sense), but this is no different from what would happen if we had a
   library of ant code that people imported on their own.

 * Remove/deprecate abuild.use-local-hooks and have this behavior
   enabled by default.  Any declared local build file should ben
   imported and searched for hooks.

 * With groovy support, make sure any place we iterate over
   comma-separated lists behaves properly with respect to whitespace.

 * We use the privately set "debug" and "deprecation" properties in
   abuild.xml to set debug and deprecation.  These should really be set
   using documented abuild properties, and we should figure out what
   other similar properties we might want to set in this way.

 * Strongly consider removing support for higher-level archives from
   abuild's ant framework.

 * Provide a way for a user to specify an externally created manifest
   file.  Users can do this cleanly with a <manifest> task in their
   own ant code, and we can hook it in using abuild's own jar creation
   task.

 * With the ability to add new targets, remove the "deploy" and
   "other" targets.  The other ones are probably okay (except
   interface-help, rules-help, and properties-help, which should be
   replaced by the new help system).


Platform Conditionals
=====================

(This item is low priority for 1.1.)

The goal is to support some kind of platform-based conditional
dependency while preserving the fundamental design goal of having a
static build graph.  We will support this only for build items of type
native.  Here's how it would work:

 * Native build items can specify some kind of platform-based
   inclusion/exclusion rules in Abuild.conf.  Maybe we'll add keywords
   build-if-platform-matches and build-unless-platform-matches, each
   of which takes arguments of the form a.b.c.d.  Each field can be a
   fixed string or * and is matched against the corresponding field of
   the platform identifier.  If both keywords appear, platform strings
   have to satisfy both.  For example,

   build-if-platform-matches: linux.*.*.gcc *.*.*.xlc
   build-unless-platform-matches: windows.*.*.*

   would mean to build on linux with gcc and everywhere except windows
   on xlc.

 * Abuild will first construct and validate the build graph
   disregarding platform restrictions.  This ensures that the build
   graph can't be invalid for some combination of available platforms
   and not for others.

 * Once the build graph is validated, abuild will traverse the build
   graph again and prune the graph at each node whose platform doesn't
   satisfy the platform restrictions.

There are several possible implications to think through.  What
happens with build items that get built "as needed" to satisfy
platform constraints but then are no longer needed after pruning?  It
may be that we have to create two build graphs, one that disregards
platform restrictions and one that doesn't.  The second build graph
should always be a proper subset of the first one, so there should be
no possibility of errors existing in the second one.

But actually, it's worse than that.  What about items that get added
to the build set just to satisfy dependencies that are no longer
required?  Do we want those?  It's like we have to mark build items as
explicit or implicit and then prune any unreferenced implicit items
after paying attention to platform restrictions.

Consider native build items:

a: b c
b: d

b is 'windows only'

When doing abuild -d from a on a non-windows platform, we only want to
build a and c, but when doing abuild -b all on a non-windows platform,
we want a, c, and d.  In the first case, d is an implicit member of
the build set, and in the second case, d is an explicit member.  For
the build graph, we can mark things as explicit if they are explicit
items on selected platforms.  Explicit items on as-needed platforms
are implicit.  To detect unreferenced implicit members, we could
traverse the pruned build graph starting from each explicit node and
mark things as seen when we encounter them.  Then, anything that's not
seen can be removed.  We'll need to test cases with platform-specific
dependencies to make sure the logic is sound.  Also consider whether
the special failure build item used to implement recovery from certain
types of cycle errors should be explicit.


Buildable Plugins
=================

There are a number of potential uses for plugins that can't presently
be realized because plugins have to be completely static.  For
example, it would be useful to be able to create a generic UNIX
compiler plugin that must be configured using autoconf by the user
before starting to build or that would use autoconf or libtool to
figure out certain flags, such as the proper flags to create shared
libraries.  Buildable plugins could also be used to force certain
steps to be performed early in a build, such as checking for proper
environment variable settings or making architectural checks on
dependency rules that go beyond what can be enforced through abuild's
internal mechanisms.  It may also be possible to use global, buildable
plugins to implement some kind of project-wide configuration
mechanism.

Making plugins buildable implies that abuild has to have build plugins
before anyone might use them.  Since plugins are loaded in declaration
order in each tree, this results in declaration order implying some
kind of dependency-like relationship.  To determine build order, make
a dependency graph among buildable plugins where a dependency is
created from each plugin to its immediate predecessor in the build
order.  This is done for global plugins and for each tree.  If there
are any cycles (caused by buildable plugins being loaded in different
orders across different trees), it is an error.  If not, the first
phase of the build is to build plugins.

Since plugins are loaded in declaration order in each tree, this
approach guarantees that buildable plugins are built before other
plugins that may reference them.  One could argue that such logic
should be applied to all plugins since it is possible for plugins
to interact, but I would argue that this would create unnecessary
constraints.  If one plugin really requires another plugin, one
should first rethink whether the plugins are being used sensibly,
and if they really are, then the plugin should just check for the
existence of a variable/property defined by the other plugin.  The
case of buildable plugins is a little different because a plugin
may not even work before it is build.

If we require buildable plugins to have platform type "indep", then
it's probably also okay for plugin.interface files to have after-build
files, something that is currently disallowed since plugins are
instantiated for each possible platform.

In order to make it possible for the outcome of a plugin's build step
to influence what platforms it provides, it will be necessary for
abuild to build a plugin before executing its list_platforms file.


Building Abuild
===============

 * Consider creating a ./configure that finds boost libraries and
   deals properly with pthread.  Then consider packaging auto-srcs
   with abuild sources.  Check on debian to see if this works with the
   latest flex.  Consider making the re-entrant scanner switch, made
   possible by controlling the flex and bison files provided that
   there is an autoconf check for the right versions of flex and
   bison.  See ~/source/work-software/argon/third-party-support/boost
   for sample boost autoconf code.

   It might be possible to make this work properly when abuild is
   building itself by having a buildable plugin that checks to make
   sure configure has been run.  Bootstrapping makefile can fail if
   configure hasn't been run.


Revamped Build Tree Structure
=============================

Problem Statement
-----------------

A principal failing in abuild 1.0 stems from the use of paths to
specify the locations of external build trees -- "external-dirs" is
used to convey both dependency and location information.  This is
against a fundamental design principle of abuild and must be
corrected.  Another serious problem is the interaction between backing
areas and externals: setting up backing areas for trees with lots of
externals is complex to the point of being impractical.

Projects that desire certain parts of their trees to be potentially
compile-time independent from other parts have to break things into
multiple trees and use externals.  This sometimes results in build
areas consisting of many more trees than I envisioned in my original
design.  (I had originally envisioned externals as being a rarely-used
feature, primarily intended for supporting builds at multiple
classification levels or supporting central libraries of reusable
build items.)

Consider first the case of externals without backing areas.  If there
are multiple build trees with complex "external" relationships between
them, then there is an implicit build "forest" consisting of multiple
build trees which must be organized relative to each other in a
particular way.  Knowledge of this relative organization of trees is
not represented in any one place but rather is distributed through all
the root Abuild.conf files, usually with considerable but non-obvious
duplication of knowledge (exactly the situation abuild's name-based
organization was designed to avoid).  For example, if A, B, C, and D
are build trees whose roots are under a common parent, you could have
a situation in which A declares ../B and ../C as externals and B
declares ../D as an external.  There is no single place where A, B, C,
and D are even all mentioned, yet abuild will require them to all be
in the same directory.  This situation becomes much worse when build
trees are at different levels -- the same tree may be referred to by
multiple different relative paths.  This creates great confusion, and
makes it very to move a tree around or even find who is referencing a
particular tree.

When backing areas are added to the mix, the problem is further
compounded.  If a build tree contains other external build trees
nested inside of it, use of a backing area with the parent tree, in
practice, requires use of a specific backing area on the child tree,
especially when externals need to be resolved from a backing area.
Consider this arrangement of build trees:

   A       F
 / | \    /
B  C  D  G
|
E

with the following external relationships:

E -> C, D
D -> G

Suppose you have a backing area forest containing A and F, and a local
build area containing only A.  In this case, in the local A, it is
necessary to have backing areas for E, C, and D in, and they all have
to point to the right locations under A's backing area.  In addition
to that, people remain generally in the dark about how externals are
resolved through backing areas.  It's (understandably) hard for people
to understand the idea that a relative path expressed in an
Abuild.conf file may be resolve relative to another directory that is
listed in an Abuild.backing file.

In defense of the original design, when abuild was a simple perl
script that used "make" to do most of its work, this made the initial
implementation very easy -- abuild just replaced the tree top path
with the backing area path and re-invoked itself.  However, given the
current state of abuild's evolution and an understanding of how these
features are actually used, it is obvious that the current
implementation is no longer tenable.

It is clear that build trees deserve to be named entities, and that
just as is true with build items, the location of any given tree must
appear in only one place within a build area.  It is also clear that
use of backing areas when multiple trees are involved is too
cumbersome to be practical.

A better traversal system is required in order to make abuild aware of
all the possible build trees and their locations.  The following other
problems must be addressable by this:

 * It is impossible to pass information, such as extra compilers or
   flags, backwards across the external gap, so if you use a
   collection of common build items (like tps-build-items), there's no
   way to get those items to compile using your own compiler.  This
   applies also to test suite build items that are separate trees
   nested within the tree that provides the items they are testing.
   (tests for boost, xbinder, etc.).  This problem is addressed by the
   support of global plugins.

 * If it is desired to build one portion of a build area without
   having other portions build, there needs to be a mechanism for
   abuild to treat certain trees as read-only for the duration of the
   build, but this information should probably not be encoded into the
   Abuild.conf files.  Consider:

         A
       / | \
      B  C  D

   If B and D both have C as an external and are independent from each
   other, you might want to build C first and then have both B and D
   built in parallel while treating C as read only.  Maybe we can
   specify one or more read/write or read-only roots on the
   command-line.  If none are specified, all externals are read/write.
   If read-only roots are specified, all externals are read/write
   except for those explicitly listed as read-only.  If any read/write
   roots are specified, all externals are read-only except those
   specified as read/write.  It is an error to specify both.

 * It would be nice to be able to build everything from a single build
   even if there is no single build item that can see all the build
   trees.  In the above example, there may be no single place from
   which B, C, and D are all known, but it would still be nice to be
   abuild to do a build that includes all the trees, even if B and D
   have duplicated names in them.

 * Name disambiguation would be nice across build trees.  Named trees
   allows fully qualified build items of the form tree::item.  If
   build item A includes X and Y with X -> Y and build tree B shows up
   with its own Y, a reference to Y from within A should resolve to
   A's Y.  If there is a desire to reach a Y in tree B, A can refer to
   B::Y.  Need to think about how this interacts with name-based
   access control, but it will probably interact fine.  Since colon is
   not currently a valid character in a build item name, there is no
   issue with backward compatibility.

 * It would be good if errors in a part of the collection of build
   trees that are not relevant to you don't impact your build.  For
   example, a build of B above should not fail or even necessarily
   tell you if there are errors in D.  Perhaps we can figure out which
   trees are touched in a build set and disregard errors in untouched
   trees unless --full-integrity is specified.

 * There is no way to find all build tree roots without doing an
   exhaustive search of all Abuild.conf files.

Solution
--------

Introduce this file system hierarchy restriction: all build items in a
local collection of build trees, called a "build forest", must be
located physically under the root of the topmost build tree.

Imposing this restriction makes it possible to eliminate the
parent-dir key.  Enforcing this restriction involves verifying that
child-dirs may not contain .. in any path element, and that there are
no intervening Abuild.conf files between a parent and child
Abuild.conf.

This also implies elimination of absolute path externals, and makes it
impossible to have multiple roots without a common parent directory.
Although this is strictly a loss of functionality, it eliminates
something that's not really a good practice anyway.  In particular,
having multiple roots to the collection of build trees creates
confusion and makes it hard to know what you're dealing with.  This
makes it harder to split builds across physical disks, but doing so is
already impractical with parent and child pointers, and using junction
points (Windows) or bind/loopback mounts (UNIX) can provide a viable
alternative.

Allow Abuild.backing files only at forest roots.  This makes it
impractical to have one subtree back to something different from the
rest of the build forest, but I've never seen anyone attempt to do
such a thing anyway, and even if they did, it would probably only work
if that backing area itself backed to the common one used by the other
subtrees.

Require build tree root Abuild.conf files to include a "tree-name" key
which provides the name of the build tree.  Any Abuild.conf file may
contain a tree-name key.  This makes it the root of a subtree, which
functions very much as externals do in abuild 1.0.

Replace "external-dirs" with "tree-deps" which takes a list of tree
names rather than tree paths.  Since we have no longer have the
concept of externals, we no longer have the concept of read-only
externals.  To support the pattern of building a tree without building
any of the other subtrees that it uses, we add another mechanism such
as declaration of one or more read-only or read/write root directories
outside of which all build trees are to be treated as read-only, or
perhaps explicit specification of read-only or read/write build trees,
though it's less clear in that case how to handle nested subtrees.

Traits, supported flags, and plugins behave with respect to subtrees
in 1.1 just as they behaved with respect to externals in 1.0.  This
means that it is still necessary to repeat plugin declaration lists
for each subtree.  Although this is somewhat unfortunate, it makes it
possible to have reasonable semantics when building an isolated
subtree outside of the context of a backing area.  (That said, a
build's behavior could still potentially be changed by global plugins
that would inherit through the backing area.)

Example:

  OLD:

   Top-level Abuild.conf files in each leaf below.  No way to know of
   all build trees or their relative positions without visiting each
   root.  No way to get list of build tree roots other than exhaustive
   search.

   top                  (no Abuild.conf)
   |
   |-- common           root Abuild.conf; no externals
   |
   |-- proj1
   |   |
   |   |-- interface
   |   |   |
   |   |   |-- comp1    external-dirs: ../../../common
   |   |   |
   |   |   `-- comp2    external-dirs: ../../../common
   |   |
   |   `-- private
   |       |
   |       |-- comp1    external-dirs: ../../interface/comp1
   |       |
   |       `-- comp2    external-dirs: ../../interface/comp2 ../comp1
   |
   `-- proj2
       |
       |-- common       external-dirs: ../../common
       |
       |-- comp1        external-dirs: ../common
       |
       `-- comp2        external-dirs: ../comp1

  Note that ../../common from proj2/common is the same as
  ../../../common from proj1/interface/comp1 and different from
  ../common in proj2/comp1.


  NEW:

   Top-level Abuild.conf file in top directory; subtrees are hooked in
   with child-dirs just like any other subdirectory.

   top                  tree-name: top
   |
   |-- common           tree-name: common
   |
   |-- proj1
   |   |
   |   |-- interface
   |   |   |
   |   |   |-- comp1    tree-name: proj1-comp1; tree-deps: common
   |   |   |
   |   |   `-- comp2    tree-name: proj1-comp2; tree-deps: common
   |   |
   |   `-- private
   |       |
   |       |-- comp1    tree-name: proj1-comp1-impl; tree-deps: proj1-comp1
   |       |
   |       `-- comp2    tree-name: proj1-comp2-impl;
   |                    tree-deps: proj1-comp2 proj1-comp1
   `-- proj2
       |
       |-- common       tree-name: proj2-common; tree-deps: common
       |
       |-- comp1        tree-name: proj2-comp1; tree-deps: proj2-common
       |
       `-- comp2        tree-name: proj2-comp2; tree-deps: proj2-comp1



Traversal algorithm:

 * Find the root of the current build forest.

   cur_build_item = this directory
   forest_top = nil

   do until end search
     if cur_build_item's Abuild.conf contains tree-name key
        forest_top = cur_build_item
     parent_build_item = next higher Abuild.conf
     if parent_build_item exists and has child pointing to cur_build_item
        cur_build_item = parent_build_item
     else
        if forest_top == cur_build_item
           this is found forest root
	   end search
        else
           forest_top = nil
           error: unable to find top of build forest

   Note that if a parent Abuild.conf is found but it doesn't have a
   child-dirs key that points to the child build item and if the child
   build item is a build tree root, the search stops, and there is no
   error or warning reported.  This is a normal case of a separate,
   independent tree nested inside another tree.  Examples of when you
   might have this would include test suites that create build trees
   (such as abuild's own test suite) or instances in which abuild may
   be used to build third-party software distributions nested within
   something that contains Abuild.conf files.  If this tree was
   supposed to be connected into higher trees and was not, there will
   probably be unresolved tree-deps or deps values.

 * If the root of the forest does not contain an Abuild.backing, then
   this is an unbacked forest.  If it does contain an Abuild.backing
   file, ensure that it points to a tree root (not necessarily a
   forest root).  In that case, search for the backing tree's forest
   root.  Continue until an unbacked forest is found.  Traverse the
   unbacked forest (as described below).

   Note that we impose no restrictions on whether the backing area
   points to the same tree or even to a backing forest that contains
   the same tree.  This makes it possible to add an entirely new
   subtree in a work area that backs to some other area, and then to
   have the backing area later get included inside of a higher-level
   tree without impacting the work area.

 * Traverse the build forest.

     traverse:

     if current item has a tree-name key
        set cur_tree to name of tree
     store current build item in cur_tree
     for each dir in child-dirs
        ensure that dir has no path elements equal to ".."
        if dir has more than one path element
           ensure that no intermediate directories have Abuild.conf
        traverse recursively from dir

 * Verify that each tree in the forest is uniquely named

 * Copy build items from the backing area forest that are absent from
   the local forest into the local list.  Exclude build items that are
   listed as deleted or that belong to trees that are listed as
   deleted in the Abuild.backing file.

 * Make sure that the graph implied by the tree-deps key is an
   error-free directed acyclic graph.  Do not do checks to ensure that
   is bipartite with respect to backing area traversal; save this
   check for the build item level.  This makes it possible to sparsely
   shadow a build tree for the purpose of adding items to it.

 * Check dependencies and build item references (but do not report
   errors) for the whole forest rather than doing it separately for
   each build item and copying build items around.  (We only copy
   build items from backing areas, not subtrees.)  Just disallow
   resolution of any build item name in a tree not declared as used.
   This makes it possible to issue error messages akin to "A is not
   allowed to depend on B since A-tree has not declared B-tree as in
   its tree-used key."

 * If in full integrity mode, report all dependency and integrity
   errors.  Otherwise, report errors only for subtrees relevant to the
   current build.

Figure out how to make global plugins work with this and what
restrictions, if any, should be imposed on them (like maybe they're
not allowed to have interfaces or rules but are just allowed to be
platform type or compiler plugins).  Shouldn't be that hard.

Need to flesh out an example that includes both searchlight and
lh3-style trees.  Think about external build item library concept,
whether it's sensible, and how it interacts with global plugins.  Also
consider the case of nested build trees with externals that point up
such as in the test suites of some of the plugins.  How should the be
handled for --build=all?  We probably need a new build set that does
what 1.0's --build=all does (in other words, build all trees that are
referenced from the current build item) and save --build=all to build
the whole forest.  (I bet lots of people think this is what it does
now anyway.)


Compatibility
=============

When abuild starts up, a version compatibility flag may be provided.
We should probably support this from the command line or from the
environment.  If no flag is specified, abuild should attempt to
automatically determine whether to run in 1.0 compatibility mode.
Abuild must store the reason why it chose a particular version so it
can report that in error messages as needed.  By default, abuild will
give deprecation warnings for 1.0 constructs.  These can optionally be
made into errors, but they cannot be suppressed.

Think about whether it is possible to support some kind of hybrid mode
where some build trees are 1.0 and some are 1.1.  That might make
migration easier.

 * If build item has a parent-dir or external-dirs key, use 1.0

 * Else if the local build item has an name key or any other key
   that was introduced in version 1.1, use 1.1

 * Else if build item has any keys that are allowed in build tree
   roots or has an Abuild.backing file, use 1.0 (since if it had a
   tree-name key, we would have already chosen 1.1)

 * Else if build item has a child-dirs key and child build item has a
   parent-dir key, use 1.0

 * Else could be single-build-item 1.0 tree or normal case 1.1 build
   item.  If the next higher Abuild.conf refers to this as a child,
   use 1.1.  Otherwise, give a warning and proceed to treat as a
   single build-item 1.0 tree.

----------------------------------------------------------------------

=== Things with no Specific Release Target ===

Windows Issues
==============

 * There are some Windows path issues.  You can't use absolute paths
   in Windows as long as cygwin is in use because cygwin gnu make will
   not interpret absolute paths in the same way that Windows will for
   purposes of dependencies in .dep files, library dependencies, etc.
   Relative paths should work, but they don't always work because
   Windows seems to have limits on the number of times .. may appear
   in a path (among possibly other things), and besides, there is no
   way to construct a relative path to a file under another drive
   letter.  Ideally, we should be using something like msys and/or
   gnuwin32 rather than cygwin, along with supporting ActivePerl, but
   this has major implications since qtest doesn't currently work
   without cygwin, not to mention the fact that the test suite makes
   free use of unix constructs.

 * gen_deps: rewrite in C++ so that it doesn't force a runtime
   dependency on perl.  It should be a fallback for cases when
   compilers can't generate dependency information.  With gcc, use -MD
   -MF -MP to generate proper .dep files.  xlc: "-M -MF a.dep" works,
   but there is no equivalent to -MP, so we'll need to postprocess.
   VC: there seems to be a /showIncludes option that we may be able to
   exploit.  Not sure what versions of VC++ have this.  This will be
   worth doing if we can remove a runtime dependency on Cygwin for
   Windows/C++.  For non-Windows systems, requiring perl is not a big
   deal.


Compiler/Platform Configuration
===============================

There is a general problem with compiler options, 32-bit and 64-bit
compilers, project-specific configuration, supporting compilers that
aren't known in advance, etc.  This is kind of what toolset was
designed to handle.  The following items are possibly contradictory or
interdependent and need to be sorted out better.  These items all
imply certain things that may need to be done very early in abuild's
life even before private/bin/get_native_platform_data is called.

 * Need a more flexible way of handling compiler options.  It should
   be possible to create plugins that add compiler options to
   internally supported compilers, and options should be able to be
   meaningfully selected in groups.  For example, it should be
   possible to add {m32, m64} that can't be specified together and
   {debug, release} that can't be specified together while allowing
   debug+m32 or release+m64 or other permutations.  This implies the
   need for a canonical form.

 * We need some way for people to change the toolset portion of the
   platform string in a global way for a particular collection of
   build trees.

 * There needs to be better cross-compiler support for things like
   building 32-bit code on a 64-bit system.  Adding -m32 doesn't
   really do it because why should have you
   linux.x86_64.rhel51.gcc.m32 be the same as linux.ix86.rhel51.gcc?


Java Problems
=============

We probably need a different approach to Java.  Ant was not designed
to be used as a framework, and it doesn't work very well when used in
this way.

 * In order to get wars in ear files, we need to add them to
   abuild.classpath.  Although this is harmless, it's sort of an abuse
   of abuild.classpath.

 * Ant launcher: consider having a Java-based ant launcher that abuild
   communicates with via some kind of IPC to make launching ant more
   efficient.  See ~/argon/tmp/ant-launcher and email X-ArgonCount:
   23536 in abuild, 4/3/2008, subject "preliminary ant launcher
   experiment".  For communication between abuild and the ant
   launcher, see ~/source/examples/portability/socket-java-c++-workers.

 * ant with build failure appears not to exit abnormally in Windows.
   This is a bug in ant.bat and could be worked around by using our
   own ant launcher.

 * We don't detect when inaccessible build items are referenced in
   abuild.hook-build-items.  This won't matter anymore if we move hook
   specification to Abuild.conf.

 * Abuild has no real way to support a difference between compile-time
   classpaths and run-time classpaths.

 * Reconsider using depends task for compile in abuild.xml.

 * Signed jar support will eventually be required.  See whether this
   should be provided by default.  Most likely it should not as it can
   be provided easily with a hook.

 * Our default java compile rule doesn't notice if a .java file was
   removed.  Maybe we want to force full recompilation if the list of
   files changed, or maybe we want to delete class files that appear
   to have come from non-existent java files.  I'm not sure what
   happens with nested/inner classes that disappeared....does javac
   automatically remove the corresponding class files?  This would be
   an easy experiment to try.

 * Consider supporting creation of multiple jar files with different
   contents analogous to different libraries being created from a
   single C++ build item.

 * Ant seems to not complain when populating an ear file from a
   classpath that contains non-existent items.  In general, there may
   be an issue with not getting any notification of non-existent
   classpath items.  Note that, sometimes, you want to try to create
   an ear even of some of its contents aren't there, so this may not
   really be a problem worth fixing.  If we can fix it, we should be
   able to control on a per-build-item basis whether it is an error
   condition or just a warning, probably having "error" be the
   default.

 * The classpath in the manifest for a jar should only include
   first-level dependencies.  Transitive dependencies are satisfied
   automatically.


Known Bugs
==========

 * Piping ANSI color stuff through ant on Windows doesn't work.  When
   running qtest from ant on Windows, qtest correctly generates the
   ansi color codes, but they don't get displayed right through ant,
   at least in cygwin.


Issues, Enhancement Ideas
=========================

See also "Known Limitations" in the documentation.

 * Test qtest coverage from abuild test suite.  Relatively low
   priority since abuild's test suite itself uses coverage, so
   abuild's qtest coverage support is exercised every time the abuild
   test suite is run.  (It's just that you might not notice if it
   weren't there.)

 * Think about implementing a dependency analyzer that would look at
   first-level includes to figure out what the correct list of direct
   dependencies should be.

 * Consider having --silent invoke make with --no-print-directory.  If
   we do this, we should follow build item failure with a message that
   contains the name, path, and platform of whatever failed.

 * Consider having an abuild template generator that can run if no
   Abuild.conf or other files are present.  This would spit out
   commented template files.  Alternatively, could be a command-line
   wizard or something.

 * To check for all Abuild.mk files that define local targets:
   pcregrep '^\s*\S+\s*:(\Z|[^=])' **/Abuild.mk

 * Consider using re-entrant scanners instead of C++ scanners.  This
   requires flex >= 2.5.33.  Have abuild's own build process detect
   whether or not a new enough version of flex is available.  If so,
   it should generate the parsers and attempt to update a cached copy
   of the automatically generated files if they have changed.
   Otherwise, it should use the cached files by adding them to SRCS in
   place of the automatically generated ones.  We also need to disable
   warnings for the flex-generated code.  Use %option nounistd.  (This
   suggestion may be simplified if better support for files generated
   by optional tools is added.)

 * It would be nice if there were a mechanism for providing
   documentation on traits so that --list-traits could tell the user
   how each trait was intended to be used.

 * Consider capturing the output of the backend so that we can
   de-interleave output when running parallel builds (or mark each
   line of output with the build item/platform data), separate error
   from informational output, etc.  It is possible to create pipe-like
   handles with CreatePipe in Windows and to use them to initialize
   hStdInput, hStdOutput, and hStdError fields of the startupinfo
   parameter to CreateProcess.  There is an example at
   http://lists.trolltech.com/qt-interest/1999-09/thread00282-0.html
   There is also some kind of Win32 Job API used by the perl
   Win32::Job classes (CreateJobObject).  This may provide a better
   solution than our current CTRL-C handling.  See if boost provides
   anything that could do this.

 * Clean up ~/source/examples/java/native/abuild and use as JNI
   example

 * ccxx: Consider enforcing that no object file may appear both as a
   program and a library object file and that no object file may be
   generated from more than one source file (with different suffixes)

 * Consider converting abuild_data.dtd to a schema for tighter
   validation (which attributes are allowed in which contexts).
   Search for DTD in the documentation and test suite.  Probably don't
   really want to do this.

 * In the manual, it would be nice if we could use higher resolution
   figures for the PDF than for the HTML.  There is plenty of material
   in the sagehill.net DocBook XSL guide about this.  The best
   solution would be to convert the figures to SVG.  It may work to
   use graphviz to generate the SVG.

 * Orphan target detection won't find orphan targets in
   subdirectories.  This is very hard to fix in general.  We could
   search directories represented in the source lists, but that
   wouldn't help if we removed the last file from a subdirectory.  For
   now, we'll just not handle this case.

 * Mingw support isn't that complete: see known limitations in the
   documentation and comments in private/list_platforms.  If it is
   improved, consider improving support for recognizing it so that the
   user doesn't have to set MINGW=1.  Search for mingw in the
   documentation and adjust as needed.

 * Consider adding a trouble shooting section to the documentation,
   web site, or wiki

    - example: library name inconsistency between Abuild.mk and
      Abuild.interface

 * Cass Dalton reports that he sometimes gets "resource busy" errors
   when running autoconf with --make-jobs.

 * Abuild.interface files necessarily duplicate information from
   Abuild-ant.properties or Abuild.mk such as jar names or library
   names.  This is probably okay as you can always avoid it by having
   a convention of setting "local" variables (i.e., variables named in
   such a way to not conflict with anything) that are referenced in
   the Abuild.mk or Abuild-ant.propertiesd. files.
