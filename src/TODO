Next
====

 * Bug: make_shlib should use $(1), not $(CXX) as linker.  Check all
   compiler toolchain files.

 * To override OFLAGS, DFLAGS, or WFLAGS globally, it is necessary to
   prefix the assignment with "override" in Abuild.mk.  This needs to
   be mentioned in the documentation.


Version 1.1
===========

General
-------

 * It would be nice if -p native:skip didn't actually disable native
   platforms but instead just took them out of the default build list.
   That way, when doing -p native:skip, if a java or indep build item
   depends on a native build item, abuild can still build the native
   item "as needed" just as it would for other platform-specific
   dependencies.  While we're at it, it should be possible to disable
   java and indep build items in this same way, and maybe also to
   specify indep-only or java-only.

 * Remove temporary ABUILD_FORCE_32BIT hack.  Search for FORCE32 in
   the code.  The only references are in
   private/bin/get_native_platform_data and make/toolchains/gcc.mk.
   For a description, see release notes in the documentation.

 * Inheritable or Global plugins.  It would be nice if we could
   declare a plugin as automatically inheriting across externals.
   This might be related to site configuration or rethinking build
   tree status.

 * Need a better solution for automatically generated files that might
   be controlled in some cases to work around lack of tool support.
   Abuild itself could use this for flex/bison files.  We could also
   use it for cases like xbinder where generating the files requires a
   special license.  We need a clean way to handle the following:

    - Regeneration of the files if they are out of date and the tools
      are available.

    - Use of cached files if they are not out of date.

    - Error if the files are out of date and the tools are not
      available.

   This implies, at least for these cases, some kind of checksum-based
   method (rather than using modification times) to tell whether files
   are out of date.  That way, checkouts from the version control
   system can work without modification time preservation.

 * Consider creating a ./configure that finds boost libraries and
   deals properly with pthread.  Then consider packaging auto-srcs
   with abuild sources.  Check on debian to see if this works with the
   latest flex.  Consider making the re-entrant scanner switch, made
   possible by controlling the flex and bison files provided that
   there is an autoconf check for the right versions of flex and
   bison.  See ~/source/work-software/argon/third-party-support/boost
   for sample boost autoconf code.


Rethink Status of Build Trees
-----------------------------

Incorporate:

 * Removing parent-dir and child-dirs is not a good idea.

 * We need some kind of tree location algorithm.  It should still work
   to have

   A common B

   where A and B are completely independent but both use common
   without having them all getting combined.  Maybe it would be okay
   for building A to notice B, but errors in B should not even be
   reported when building A.

 * See if there is any need for externals at all.  See if there is
   still a need for absolute path externals or read-only externals.

-----

It has become clear that build trees deserve to be named entities.  It
seems that we are using externals for things for lots of purposes, and
maybe we need to rethink.  See "Tree Registry" for one idea of how to
approach this, though I no longer favor that particular idea.

A fundamental issue is that, the way we are using externals, there is
an implied relationship among multiple different build trees that
comprise the overall build of a particular project.

Just like abuild currently forms a mapping between build item names
and paths, it would be nice if abuild could do something similar for
build trees.  One idea would be to have some kind of rules that you
could code or otherwise specify that would help abuild locate build
trees.  Another option would be to make build trees more flexible so
that we don't have to split them in all the cases we do now.

Here are some of the problems we need to address:

 * Projects that desire certain parts of their trees to be potentially
   compile-time independent from other parts have to break things into
   multiple trees and use externals.  This creates several problems:

    - Plugin declarations have to be duplicated

    - It is impossible to pass information, such as extra compilers or
      flags, backwards across the external gap, so if you use a
      collection of common build items (like common-abuild-library),
      there's no way to get those items to compile using your own
      compiler.  This applies also to test suite build items that are
      separate trees nested within the tree that provides the items
      they are testing.  (tests for boost, xbinder, etc.)

    - Information about relative locations of external build trees are
      proliferated throughout all the root Abuild.conf files.

There are some general problems, such as the fact that an error in an
unrelated part of the build system can prevent your build from
working.  These problems are mitigated by using externals, but it
would be out of control to create every island of dependency-isolated
build items and put them in an external.  We need different sorts of
barriers that we can create without having to use externals.

This reminds me of multiple baselines in BCS.  Externals as currently
implemented kind of point toward the mulitple single points of failure
problem.  Maybe they need to be eliminated entirely.  Maybe we need
some kind of opaque parent/child relationship or something.

Here's a partial solution.

 * Remove parent-dir, child-dirs, and external-dirs.

 * Add a new key "tree" that takes the name of a tree.

 * Add new optional keys "traverse-up" and "traverse-down", if needed.
   These are legal everywhere except for absolute tree tops
   (a.k.a. forest roots, at least for now).

Traversal algorithm:

 * Start at current build item and walk up the tree until a build item
   with a "tree" key is found.  If the parent directory does not have
   an Abuild.conf, it is an error.  (Possible "traverse-up" key to
   indicate where upward traversal should continue, but maybe this is
   a bad idea.)  When a tree: key is encountered, this is a build tree
   root.

 * Follow the chain of Abuild.backing files until a tree is reached
   with no backing file.

 * Traverse downward.  When an Abuild.conf is found, check all direct
   child directories that are not abuild output directories for
   Abuild.conf files.  This means we have to do an opendir and
   readdir, but it's still not an unbounded search.  (Possible
   "traverse-down" to allow skipping directories, but this may be a
   bad idea.)

 * When traversing downward, additional tree roots may be
   encountered.  Recursively traverse those.

 * Once tree is traversed, compare the list of known build items with
   the list of referenced build items (trait referents, dependencies).
   (Is this only within the tree, or do we somehow look at all known
   items?  Maybe we only look at the backing chain but not other trees
   at the same level?  Maybe we only look at items within the same
   tree in the backing chain?)  The latter probably has to be done at
   a later stage.)  If the tree is referentially closed, traversal is
   complete.  Otherwise, unless the "-forest-root" option has been
   specified after the tree name (need something better than "forest
   root" or "absolute top"), continue upward traversal again looking
   for a tree root.  This is tricky because when we traverse downward,
   we will encounter subtrees.  We'll probably have to do another
   referential integrity check later after we've traversed everything.

 * Backing areas: when a tree root points to another tree root, we
   probably want to require that the destination be a tree root of a
   tree with the same name.  That may clear up some issues.

 * Additional integrity checks: rather than requiring trees to declare
   other trees that they use, we'll construct a dependency graph of
   trees.  (Need to think about how this interacts with backing areas.
   Are tree and tree' one tree or two trees?)  If tree A has an item
   that depends on an item in tree B, then there is a dependency
   between tree A and tree B.  This graph must also be acyclic.  This
   analysis needs to be done with expanded dependencies, in which case
   it should implement one-way dependency gates.  Open question: what
   about non-dependency relationships?  I'm thinking no name
   resolution is allowed to cross back across these gates, making this
   very much like externals now, except perhaps with regard to global
   plugins, which we have to define.  The idea of global plugins,
   including allowing them to disregard the "external" boundaries, may
   solve problems like adding new compilers for all trees.  However,
   this interacts poorly with the idea of stopping traversal at the
   root of a referentially closed tree.  Maybe that's a bad idea.
   There aren't many advantages to stopping traversal at the root of a
   closed tree, other than perhaps efficiency gains, particularly if
   we can disregard errors that don't impact any items in the current
   build set.

Need to flesh out an example that includes both searchlight and
lh3-style trees.  Think about external build item library concept,
whether it's sensible, and how it interacts with global plugins.

Java
----

 * Ant launcher: consider having a Java-based ant launcher that abuild
   communicates with via some kind of IPC to make launching ant more
   efficient.  See ~/argon/tmp/ant-launcher and email X-ArgonCount:
   23536 in abuild, 4/3/2008, subject "preliminary ant launcher
   experiment".

Compiler/Platform Configuration
-------------------------------

There is a general problem with compiler options, 32-bit and 64-bit
compilers, project-specific configuration, supporting compilers that
aren't known in advance, etc.  This is kind of what toolset was
designed to handle.  The following items are possibly contradictory or
interdependent and need to be sorted out better.

 * Need a more flexible way of handling compiler options.  It should
   be possible to create plugins that add compiler options to
   internally supported compilers, and options should be able to be
   meaningfully selected in groups.  For example, it should be
   possible to add {m32, m64} that can't be specified together and
   {debug, release} that can't be specified together while allowing
   debug+m32 or release+m64 or other permutations.  This implies the
   need for a canonical form.

 * We need some way for people to change the toolset portion of the
   platform string in a global way for a particular collection of
   build tres.

 * There needs to be some kind of "site" configuration that lives in a
   build tree that may be at the base of the externals chain.  This
   should be like a plugin but we need the ability to support some
   kind of build/configuration.  For example, it should be possible to
   generate toolsets or change default compiler options based on the
   output of ./configure or to set things that are specific to which
   compiler is used.

 * It would be nice to have some way to support libtool and a generic
   UNIX compiler such that if you could specify it with ./configure,
   you could build using abuild with it.  This may figure into the
   site configuration somehow.  Ultimately, it should be possible for
   a given project to be configured such that its build trees build
   with a particular compiler and particular options, and this should
   be possible to do without modifying abuild or requiring every
   single build tree to take some specific actions.

 * There needs to be better cross-compiler support for things like
   building 32-bit code on a 64-bit system.  Adding -m32 doesn't
   really do it because why should have you
   linux.x86_64.rhel51.gcc.m32 be the same as linux.ix86.rhel51.gcc?


Platform Conditionals
=====================

People want conditional dependencies, but mainly for platform issues.
Consider one or both of the following ideas:

 * Platform restrictions per build item.  If a build item has a
   platform restriction, it will be excluded from the initial build
   set construction.  Then what happens if it get pulled in to satisfy
   a dependency?  This should be an error, but that causes problems in
   some cases.  See next idea for a possible solution.

 * Sometimes we use dependencies just to force something to build, as
   in the case of the "compile-all" item in searchlight or some
   "top-level" builds.  We really need the concept of a "build-also"
   keyword that specifies build items that should be built if this one
   is built.  It effectively just adds them to the build set.  The
   build-also keyword doesn't have any restrictions about cycles -- it
   is just used during inital build set construction.  As such, it can
   have platform-based conditionals.

Using these two features together, it should be possible to achieve
the goal of supporting platform-based conditional dependencies in a
safe manner.


Java Problems
=============

We probably need a different approach to Java.  Ant was not designed
to be used as a framework, and it doesn't work very well when used in
this way.

 * In order to get wars in ear files, we need to add them to
   abuild.classpath.  Although this is harmless, it's sort of an abuse
   of abuild.classpath.

 * We don't detect when inaccessible build items are referenced in
   abuild.hook-build-items

 * Abuild has no real way to support a difference between compile-time
   classpaths and run-time classpaths.

 * NOTE: It was necessary to create /usr/{share,lib}/java-1.6.0 in
   order for build-classpath from jpackage to do the right thing when
   launching ant 1.7.0 in fedora core 5.  Not sure how general of a
   problem this is.

 * Reconsider using depends task for compile in abuild.xml.

 * Signed jar support will eventually be required.

 * Our default java compile rule doesn't notice if a .java file was
   removed.  Maybe we want to force full recompilation if the list of
   files changed, or maybe we want to delete class files that appear
   to have come from non-existent java files.  I'm not sure what
   happens with nested/inner classes that disappeared....does javac
   automatically remove the corresponding class files?  This would be
   an easy experiment to try.

 * Consider supporting creation of multiple jar files with different
   contents analogous to different libraries being created from a
   single C++ build item.

 * Ant seems to not complain when populating an ear file from a
   classpath that contains non-existent items.  In general, there may
   be an issue with not getting any notification of non-existent
   classpath items.

 * We use the privately set "debug" and "deprecation" properties in
   abuild.xml to set debug and deprecation.  These should really be set
   using documented abuild properties, and we should figure out what
   other similar properties we might want to set in this way.

 * There is presently no mechanism for adding a new build target that
   is visible to all build items (as one can do with plugin.mk in
   make-based builds).  Figure out again why we can't add a custom
   target in ant code that is loaded as a plugin or hook build item.
   Was there a reason we didn't use import?

   I think the reason is this: with make, if two different build items
   define the same target, if at least one uses a : target instead of
   a :: target, it's an error.  Otherwise, all the variants of the
   target get run.  With ant, there is no such facility.  All but one
   of the definitions of the target will get mangled to
   project.target, and there's no way to run all of the
   implementations.  The only way to get this behavior right now is to
   use hooks.

 * You have to duplicate the archive name (abuild.jar-name, etc.) in
   the Abuild.interface file.


Issues, Enhancement Ideas
=========================

See also "Known Limitations" in the documentation.

 * ant with build failure appears not to exit abnormally in Windows.

 * gen_deps: rewrite so that it doesn't force a runtime dependency on
   perl.  It should be a fallback for cases when compilers can't
   generate dependency information.  With gcc, use -MD -MF -MP to
   generate proper .dep files.  xlc: "-M -MF a.dep" works, but there
   is no equivalent to -MP, so we'll need to postprocess.  VC:
   nothing.

 * Test qtest coverage from abuild test suite

 * Think about implementing a dependency analyzer that would look at
   first-level includes to figure out what the correct list of direct
   dependencies should be.

 * Consider having --silent invoke make with --no-print-directory.  If
   we do this, we should follow build item failure with a message that
   contains the name, path, and platform of whatever failed.

 * Consider having an abuild template generator that can run if no
   Abuild.conf or other files are present.  This would spit out
   commented template files.  Alternatively, could be a command-line
   wizard or something.

 * Piping ANSI color stuff through ant on Windows doesn't work.  When
   running qtest from ant on Windows, qtest correctly generates the
   ansi color codes, but they don't get displayed right through ant,
   at least in cygwin.

 * To check for all Abuild.mk files that define local targets:
   pcregrep '^\s*\S+\s*:(\Z|[^=])' **/Abuild.mk

 * It might be useful to have the ability to find all references to a
   particular interface variable and/or to find the origin and
   variable history for a specific variable.  This comes back to the
   interface tracing mode or dump mode.  Examples: I see some
   interface variable in a build item's Abuild.interface file and want
   to know who uses it, or I see some variable in someone's
   Abuild-ant.properties or Abuild.mk and want to know who defines it.

 * Consider useing re-entrant scanners instead of C++ scanners.  This
   requires flex >= 2.5.33.  Have abuild's own build process detect
   whether or not a new enough version of flex is available.  If so,
   it should generate the parsers and attempt to update a cached copy
   of the automatically generated files if they have changed.
   Otherwise, it should use the cached files by adding them to SRCS in
   place of the automatically generated ones.  We also need to disable
   warnings for the flex-generated code.  Use %option nounistd.

 * Test, at least informally, backing areas on different drive letters
   on Windows.  Not sure whether it's worth putting this in the test
   suite.

 * It would be nice if there were a mechanism for providing
   documentation on traits so that --list-traits could tell the user
   how each trait was intended to be used.

 * Consider capturing the output of the backend so that we can
   de-interleave output when running parallel builds, separate error
   from informational output, etc.  It is possible to create pipe-like
   handles with CreatePipe in Windows and to use them to initialize
   hStdInput, hStdOutput, and hStdError fields of the startupinfo
   parameter to CreateProcess.  There is an example at
   http://lists.trolltech.com/qt-interest/1999-09/thread00282-0.html
   There is also some kind of Win32 Job API used by the perl
   Win32::Job classes (CreateJobObject).  This may provide a better
   solution than our current CTRL-C handling.

 * Clean up ~/source/examples/java/native/abuild and use as JNI
   example

 * ccxx: Consider enforcing that no object file may appear both as a
   program and a library object file and that no object file may be
   generated from more than one source file (with different suffixes)

 * Consider converting abuild_data.dtd to a schema for tighter
   validation (which attributes are allowed in which contexts).
   Search for DTD in the documentation and test suite.

 * It would be nice if we could use higher resolution figures for the
   PDF than for the HTML.  There is plenty of material in the
   sagehill.net DocBook XSL guide about this.

 * We really need a way to be able to use autoconf to find out
   information about a specific compiler.  This would be especially
   useful for figuring out what flags to use for PIC when building
   shared libraries.

 * Orphan target detection won't find orphan targets in
   subdirectories.  This is very hard to fix in general.  We could
   search directories represented in the source lists, but that
   wouldn't help if we removed the last file from a subdirectory.  For
   now, we'll just not handle this case.

 * There are some Windows path issues.  Find out the real story behind
   Windows paths.  See whether using absolute paths is better than
   relative paths for Windows.  If so, this has implications as there
   is a mixture of Windows native and cygwin tools in use.

 * Right now, list_platforms has no way to get native os, cpu, or
   toolset data.  See comment in Abuild::loadPlatformData before
   invocation of list_platforms.

 * It would be nice if we could have a flag that would tell abuild to
   capture and de-interleave the output from multiple backends in
   parallel.  See Abuild::invokeBackend.

 * Mingw support isn't that complete: see known limitations in the
   documentation and comments in private/list_platforms.  If it is
   improved, consider improving support for recognizing it so that the
   user doesn't have to set MINGW=1.  Search for mingw in the
   documentation and adjust as needed.

 * Consider adding a trouble shooting section to the documentation,
   web site, or wiki

    - example: library name inconsistency between Abuild.mk and
      Abuild.interface

 * Cass Dalton reports that he sometimes gets "resource busy" errors
   when running autoconf with --make-jobs.

 * Scott Lemke points out that abuild has a lot of knowledge about
   things that are not relevant to any particular build.  One thing to
   consider would be having abuild analyze error conditions to
   determine which ones are not relevant to the local build.  This
   might enable abuild, in some cases, to build a local group of items
   even when there are integrity errors in other parts of the build
   tree.  This may or may not be a desirable feature.

 * It would be nice if plugins could have type indep and could build
   stuff.  It would be nice, for example, to be able to implement a
   compiler plugin that uses autoconf to figure out the correct
   compiler invocation so that it would be possible to support a
   generic unix compiler or libtool from a plugin.
